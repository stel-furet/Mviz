<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Vizzy - Advanced Music Visualizer with Live Display and Multiple Visualization Modes">
    <meta name="keywords" content="music visualizer, audio visualization, live display, spectrum analyzer, music player">
    <meta name="author" content="GitItUp">
    <meta name="theme-color" content="#2969b0">
    
    <!-- Open Graph / Facebook -->
    <meta property="og:type" content="website">
    <meta property="og:title" content="Vizzy-Music Visualizer">
    <meta property="og:description" content="Advanced music visualizer with live display capabilities">
    
    <!-- Twitter -->
    <meta property="twitter:card" content="summary_large_image">
    <meta property="twitter:title" content="Vizzy-Music Visualizer">
    <meta property="twitter:description" content="Advanced music visualizer with live display capabilities">
    
    <title>Vizzy-Music Visualizer</title>
    
    <!-- Favicon -->
    <link rel="icon" type="image/x-icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>🎵</text></svg>">
    
    <!-- Preload critical resources -->
    <link rel="preconnect" href="https://content.app-sources.com">
    
    <!-- Music Metadata Library - Embedded lightweight parser -->
    <script>
        // Lightweight ID3 tag parser for MP3 files
        window.lightweightMetadata = {
            async parseFile(file) {
                try {
                    if (file.name.toLowerCase().endsWith('.mp3')) {
                        return await this.parseMP3(file);
                    }
                    return null; // Use fallback for other formats
                } catch (error) {
                    console.warn('Lightweight metadata parsing failed:', error);
                    return null;
                }
            },
            
            async parseMP3(file) {
                const buffer = await file.arrayBuffer();
                const view = new DataView(buffer);
                
                // Look for ID3v2 tag at beginning of file
                if (view.getUint8(0) === 0x49 && view.getUint8(1) === 0x44 && view.getUint8(2) === 0x33) {
                    return this.parseID3v2(view);
                }
                
                // Look for ID3v1 tag at end of file
                if (buffer.byteLength > 128) {
                    const id3v1Offset = buffer.byteLength - 128;
                    if (view.getUint8(id3v1Offset) === 0x54 && view.getUint8(id3v1Offset + 1) === 0x41 && view.getUint8(id3v1Offset + 2) === 0x47) {
                        return this.parseID3v1(view, id3v1Offset);
                    }
                }
                
                return null;
            },
            
            parseID3v2(view) {
                try {
                    const version = view.getUint8(3);
                    const flags = view.getUint8(5);
                    const size = this.getSynchsafeInt(view, 6);
                    
                    let offset = 10;
                    const metadata = {};
                    
                    while (offset < size + 10) {
                        if (offset + 4 >= view.byteLength) break;
                        
                        const frameId = String.fromCharCode(
                            view.getUint8(offset),
                            view.getUint8(offset + 1),
                            view.getUint8(offset + 2),
                            view.getUint8(offset + 3)
                        );
                        
                        const frameSize = version === 4 ? this.getSynchsafeInt(view, offset + 4) : 
                                         (view.getUint8(offset + 4) << 24) | (view.getUint8(offset + 5) << 16) | 
                                         (view.getUint8(offset + 6) << 8) | view.getUint8(offset + 7);
                        
                        if (frameSize === 0 || offset + 10 + frameSize > view.byteLength) break;
                        
                        const frameData = this.getFrameData(view, offset + 10, frameSize);
                        
                        switch (frameId) {
                            case 'TIT2': metadata.title = frameData; break;
                            case 'TPE1': metadata.artist = frameData; break;
                            case 'TALB': metadata.album = frameData; break;
                        }
                        
                        offset += 10 + frameSize;
                    }
                    
                    return metadata;
                } catch (error) {
                    console.warn('ID3v2 parsing error:', error);
                    return null;
                }
            },
            
            parseID3v1(view, offset) {
                try {
                    return {
                        title: this.getString(view, offset + 3, 30).trim(),
                        artist: this.getString(view, offset + 33, 30).trim(),
                        album: this.getString(view, offset + 63, 30).trim()
                    };
                } catch (error) {
                    console.warn('ID3v1 parsing error:', error);
                    return null;
                }
            },
            
            getSynchsafeInt(view, offset) {
                return (view.getUint8(offset) << 21) | (view.getUint8(offset + 1) << 14) | 
                       (view.getUint8(offset + 2) << 7) | view.getUint8(offset + 3);
            },
            
            getFrameData(view, offset, size) {
                // Skip encoding byte
                let start = offset + 1;
                let data = '';
                
                for (let i = start; i < offset + size && i < view.byteLength; i++) {
                    const byte = view.getUint8(i);
                    if (byte === 0) break; // Null terminator
                    data += String.fromCharCode(byte);
                }
                
                return data;
            },
            
            getString(view, offset, length) {
                let result = '';
                for (let i = 0; i < length && offset + i < view.byteLength; i++) {
                    const byte = view.getUint8(offset + i);
                    if (byte === 0) break;
                    result += String.fromCharCode(byte);
                }
                return result;
            }
        };
        
        console.log('✓ Lightweight metadata parser loaded');
    </script>
</head>
<body>
<header class="header">
    <button class="info-button" id="infoBtn" title="About GitItUp">i</button>
    <div class="header-content">
        <div class="header-left" style="display: none;">
            <!-- Old sections hidden - using new tabbed interface -->
            </div>

        <!-- Old sections cleanup area -->
        <div style="display: none;">
            <!-- Hidden playlist data for backward compatibility -->
            <div id="playlistData" style="display: none;">
                <!-- Will be populated by PlaylistManager -->
            </div>

            <!-- Hidden file inputs -->
            <input type="file" id="playlistImportInput" accept=".json" style="display: none;">





        </div>
        <!-- End header-left -->

        </div>
    <!-- End header-content -->
</header>

<!-- New Tabbed Header Interface (Hidden until Phase 5) -->
<div class="tab-header" id="tabHeader">
    <!-- App Icon -->
    <img class="app-icon" id="appIcon" src="" alt="Vizzy App Icon" />
    
    <!-- Tab Group (Centered) -->
    <div class="tab-group">
        <button class="tab-item" id="audioTab" data-section="audio">Audio</button>
        <button class="tab-item" id="videoTab" data-section="video">Video</button>
        <button class="tab-item" id="visualizationsTab" data-section="visualizations">Visualizations</button>
        <button class="tab-item" id="autopilotTab" data-section="autopilot">Autopilot</button>
        <button class="tab-item" id="outputTab" data-section="output">Output</button>
    </div>
    
    <!-- Spacer for balance -->
    <div class="tab-spacer"></div>
</div>

<!-- Section Panels (Hidden until opened) -->
<div class="section-panel" id="audioPanel">
    <div class="panel-content">
        <!-- Live Audio (renamed from Audio Input) -->
        <div class="panel-row">
            <div class="input-mode-container">
                <button class="input-mode-btn" id="inputModeBtn" title="Toggle Live Audio Input">
                    <span class="input-mode-text">Live Audio</span>
                </button>
                <select class="audio-device-select" id="audioDeviceSelect" style="display: none;">
                    <option value="">Select Audio Input...</option>
                </select>
            </div>
        </div>

        <!-- Playlist -->
        <div class="panel-row">
            <div class="dropdown playlist-dropdown">
                <div class="dropdown-label">Playlist</div>
                <button class="dropdown-toggle" id="playlistToggle">Select Track</button>
                <div class="dropdown-content" id="playlistDropdown">
                    <!-- Playlist content will be populated here -->
                </div>
            </div>
        </div>
    </div>
</div>

<div class="section-panel" id="videoPanel">
    <div class="panel-content">
        <!-- Live Source (renamed from Video Input) -->
        <div class="panel-row">
            <div class="input-mode-container">
                <button class="input-mode-btn" id="videoInputBtn" title="Toggle Video Source">
                    <span class="video-mode-text">Live Source</span>
                </button>
                <select class="audio-device-select" id="videoDeviceSelect" style="display: none;">
                    <option value="">Select Video Input...</option>
                </select>
                <div class="video-file-info" id="videoFileInfo" style="display: none;">
                    <span class="video-file-name" id="videoFileName">No file selected</span>
                    <div class="video-file-controls-inline">
                        <button class="video-file-control-btn active" id="videoFileLoopBtn">Loop</button>
                        <button class="video-file-control-btn active" id="videoFileMuteBtn">Muted</button>
                    </div>
                </div>
                <input type="file" id="videoFileInput" accept="video/*" style="display: none;">
                
                <!-- Video Settings Panel -->
                <div class="video-controls-panel" id="videoControlsPanel" style="display: none;">
                    <div class="panel-header">
                        <span>Video Settings</span>
                        <button class="panel-close-btn" id="videoControlsClose">×</button>
                    </div>

                    <!-- Basic Controls -->
                    <div class="control-group">
                        <div class="group-label">Basic</div>
                        <div class="slider-container">
                            <label>Opacity</label>
                            <input type="range" id="videoOpacitySlider" min="0" max="100" value="100">
                            <span id="videoOpacityValue">100%</span>
                        </div>
                        <div class="slider-container">
                            <label>Brightness</label>
                            <input type="range" id="videoBrightnessSlider" min="0" max="200" value="100">
                            <span id="videoBrightnessValue">100%</span>
                        </div>
                        <div class="slider-container">
                            <label>Contrast</label>
                            <input type="range" id="videoContrastSlider" min="0" max="200" value="100">
                            <span id="videoContrastValue">100%</span>
                        </div>
                        <div class="slider-container">
                            <label>Fade Time</label>
                            <input type="range" id="videoFadeSlider" min="0" max="10" step="0.5" value="3">
                            <span id="videoFadeValue">3.0s</span>
                        </div>
                    </div>

                    <!-- Color Controls -->
                    <div class="control-group">
                        <div class="group-label">Color</div>
                        <div class="slider-container">
                            <label>Saturation</label>
                            <input type="range" id="videoSaturationSlider" min="0" max="200" value="100">
                            <span id="videoSaturationValue">100%</span>
                        </div>
                        <div class="slider-container">
                            <label>Hue Rotate</label>
                            <input type="range" id="videoHueRotateSlider" min="0" max="360" value="0">
                            <span id="videoHueRotateValue">0°</span>
                        </div>
                        <div class="slider-container">
                            <label>Grayscale</label>
                            <input type="range" id="videoGrayscaleSlider" min="0" max="100" value="0">
                            <span id="videoGrayscaleValue">0%</span>
                        </div>
                        <div class="slider-container">
                            <label>Sepia</label>
                            <input type="range" id="videoSepiaSlider" min="0" max="100" value="0">
                            <span id="videoSepiaValue">0%</span>
                        </div>
                    </div>

                    <!-- Effects -->
                    <div class="control-group">
                        <div class="group-label">Effects</div>
                        <div class="slider-container">
                            <label>Blur</label>
                            <input type="range" id="videoBlurSlider" min="0" max="20" value="0">
                            <span id="videoBlurValue">0px</span>
                        </div>
                        <div class="slider-container">
                            <label>Vignette</label>
                            <input type="range" id="videoVignetteSlider" min="0" max="100" value="0">
                            <span id="videoVignetteValue">0%</span>
                        </div>
                        <div class="slider-container">
                            <label>Posterize</label>
                            <input type="range" id="videoPosterizeSlider" min="2" max="16" value="16">
                            <span id="videoPosterizeValue">Off</span>
                        </div>
                        <div class="button-container">
                            <button class="effect-toggle-btn" id="videoInvertBtn">Invert: Off</button>
                            <button class="effect-toggle-btn" id="videoMirrorBtn">Mirror: Off</button>
                        </div>
                    </div>

                    <!-- Animation -->
                    <div class="control-group">
                        <div class="group-label">Animation</div>
                        <div class="button-container">
                            <button class="effect-toggle-btn" id="videoPulseBtn">Pulse: Off</button>
                        </div>
                        <div class="slider-container" id="videoPulseRateContainer" style="display: none;">
                            <label>Pulse Rate</label>
                            <input type="range" id="videoPulseRateSlider" min="0.5" max="4" step="0.1" value="2">
                            <span id="videoPulseRateValue">2.0s</span>
                        </div>
                    </div>

                    <!-- Visualization Aspect Ratio -->
                    <div class="control-group">
                        <div class="group-label">Visualization</div>
                        <div class="button-container">
                            <button class="effect-toggle-btn active" id="matchVisualizationAspectBtn">Match Video Aspect: On</button>
                        </div>
                    </div>

                    <!-- Presets -->
                    <div class="control-group">
                        <div class="group-label">Presets</div>
                        <div class="preset-buttons">
                            <button class="video-preset-btn" data-preset="normal">Normal</button>
                            <button class="video-preset-btn" data-preset="dreamy">Dreamy</button>
                            <button class="video-preset-btn" data-preset="noir">Noir</button>
                            <button class="video-preset-btn" data-preset="cyberpunk">Cyberpunk</button>
                            <button class="video-preset-btn" data-preset="vintage">Vintage</button>
                            <button class="video-preset-btn" data-preset="retro-tv">Retro TV</button>
                            <button class="video-preset-btn" data-preset="underwater">Underwater</button>
                            <button class="video-preset-btn" data-preset="infrared">Infrared</button>
                            <button class="video-preset-btn" data-preset="acid">Acid</button>
                            <button class="video-preset-btn" data-preset="thermal">Thermal</button>
                            <button class="video-preset-btn" data-preset="matrix">Matrix</button>
                            <button class="video-preset-btn" data-preset="glitch">Glitch</button>
                        </div>
                    </div>

                    <!-- Camera & Stream Stats -->
                    <div class="control-group">
                        <div class="group-label">Stream Statistics</div>
                        <div id="cameraStatsContainer" class="stats-container">
                            <div class="stats-placeholder">Camera stream info will appear here when video input is active</div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

<div class="section-panel" id="visualizationsPanel">
    <div class="panel-content">
        <!-- Spectrum Controls (with ON button and Random) -->
        <div class="spectrum-controls-container">
            <div class="dropdown-label">Spectrum</div>
            <div class="control-with-settings">
                <div class="dropdown">
                    <button class="dropdown-toggle" id="vizModeToggle">Spectrum</button>
                    <div class="dropdown-content" id="vizModeDropdown">
                        <div class="dropdown-item active" data-mode="0">Spectrum</div>
                        <div class="dropdown-item" data-mode="1">Mirror Wave</div>
                        <div class="dropdown-item" data-mode="2">Classic LED</div>
                        <div class="dropdown-item" data-mode="3">Stereo</div>
                        <div class="dropdown-item" data-mode="4">Radial Spectrum</div>
                        <div class="dropdown-item" data-mode="5">Energy</div>
                        <div class="dropdown-item" data-mode="6">Mirror</div>
                    </div>
                </div>
                <!-- ON button pinned to the right -->
                <button class="dropdown-toggle viz-toggle-btn active" id="vizToggleBtn" title="Toggle Visualization">ON</button>
            </div>
            <!-- Random button below, left-aligned with Spectrum -->
            <button class="dropdown-toggle random-viz-btn" id="randomVizBtn" title="Random Visualization">Random</button>
        </div>

        <!-- Presets -->
        <div class="presets-container">
            <div class="dropdown-label">Presets</div>
            <div class="preset-buttons">
                <select class="preset-selector" id="presetSelector" title="Load Saved Preset">
                    <option value="">Load Preset...</option>
                </select>
                <button class="preset-btn" id="savePresetBtn" title="Save Current as Preset">Save</button>
                <button class="preset-btn" id="exportPresetsBtn" title="Export All Presets">Export</button>
                <button class="preset-btn" id="importPresetsBtn" title="Import Presets">Import</button>
                <input type="file" id="importPresetsFile" accept=".json" style="display: none;">
            </div>
        </div>

        <!-- Morph -->
        <div class="morph-controls">
            <div class="dropdown-label">Morph</div>
            <div class="morph-buttons">
                <button class="morph-btn" id="morphBtn" title="Morph between visualizations">
                    <span class="morph-btn-text">Start Morph</span>
                </button>
                <select class="morph-speed-select" id="morphSpeedSelect">
                    <option value="slow">Slow</option>
                    <option value="medium" selected>Medium</option>
                    <option value="fast">Fast</option>
                    <option value="ultra">Ultra</option>
                    <option value="energy">Energy</option>
                </select>
            </div>
            <div class="energy-container" id="energyContainer" style="display: none;">
                <div class="energy-label">Energy</div>
                <div class="energy-bar">
                    <div class="energy-indicator" id="energyIndicator"></div>
                </div>
            </div>
        </div>

        <!-- Color Schemes -->
        <div class="color-scheme-container">
            <div class="dropdown-label">Color Scheme</div>
            <div class="dropdown">
                <button class="dropdown-toggle" id="colorSchemeToggle">Default</button>
                <div class="dropdown-content" id="colorSchemeDropdown">
                    <div class="dropdown-item active" data-scheme="default">Default</div>
                    <div class="dropdown-item" data-scheme="earthtones">Earthtones</div>
                    <div class="dropdown-item" data-scheme="luigi">Luigi</div>
                    <div class="dropdown-item" data-scheme="metal">Heavy Metal</div>
                    <div class="dropdown-item" data-scheme="psychedelic">Psychedelic</div>
                </div>
            </div>
        </div>

        <!-- Kaleidoscope -->
        <div class="kaleidoscope-controls">
            <div class="dropdown-label">Kaleidoscope</div>
            <button class="dropdown-toggle kaleidoscope-btn" id="kaleidoscopeBtn" title="Kaleidoscope">
                <span class="kaleidoscope-btn-text">Kaleidoscope Off</span>
            </button>

            <!-- Kaleidoscope settings panel -->
            <div class="kaleidoscope-panel" id="kaleidoscopePanel" style="display: none;">
                <div class="panel-header">
                    <span>Kaleidoscope Settings</span>
                    <button class="panel-close-btn" id="kaleidoscopeCloseBtn">×</button>
                </div>

                <div class="control-group">
                    <div class="slider-container">
                        <label>Segments</label>
                        <input type="range" id="kaleidoscopeSegments" min="2" max="24" value="6" step="1">
                        <span id="kaleidoscopeSegmentsValue">6</span>
                    </div>
                    <div class="slider-container">
                        <label>Rings</label>
                        <input type="range" id="kaleidoscopeRings" min="1" max="5" value="1" step="1">
                        <span id="kaleidoscopeRingsValue">1</span>
                    </div>
                    <div class="slider-container">
                        <label>Ring Spacing</label>
                        <input type="range" id="kaleidoscopeRingSpacing" min="5" max="30" value="20" step="5">
                        <span id="kaleidoscopeRingSpacingValue">20%</span>
                    </div>
                    <div class="slider-container">
                        <label>Rotation Speed</label>
                        <input type="range" id="kaleidoscopeSpeed" min="0" max="6" value="0" step="0.25">
                        <span id="kaleidoscopeSpeedValue">0</span>
                    </div>
                    <div class="slider-container">
                        <label>Scale</label>
                        <input type="range" id="kaleidoscopeScale" min="50" max="200" value="100" step="10">
                        <span id="kaleidoscopeScaleValue">100%</span>
                    </div>
                    <div class="slider-container">
                        <label>Center X</label>
                        <input type="range" id="kaleidoscopeCenterX" min="0" max="100" value="50" step="1">
                        <span id="kaleidoscopeCenterXValue">50%</span>
                    </div>
                    <div class="slider-container">
                        <label>Center Y</label>
                        <input type="range" id="kaleidoscopeCenterY" min="0" max="100" value="50" step="1">
                        <span id="kaleidoscopeCenterYValue">50%</span>
                    </div>
                    <div class="button-container">
                        <button class="effect-toggle-btn" id="kaleidoscopeVideoBtn">Apply to Video: Off</button>
                        <button class="effect-toggle-btn" id="kaleidoscopeVizBtn">Apply to Viz: On</button>
                        <button class="effect-toggle-btn" id="kaleidoscopeInfiniteZoomBtn">Infinite Zoom: Off</button>
                    </div>
                    <div class="button-container">
                        <button class="effect-toggle-btn" id="kaleidoscopeShapeBtn">Shape: Triangle</button>
                    </div>
                    <div class="apply-container"></div>

                    <div class="control-group">
                        <div class="group-label">Beat Reaction</div>
                        <div class="button-container">
                            <button class="effect-toggle-btn" id="kaleidoscopeBeatBtn">Beat React: Off</button>
                            <button class="effect-toggle-btn" id="kaleidoscopeBeatRotationBtn">Rotation: Off</button>
                            <button class="effect-toggle-btn" id="kaleidoscopeBeatShapeBtn">Shape: Off</button>
                        </div>
                        <div class="slider-container" id="beatSensitivityContainer" style="display: none;">
                            <label>Sensitivity</label>
                            <input type="range" id="kaleidoscopeBeatSensitivity" min="10" max="100" value="50" step="10">
                            <span id="kaleidoscopeBeatSensitivityValue">50%</span>
                        </div>
                    </div>
                </div>
                <div class="control-group">
                    <div class="group-label">Presets</div>
                    <div class="preset-buttons">
                        <button class="kaleidoscope-preset-btn" data-preset="0">Classic</button>
                        <button class="kaleidoscope-preset-btn" data-preset="1">Flower</button>
                        <button class="kaleidoscope-preset-btn" data-preset="2">Crystal</button>
                        <button class="kaleidoscope-preset-btn" data-preset="3">Mandala</button>
                        <button class="kaleidoscope-preset-btn" data-preset="4">Star</button>
                    </div>
                </div>
                
            </div>
        </div>

        <!-- Infinite Zoom -->
        <div class="kaleidoscope-controls">
            <div class="dropdown-label">Infinite Zoom</div>
            <button class="dropdown-toggle kaleidoscope-btn" id="infiniteZoomBtn" title="Infinite Zoom">
                <span class="kaleidoscope-btn-text">Infinite Zoom Off</span>
            </button>

            <!-- Infinite Zoom settings panel -->
            <div class="kaleidoscope-panel" id="infiniteZoomPanel" style="display: none;">
                <div class="panel-header">
                    <span>Infinite Zoom Settings</span>
                    <button class="panel-close-btn" id="infiniteZoomCloseBtn">×</button>
                </div>

                <div class="control-group">
                    <div class="button-container">
                        <select id="infiniteZoomShapeSelect" class="dropdown-select">
                            <option value="circle">Circle</option>
                            <option value="square">Square</option>
                            <option value="rectangle">Rectangle</option>
                            <option value="triangle">Triangle</option>
                            <option value="star">Star</option>
                            <option value="mushroom">Mushroom</option>
                        </select>
                    </div>
                    <div class="slider-container">
                        <label for="infiniteZoomColorRandomSlider">Color Randomness:</label>
                        <input type="range" id="infiniteZoomColorRandomSlider" min="0" max="1" step="0.1" value="0.5" class="slider">
                        <span id="infiniteZoomColorRandomValue">0.5</span>
                    </div>
                    <div class="slider-container">
                        <label for="infiniteZoomMinSizeSlider">Min Size:</label>
                        <input type="range" id="infiniteZoomMinSizeSlider" min="1" max="10" step="1" value="2" class="slider">
                        <span id="infiniteZoomMinSizeValue">2</span>
                    </div>
                    <div class="slider-container">
                        <label for="infiniteZoomMaxSizeSlider">Max Size:</label>
                        <input type="range" id="infiniteZoomMaxSizeSlider" min="10" max="50" step="5" value="20" class="slider">
                        <span id="infiniteZoomMaxSizeValue">20</span>
                    </div>
                    <div class="slider-container">
                        <label for="infiniteZoomDensitySlider">Density:</label>
                        <input type="range" id="infiniteZoomDensitySlider" min="1" max="100" step="1" value="50" class="slider">
                        <span id="infiniteZoomDensityValue">50</span>
                    </div>
                    <div class="slider-container">
                        <label for="infiniteZoomSpeedSlider">Speed:</label>
                        <input type="range" id="infiniteZoomSpeedSlider" min="-100" max="100" step="1" value="50" class="slider">
                        <span id="infiniteZoomSpeedValue">50</span>
                    </div>
                    <div class="slider-container">
                        <label for="infiniteZoomRotationSlider">Rotation:</label>
                        <input type="range" id="infiniteZoomRotationSlider" min="-10" max="10" step="0.1" value="0" class="slider">
                        <span id="infiniteZoomRotationValue">0.0</span>
                    </div>
                    <div class="slider-container">
                        <label for="infiniteZoomOpacitySlider">Opacity:</label>
                        <input type="range" id="infiniteZoomOpacitySlider" min="0" max="100" step="1" value="100" class="slider">
                        <span id="infiniteZoomOpacityValue">100%</span>
                    </div>
                    <div class="button-container">
                        <button id="infiniteZoomBeatReactBtn" class="toggle-btn">Beat React: Off</button>
                    </div>
                    <div class="control-group" id="infiniteZoomBeatReactControls" style="display: none;">
                        <h4>Beat Reaction Controls</h4>
                        <div class="control-item">
                            <label for="infiniteZoomSensitivitySlider">Sensitivity:</label>
                            <input type="range" id="infiniteZoomSensitivitySlider" min="0" max="100" step="1" value="100" class="slider">
                            <span id="infiniteZoomSensitivityValue">100%</span>
                        </div>
                        <div class="button-container">
                            <button id="infiniteZoomBeatZoomBtn" class="toggle-btn">Beat Zoom: Off</button>
                        </div>
                        <div class="button-container">
                            <button id="infiniteZoomBeatRotationBtn" class="toggle-btn">Beat Rotation: Off</button>
                        </div>
                        <div class="button-container">
                            <button id="infiniteZoomBeatDensityBtn" class="toggle-btn">Beat Density: Off</button>
                        </div>
                        <div class="button-container">
                            <button id="infiniteZoomBeatShapeBtn" class="toggle-btn">Beat Shape: Off</button>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

<div class="section-panel" id="autopilotPanel">
    <div class="panel-content">
        <!-- AI AUTOPILOT Section -->
        <div class="autopilot-section">
            <div class="dropdown-label">AI Autopilot</div>
            <div class="control-with-settings">
                <button class="dropdown-toggle" id="aiAutopilotBtn" title="Activate AI Autopilot">
                    Activate
                </button>
                <button id="aiAutopilotSettingsBtn" class="video-settings-toggle" title="AI Autopilot Settings">⚙</button>
            </div>
            <div class="control-with-settings" style="margin-top: 8px;">
                <button class="dropdown-toggle" id="learningAnalyticsBtn" title="Open Learning Analytics Dashboard">
                    📊 Learning Analytics
                </button>
                
                <!-- AI Autopilot Settings Panel -->
                <div class="autopilot-settings-panel" id="aiAutopilotSettingsPanel" style="display: none;">
                <div class="panel-header">
                    <span>AI Autopilot Settings</span>
                    <button class="panel-close-btn" id="aiAutopilotSettingsClose">×</button>
                </div>

                <div class="autopilot-settings-content">
                    <!-- Left Column -->
                    <div class="autopilot-column">
                <!-- Autopilot Scope -->
                <div class="control-group">
                    <div class="group-label">Autopilot Scope</div>
                    <div class="preset-buttons">
                                <button class="scope-btn" data-scope="bars">Bars</button>
                        <button class="scope-btn" data-scope="radial">Radial</button>
                        <button class="scope-btn" data-scope="energy">Energy</button>
                                <button class="scope-btn active" data-scope="all">All</button>
                    </div>
                </div>

                <!-- Color Schemes Toggle -->
                <div class="control-group">
                    <div class="group-label">Color Automation</div>
                    <div class="button-container">
                        <button class="effect-toggle-btn" id="autoColorSchemesBtn">Auto Color Schemes: Off</button>
                    </div>
                </div>

                <!-- Change Timing -->
                <div class="control-group">
                    <div class="group-label">Change Timing</div>
                    <div class="preset-buttons">
                        <button class="timing-btn active" data-timing="instant">Instant</button>
                        <button class="timing-btn" data-timing="smooth">Smooth</button>
                        <button class="timing-btn" data-timing="slow">Slow</button>
                        <button class="timing-btn" data-timing="beat-synced">Beat-Synced</button>
                    </div>
                </div>

                <!-- Sensitivity -->
                <div class="control-group">
                    <div class="group-label">Sensitivity</div>
                    <div class="preset-buttons">
                        <button class="sensitivity-btn" data-sensitivity="low">Low</button>
                        <button class="sensitivity-btn active" data-sensitivity="medium">Medium</button>
                        <button class="sensitivity-btn" data-sensitivity="high">High</button>
                    </div>
                </div>

                <!-- Genre Selection -->
                <div class="control-group">
                    <div class="group-label">Genre Detection</div>
                    <div class="preset-buttons">
                        <button class="genre-btn active" data-genre="auto">Auto Detect</button>
                        <button class="genre-btn" data-genre="heavy-metal">Heavy Metal</button>
                        <button class="genre-btn" data-genre="rock">Rock</button>
                        <button class="genre-btn" data-genre="electronic">Electronic</button>
                        <button class="genre-btn" data-genre="reggae">Reggae</button>
                        <button class="genre-btn" data-genre="country">Country</button>
                        <button class="genre-btn" data-genre="funk">Funk</button>
                        <button class="genre-btn" data-genre="ambient">Ambient</button>
                        <button class="genre-btn" data-genre="punk">Punk</button>
                        <button class="genre-btn" data-genre="jazz">Jazz</button>
                        <button class="genre-btn" data-genre="classical">Classical</button>
                    </div>
                </div>

                <!-- Parameter Control -->
                <div class="control-group">
                    <div class="group-label">Parameter Control</div>
                    <div class="button-container">
                        <button class="effect-toggle-btn active" id="enableParameterControlBtn">Parameter Control: On</button>
                    </div>
                </div>

                <!-- Video Effects -->
                <div class="control-group">
                    <div class="group-label">Video Effects</div>
                    <div class="button-container">
                        <button class="effect-toggle-btn active" id="enableVideoEffectsBtn">Video Effects: On</button>
                    </div>
                </div>

                        <!-- Learning Controls -->
                        <div class="control-group">
                            <div class="group-label">Learning Controls</div>
                            <div class="button-container">
                                <button class="effect-toggle-btn active" id="enableLearningBtn">Learning: On</button>
                            </div>
                            <div class="button-container">
                                <button class="effect-toggle-btn" id="resetLearningBtn">Reset Learning Data</button>
                            </div>
                        </div>

                        <!-- Adaptive Tuning Controls -->
                        <div class="control-group">
                            <div class="group-label">Adaptive Tuning</div>
                            <div class="button-container">
                                <button class="effect-toggle-btn active" id="enableAdaptiveTuningBtn">Adaptive Tuning: On</button>
                            </div>
                            <div class="button-container">
                                <button class="effect-toggle-btn" id="forceOptimizationBtn">Force Optimization</button>
                            </div>
                        </div>

                        <!-- Predictive Behavior Controls -->
                        <div class="control-group">
                            <div class="group-label">Predictive Behavior</div>
                            <div class="button-container">
                                <button class="effect-toggle-btn active" id="enablePredictiveBehaviorBtn">Predictive Behavior: On</button>
                            </div>
                            <div class="button-container">
                                <button class="effect-toggle-btn" id="testPredictionBtn">Test Prediction</button>
                            </div>
                        </div>

                        <!-- Multi-layered Intelligence Controls -->
                        <div class="control-group">
                            <div class="group-label">Multi-layered Intelligence</div>
                            <div class="button-container">
                                <button class="effect-toggle-btn active" id="enableMultiLayeredIntelligenceBtn">Multi-layered Intelligence: On</button>
                            </div>
                            <div class="button-container">
                                <button class="effect-toggle-btn" id="testIntelligenceBtn">Test Intelligence</button>
                            </div>
                        </div>

                        <!-- Test Button -->
                        <div class="control-group">
                            <div class="group-label">Test</div>
                            <div class="button-container">
                                <button class="effect-toggle-btn" id="testParameterControlBtn">Test Parameter Control</button>
                            </div>
                            <div class="button-container">
                                <button class="effect-toggle-btn" id="testParametersBtn">Test Parameters</button>
                            </div>
                        </div>
                    </div>

                    <!-- Right Column -->
                    <div class="autopilot-column">
                <!-- Current Genre Display -->
                <div class="control-group">
                    <div class="group-label">Current Genre</div>
                    <div class="info-display" id="currentGenreDisplay">Unknown</div>
                </div>

                <!-- Genre Confidence -->
                <div class="control-group">
                    <div class="group-label">Confidence</div>
                    <div class="info-display" id="genreConfidenceDisplay">0%</div>
                </div>

                        <!-- Learning Analytics -->
                <div class="control-group">
                            <div class="group-label">Learning Analytics</div>
                            <div class="info-display" id="learningProgressDisplay">Learning: 0%</div>
                            <div class="info-display" id="patternCountDisplay">Patterns: 0</div>
                            <div class="info-display" id="successRateDisplay">Success Rate: 0%</div>
                        </div>

                        <!-- Adaptive Tuning Analytics -->
                        <div class="control-group">
                            <div class="group-label">Adaptive Tuning</div>
                            <div class="info-display" id="performanceDisplay">Performance: 0%</div>
                            <div class="info-display" id="optimizationCountDisplay">Optimizations: 0</div>
                            <div class="info-display" id="performanceTrendDisplay">Trend: Stable</div>
                        </div>

                        <!-- User Feedback -->
                        <div class="control-group">
                            <div class="group-label">User Feedback</div>
                    <div class="button-container">
                                <button class="effect-toggle-btn" id="thumbsUpBtn">👍 Like Current Settings</button>
                    </div>
                            <div class="button-container">
                                <button class="effect-toggle-btn" id="thumbsDownBtn">👎 Dislike Current Settings</button>
                </div>
                            <div class="info-display" id="feedbackStatsDisplay" style="margin-top: 5px;">Satisfaction: 0%</div>
                </div>

                        <!-- Predictive Behavior Analytics -->
                        <div class="control-group">
                            <div class="group-label">Predictive Analytics</div>
                            <div class="info-display" id="predictionCountDisplay">Predictions: 0</div>
                            <div class="info-display" id="predictionAccuracyDisplay">Accuracy: 0%</div>
                            <div class="info-display" id="predictionConfidenceDisplay">Confidence: 80%</div>
                        </div>

                        <!-- Multi-layered Intelligence Analytics -->
                        <div class="control-group">
                            <div class="group-label">Intelligence Analytics</div>
                            <div class="info-display" id="intelligenceDecisionsDisplay">Decisions: 0</div>
                            <div class="info-display" id="metaLearningDisplay">Meta-Learning: 0%</div>
                            <div class="info-display" id="layerPerformanceDisplay">Performance: Balanced</div>
                        </div>
                    </div>
                </div>
                </div>
            </div>
        </div>

        <!-- Learning Analytics Dashboard Modal -->
        <div class="learning-analytics-modal" id="learningAnalyticsModal" style="display: none;">
            <div class="analytics-modal-content">
                <div class="analytics-modal-header">
                    <h2>📊 Learning Analytics Dashboard</h2>
                    <div class="analytics-controls">
                        <label for="updateFrequency">Update Frequency:</label>
                        <select id="updateFrequency" class="frequency-select">
                            <option value="1000">1 second</option>
                            <option value="2000">2 seconds</option>
                            <option value="3000">3 seconds</option>
                            <option value="5000" selected>5 seconds</option>
                            <option value="10000">10 seconds</option>
                            <option value="15000">15 seconds</option>
                            <option value="20000">20 seconds</option>
                        </select>
                        <button class="export-btn" id="exportLearningDataBtn">Export Data</button>
                        <button class="reset-btn" id="resetLearningDataBtn">Reset All Data</button>
                    </div>
                    <button class="analytics-close-btn" id="analyticsCloseBtn">×</button>
                </div>
                
                <div class="analytics-content">
                    <!-- Learning Progress Section -->
                    <div class="analytics-section">
                        <h3>🧠 Learning Progress</h3>
                        <div class="analytics-grid">
                            <div class="analytics-card">
                                <div class="card-title">Pattern Learning</div>
                                <div class="card-value" id="dashboardPatternCount">0</div>
                                <div class="card-subtitle">Patterns Learned</div>
                            </div>
                            <div class="analytics-card">
                                <div class="card-title">Success Rate</div>
                                <div class="card-value" id="dashboardSuccessRate">0%</div>
                                <div class="card-subtitle">Learning Accuracy</div>
                            </div>
                            <div class="analytics-card">
                                <div class="card-title">Learning Progress</div>
                                <div class="card-value" id="dashboardLearningProgress">0%</div>
                                <div class="card-subtitle">Overall Progress</div>
                            </div>
                        </div>
                    </div>

                    <!-- User Feedback Section -->
                    <div class="analytics-section">
                        <h3>👤 User Feedback</h3>
                        <div class="analytics-grid">
                            <div class="analytics-card">
                                <div class="card-title">Total Feedback</div>
                                <div class="card-value" id="dashboardTotalFeedback">0</div>
                                <div class="card-subtitle">Interactions</div>
                            </div>
                            <div class="analytics-card">
                                <div class="card-title">Satisfaction</div>
                                <div class="card-value" id="dashboardSatisfaction">0%</div>
                                <div class="card-subtitle">User Satisfaction</div>
                            </div>
                            <div class="analytics-card">
                                <div class="card-title">Positive</div>
                                <div class="card-value" id="dashboardPositiveFeedback">0</div>
                                <div class="card-subtitle">👍 Likes</div>
                            </div>
                        </div>
                    </div>

                    <!-- Predictive Behavior Section -->
                    <div class="analytics-section">
                        <h3>🎯 Predictive Behavior</h3>
                        <div class="analytics-grid">
                            <div class="analytics-card">
                                <div class="card-title">Predictions Made</div>
                                <div class="card-value" id="dashboardPredictions">0</div>
                                <div class="card-subtitle">Total Predictions</div>
                                <div class="card-description">Mode changes, parameter adjustments, and timing predictions based on audio analysis.</div>
                            </div>
                            <div class="analytics-card">
                                <div class="card-title">Prediction Accuracy</div>
                                <div class="card-value" id="dashboardPredictionAccuracy">0%</div>
                                <div class="card-subtitle">Success Rate</div>
                                <div class="card-description">Percentage of executed predictions out of total predictions made. Calculated from recent prediction history.</div>
                            </div>
                            <div class="analytics-card">
                                <div class="card-title">Confidence Level</div>
                                <div class="card-value" id="dashboardConfidence">80%</div>
                                <div class="card-subtitle">Current Threshold</div>
                                <div class="card-description">Minimum confidence required to execute predictions. Higher values mean more conservative decision-making.</div>
                            </div>
                        </div>
                    </div>

                    <!-- Adaptive Tuning Section -->
                    <div class="analytics-section">
                        <h3>⚙️ Adaptive Tuning</h3>
                        <div class="analytics-grid">
                            <div class="analytics-card">
                                <div class="card-title">Optimizations</div>
                                <div class="card-value" id="dashboardOptimizations">0</div>
                                <div class="card-subtitle">Parameter Optimizations</div>
                                <div class="card-description">Successful parameter adjustments that accurately produce expected results. For example, applying dark color schemes with slow graphics to ambient tracks.</div>
                            </div>
                            <div class="analytics-card">
                                <div class="card-title">Performance</div>
                                <div class="card-value" id="dashboardPerformance">0%</div>
                                <div class="card-subtitle">Current Performance</div>
                                <div class="card-description">Combined score based on audio response (60%) and user feedback (40%). Measures how well parameters match the current audio context.</div>
                            </div>
                            <div class="analytics-card">
                                <div class="card-title">Trend</div>
                                <div class="card-value" id="dashboardTrend">Stable</div>
                                <div class="card-subtitle">Performance Trend</div>
                                <div class="card-description">Direction of performance over time: Improving (getting better), Declining (getting worse), or Stable (consistent performance).</div>
                            </div>
                        </div>
                    </div>

                    <!-- Recent Activity Section -->
                    <div class="analytics-section">
                        <h3>📈 Recent Activity</h3>
                        <div class="activity-log" id="activityLog">
                            <div class="activity-item">System initialized</div>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- DMX COPILOT Section -->
        <div class="autopilot-section">
            <div class="dropdown-label">DMX Copilot</div>
            <div class="control-with-settings">
                <button class="dropdown-toggle" id="dmxCopilotBtn" title="Activate DMX CoPilot">
                    Activate
                </button>
                <button id="dmxCopilotSettingsBtn" class="video-settings-toggle" title="DMX CoPilot Settings">⚙</button>
            </div>
        </div>

        <!-- MIDI COPILOT Section -->
        <div class="autopilot-section">
            <div class="dropdown-label">MIDI Copilot</div>
            <div class="control-with-settings">
                <button class="dropdown-toggle" id="midiCopilotBtn" title="Activate MIDI CoPilot">
                    Activate
                </button>
                <button id="midiCopilotSettingsBtn" class="video-settings-toggle" title="MIDI CoPilot Settings">⚙</button>
            </div>
        </div>
    </div>
</div>

<div class="section-panel" id="outputPanel">
    <div class="panel-content">
        <!-- Live Display -->
        <div class="panel-row">
            <div class="control-with-settings">
                <button class="dropdown-toggle" id="liveDisplayBtn" title="Open Live Display Window">
                    Live Display
                </button>
                <button id="displaySettingsBtn" class="video-settings-toggle" title="Display Settings">⚙</button>
                
                <!-- Display Settings Panel -->
                <div class="display-settings-panel" id="displaySettingsPanel" style="display: none;">
                <div class="panel-header">
                    <span>Display Settings</span>
                    <button class="panel-close-btn" id="displaySettingsClose">×</button>
                </div>

                <!-- Presentation Mode -->
                <div class="control-group">
                    <div class="group-label">Presentation Mode</div>
                    <div class="preset-buttons">
                        <button class="display-mode-btn active" data-mode="original">Original</button>
                        <button class="display-mode-btn" data-mode="fit">Fit</button>
                        <button class="display-mode-btn" data-mode="fill">Fill</button>
                        <button class="display-mode-btn" data-mode="stretch">Stretch</button>
                        <button class="display-mode-btn" data-mode="performance">Performance</button>
                    </div>
                </div>

                <!-- Quality Settings -->
                <div class="control-group">
                    <div class="group-label">Capture Quality</div>
                    <div class="slider-container">
                        <label>Resolution</label>
                        <select id="captureResolution" class="quality-select">
                            <option value="3840">4K (3840px)</option>
                            <option value="2560" selected>2K (2560px)</option>
                            <option value="1920">1080p (1920px)</option>
                            <option value="1280">720p (1280px)</option>
                            <option value="960">SD (960px)</option>
            </select>
        </div>
                    <div class="slider-container">
                        <label>Frame Rate</label>
                        <select id="captureFrameRate" class="quality-select">
                            <option value="60" selected>60 FPS</option>
                            <option value="30">30 FPS</option>
                            <option value="24">24 FPS</option>
                            <option value="15">15 FPS</option>
                        </select>
    </div>
                    <div class="slider-container">
                        <label>Bitrate</label>
                        <input type="range" id="captureBitrate" min="1" max="50" value="30" step="0.5">
                        <span id="captureBitrateValue">30 Mbps</span>
                    </div>
                </div>

                <!-- Aspect Ratio -->
                <div class="control-group">
                    <div class="group-label">Aspect Ratio</div>
                    <div class="preset-buttons">
                        <button class="aspect-ratio-btn active" data-ratio="16:9">16:9</button>
                        <button class="aspect-ratio-btn" data-ratio="4:3">4:3</button>
                        <button class="aspect-ratio-btn" data-ratio="9:16">9:16</button>
                        <button class="aspect-ratio-btn" data-ratio="1:1">1:1</button>
                        <button class="aspect-ratio-btn" data-ratio="21:9">21:9</button>
                    </div>
                </div>

                <!-- Display Enhancement -->
                <div class="control-group">
                    <div class="group-label">Display Enhancement</div>
                    <div class="slider-container">
                        <label>Sharpness</label>
                        <input type="range" id="displaySharpness" min="0" max="100" value="0">
                        <span id="displaySharpnessValue">0%</span>
                    </div>
                    <div class="slider-container">
                        <label>Letterbox Color</label>
                        <div style="display: flex; align-items: center; gap: 10px;">
                            <input type="color" id="letterboxColor" value="#000000" style="width: 50px; height: 30px;">
                            <span id="letterboxColorValue">#000000</span>
                        </div>
                    </div>
                    <div class="button-container">
                        <button class="effect-toggle-btn" id="mirrorBackgroundBtn">Mirror Background: Off</button>
                    </div>
                    <div class="slider-container" id="mirrorBlurContainer" style="display: none;">
                        <label>Background Blur</label>
                        <input type="range" id="mirrorBackgroundBlur" min="0" max="50" value="20">
                        <span id="mirrorBackgroundBlurValue">20px</span>
                    </div>
                </div>

                <!-- Quick Presets -->
                <div class="control-group">
                    <div class="group-label">Quick Presets</div>
                    <div class="preset-buttons">
                        <button class="display-preset-btn" data-preset="cinema">Cinema</button>
                        <button class="display-preset-btn" data-preset="presentation">Presentation</button>
                        <button class="display-preset-btn" data-preset="social">Social Media</button>
                        <button class="display-preset-btn" data-preset="performance">Performance</button>
                        <button class="display-preset-btn" data-preset="projector">Projector</button>
    </div>
                </div>

                <!-- Capture Settings -->
                <div class="control-group">
                    <div class="group-label">Capture Settings</div>
                    <div class="button-container">
                        <button class="effect-toggle-btn" id="captureVisualizationBtn">Capture Visualization: On</button>
                        <button class="effect-toggle-btn" id="captureVideoBtn">Capture Video: On</button>
                    </div>
                </div>
                </div>
            </div>
        </div>

        <!-- Record -->
        <div class="panel-row">
            <div class="record-controls">
                <button class="dropdown-toggle" id="recordBtn" title="Record Visualization">
                    <span class="record-text">Record</span>
                    <span class="record-timer" style="display: none;">00:00</span>
                </button>
                <button id="recordSettingsBtn" class="video-settings-toggle" title="Recording Settings">⚙</button>

                <!-- Record Settings Panel -->
                <div class="record-settings-panel" id="recordSettingsPanel" style="display: none;">
                    <div class="panel-header">
                        <span>Recording Settings</span>
                        <button class="panel-close-btn" id="recordSettingsClose">×</button>
                    </div>

                    <!-- Resolution -->
                    <div class="control-group">
                        <div class="group-label">Resolution</div>
                        <select id="recordResolutionSelect" class="control-select">
                            <option value="canvas">Canvas Size</option>
                            <option value="720p">720p (1280×720)</option>
                            <option value="1080p" selected>1080p (1920×1080)</option>
                            <option value="4k">4K (3840×2160)</option>
                        </select>
                    </div>

                    <!-- Aspect Ratio -->
                    <div class="control-group">
                        <div class="group-label">Aspect Ratio</div>
                        <div class="preset-buttons">
                            <button class="aspect-ratio-btn active" data-ratio="16:9">16:9</button>
                            <button class="aspect-ratio-btn" data-ratio="4:3">4:3</button>
                            <button class="aspect-ratio-btn" data-ratio="9:16">9:16</button>
                            <button class="aspect-ratio-btn" data-ratio="1:1">1:1</button>
                        </div>
                    </div>

                    <!-- Visualization Aspect Ratio -->
                    <div class="control-group">
                        <div class="group-label">Visualization</div>
                        <div class="button-container">
                            <button class="effect-toggle-btn active" id="recordMatchVisualizationAspectBtn">Match Video Aspect: On</button>
                        </div>
                    </div>

                    <!-- Frame Rate -->
                    <div class="control-group">
                        <div class="group-label">Frame Rate</div>
                        <div class="preset-buttons">
                            <button class="framerate-btn active" data-fps="30">30 FPS</button>
                            <button class="framerate-btn" data-fps="60">60 FPS</button>
                        </div>
                    </div>

                    <!-- Video Quality -->
                    <div class="control-group">
                        <div class="group-label">Video Quality</div>
                        <select id="recordVideoQualitySelect" class="control-select">
                            <option value="auto" selected>Auto</option>
                            <option value="high">High</option>
                            <option value="medium">Medium</option>
                            <option value="low">Low</option>
                        </select>
                    </div>

                    <!-- Audio Quality -->
                    <div class="control-group">
                        <div class="group-label">Audio Quality</div>
                        <select id="recordAudioQualitySelect" class="control-select">
                            <option value="auto" selected>Auto</option>
                            <option value="high">High (320 kbps)</option>
                            <option value="medium">Medium (192 kbps)</option>
                            <option value="low">Low (128 kbps)</option>
                        </select>
                    </div>

                    <!-- File Settings -->
                    <div class="control-group">
                        <div class="group-label">File Settings</div>
                        <div class="file-location-display" id="recordFileLocation">
                            📥 Downloads folder
                        </div>
                        <button class="control-btn" id="recordChooseLocationBtn">Choose Location</button>
                        <div class="input-container">
                            <label>Filename</label>
                            <input type="text" id="recordFilenameInput" placeholder="Vizzy_Recording" class="control-input">
                            <span class="file-extension">.webm</span>
                        </div>
                    </div>

                    <!-- Recording Info -->
                    <div class="control-group">
                        <div class="group-label">Recording Info</div>
                        <div class="recording-info">
                            <div class="info-item">
                                <span class="info-label">Output:</span>
                                <span id="recordingOutput">1920×1080 @ 30fps</span>
                            </div>
                            <div class="info-item">
                                <span class="info-label">Format:</span>
                                <span id="recordingFormat">WebM (VP9/Opus)</span>
                            </div>
                            <div class="info-item">
                                <span class="info-label">Est. Size:</span>
                                <span id="recordingEstSize">~50 MB/min</span>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        :root {
            --accent-color: #2969b0;
            --text-primary: #ffffff;
            --text-secondary: #ffffff;
            --hover-color: #2a2a2a;
            --error-color: #b8312f;
        }

        html,
        body {
            height: 100%;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: var(--primary-bg, #f5f3e9);
            color: var(--text-primary);
        }

        body {
            display: flex;
            flex-direction: column;
        }

        .app-container {
            display: flex;
            flex-direction: column;
            flex: 1;
            background: var(--primary-bg, #f5f3e9);
            transition: background 0.3s ease;
        }

        .header {
            background: var(--secondary-bg, #1a1a1a);
            padding: 12px 16px;
            border-bottom: 2px solid var(--border-color, #898989);
            flex-shrink: 0;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.5);
            position: relative;
            transition: background 0.3s ease;
        }

        .header.gradient-mode {
            background: linear-gradient(135deg, var(--secondary-bg, #1a1a1a) 0%, #151515 100%);
        }

        .header-content {
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-wrap: wrap;
            gap: 12px;
        }

        .header-left {
            display: flex;
            align-items: flex-start;
            gap: 0;
            flex-wrap: wrap;
        }

        /* Header Section Styles */
        .header-section {
            display: flex;
            flex-direction: column;
            align-items: flex-start;
            gap: 8px;
            padding: 12px 16px;
        }

        .section-label {
            font-size: 10px;
            color: var(--text-secondary);
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-bottom: 4px;
        }

        .section-content {
            display: flex;
            flex-direction: column;
            align-items: flex-start;
            gap: 8px;
        }

        .section-divider {
            width: 1px;
            height: 60px;
            background: rgba(255, 255, 255, 0.3);
            margin: 0 8px;
        }

        .horizontal-divider {
            width: 100%;
            height: 1px;
            background: rgba(255, 255, 255, 0.3);
            margin: 8px 0;
        }

        /* Two-column layout for Visualizations section */
        .viz-two-columns {
            display: flex;
            flex-direction: row;
            gap: 24px;
            align-items: flex-start;
        }

        .viz-column {
            display: flex;
            flex-direction: column;
            gap: 10px;
            flex: 1;
            min-width: 200px;
        }

        /* Specific spacing for visualization elements */
        .viz-column .dropdown {
            margin-bottom: 6px;
        }

        .viz-column .morph-controls {
            margin-bottom: 6px;
        }

        .viz-column .presets-container {
            margin-bottom: 6px;
        }

        /* Removed - no longer using viz-column layout */

        /* Balance the two visualization columns */
        .viz-column:first-child {
            border-right: 1px solid rgba(255, 255, 255, 0.1);
            padding-right: 12px;
        }

        .viz-column:last-child {
            padding-left: 12px;
        }

        /* Better organization within columns */
        .viz-column .dropdown,
        .viz-column .morph-controls,
        .viz-column .presets-container {
            background: rgba(255, 255, 255, 0.02);
            border-radius: 6px;
            padding: 10px;
            border: 1px solid rgba(255, 255, 255, 0.05);
        }

        .viz-column .viz-toggle-btn,
        .viz-column .random-viz-btn {
            align-self: flex-start;
            margin: 4px 0;
        }

        /* Control with settings layout (Live Display + gear) */
        .control-with-settings {
            display: flex;
            align-items: center;
            gap: 8px;
            position: relative;
        }

        /* Spectrum with toggle layout */
        .spectrum-with-toggle {
            display: flex;
            align-items: flex-end;
            gap: 12px;
        }

        .spectrum-with-toggle .dropdown {
            flex: 1;
        }

        .spectrum-with-toggle .viz-toggle-btn {
            margin: 0;
            align-self: flex-end;
            height: 32px;
        }

        /* Ensure ON button is highlighted blue by default */
        .viz-toggle-btn.active {
            background: var(--accent-color) !important;
            color: white !important;
            border-color: var(--accent-color) !important;
        }

        /* Spectrum controls container styling */
        .spectrum-controls-container {
            background: rgba(255, 255, 255, 0.02);
            border-radius: 6px;
            padding: 10px;
            border: 1px solid rgba(255, 255, 255, 0.05);
            margin-bottom: 12px;
        }

        .spectrum-controls-container .random-viz-btn {
            margin-top: 8px;
            align-self: flex-start;
            margin-left: 0;
        }

        /* Autopilot Section Styling */
        .autopilot-section {
            background: rgba(255, 255, 255, 0.02);
            border-radius: 6px;
            padding: 10px;
            border: 1px solid rgba(255, 255, 255, 0.05);
            margin-bottom: 12px;
        }

        .autopilot-section .dropdown-label {
            font-weight: 600;
            color: var(--text-primary);
            margin-bottom: 8px;
            text-transform: uppercase;
            font-size: 11px;
            letter-spacing: 0.5px;
        }

        .autopilot-section .control-with-settings {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        /* Autopilot Settings Panel */
        .autopilot-settings-panel {
            position: absolute;
            top: calc(100% + 10px);
            left: 50%;
            transform: translateX(-50%);
            background: var(--secondary-bg, #1a1a1a);
            border: 1px solid var(--border-color, #898989);
            border-radius: 8px;
            padding: 16px;
            z-index: 6000;
            min-width: 600px;
            max-width: 800px;
            width: 90vw;
            max-height: calc(100vh - 200px);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.5);
            overflow-y: auto;
        }

        /* Two-column layout for autopilot settings */
        .autopilot-settings-content {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            height: 100%;
        }

        .autopilot-column {
            display: flex;
            flex-direction: column;
            gap: 12px;
        }

        /* Responsive design for smaller screens */
        @media (max-width: 768px) {
            .autopilot-settings-panel {
                min-width: 320px;
                max-width: 90vw;
                width: 90vw;
            }
            
            .autopilot-settings-content {
                grid-template-columns: 1fr;
                gap: 16px;
            }
        }

        /* Learning Analytics Dashboard Modal */
        .learning-analytics-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            z-index: 10000;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
        }

        .analytics-modal-content {
            background: var(--secondary-bg, #1a1a1a);
            border: 1px solid var(--border-color, #898989);
            border-radius: 12px;
            width: 95%;
            max-width: 1200px;
            max-height: 90vh;
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }

        .analytics-modal-header {
            background: var(--primary-bg, #2a2a2a);
            padding: 20px;
            border-bottom: 1px solid var(--border-color, #898989);
            display: flex;
            align-items: center;
            justify-content: space-between;
            flex-shrink: 0;
        }

        .analytics-modal-header h2 {
            margin: 0;
            color: var(--text-primary);
            font-size: 24px;
        }

        .analytics-controls {
            display: flex;
            align-items: center;
            gap: 15px;
        }

        .analytics-controls label {
            color: var(--text-secondary);
            font-size: 14px;
        }

        .frequency-select {
            background: var(--secondary-bg, #1a1a1a);
            border: 1px solid var(--border-color, #898989);
            color: var(--text-primary);
            padding: 6px 12px;
            border-radius: 4px;
            font-size: 14px;
        }

        .export-btn, .reset-btn {
            background: var(--accent-color);
            border: none;
            color: white;
            padding: 8px 16px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            transition: background 0.2s ease;
        }

        .export-btn:hover, .reset-btn:hover {
            background: var(--accent-hover, #4a9eff);
        }

        .reset-btn {
            background: #e74c3c;
        }

        .reset-btn:hover {
            background: #c0392b;
        }

        .analytics-close-btn {
            background: none;
            border: none;
            color: var(--text-secondary);
            font-size: 24px;
            cursor: pointer;
            padding: 0;
            width: 30px;
            height: 30px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .analytics-close-btn:hover {
            color: var(--text-primary);
        }

        .analytics-content {
            padding: 20px;
            overflow-y: auto;
            flex: 1;
        }

        .analytics-section {
            margin-bottom: 30px;
        }

        .analytics-section h3 {
            color: var(--text-primary);
            margin: 0 0 15px 0;
            font-size: 18px;
            border-bottom: 1px solid var(--border-color, #898989);
            padding-bottom: 8px;
        }

        .analytics-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
        }

        .analytics-card {
            background: rgba(255, 255, 255, 0.02);
            border: 1px solid rgba(255, 255, 255, 0.05);
            border-radius: 8px;
            padding: 20px;
            text-align: center;
        }

        .card-title {
            color: var(--text-secondary);
            font-size: 14px;
            margin-bottom: 8px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .card-value {
            color: var(--accent-color);
            font-size: 28px;
            font-weight: bold;
            margin-bottom: 5px;
        }

        .card-subtitle {
            color: var(--text-secondary);
            font-size: 12px;
        }

        .card-description {
            color: var(--text-secondary);
            font-size: 11px;
            margin-top: 8px;
            line-height: 1.4;
            opacity: 0.8;
            font-style: italic;
        }

        .activity-log {
            background: rgba(255, 255, 255, 0.02);
            border: 1px solid rgba(255, 255, 255, 0.05);
            border-radius: 8px;
            padding: 15px;
            max-height: 200px;
            overflow-y: auto;
        }

        .activity-item {
            color: var(--text-secondary);
            font-size: 14px;
            padding: 5px 0;
            border-bottom: 1px solid rgba(255, 255, 255, 0.05);
        }

        .activity-item:last-child {
            border-bottom: none;
        }

        /* Responsive design for analytics modal */
        @media (max-width: 768px) {
            .analytics-modal-content {
                width: 100%;
                height: 100%;
                max-height: 100vh;
                border-radius: 0;
            }
            
            .analytics-grid {
                grid-template-columns: 1fr;
            }
            
            .analytics-controls {
                flex-direction: column;
                gap: 10px;
                align-items: flex-start;
            }
        }

        /* Autopilot setting button styles */
        .scope-btn, .timing-btn, .sensitivity-btn {
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid var(--border-color, #898989);
            color: var(--text-secondary);
            padding: 6px 12px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 11px;
            transition: all 0.2s ease;
        }

        .scope-btn:hover, .timing-btn:hover, .sensitivity-btn:hover {
            background: rgba(255, 255, 255, 0.2);
            border-color: var(--accent-color);
        }

        .scope-btn.active, .timing-btn.active, .sensitivity-btn.active, .genre-btn.active {
            background: var(--accent-color);
            color: white;
            border-color: var(--accent-color);
        }
        
        /* Genre button styles */
        .genre-btn {
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid var(--border-color, #898989);
            color: var(--text-secondary);
            padding: 4px 8px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 10px;
            transition: all 0.2s ease;
            margin: 2px;
        }
        
        .genre-btn:hover {
            background: rgba(255, 255, 255, 0.2);
            border-color: var(--accent-color);
        }
        
        .genre-btn.active {
            background: var(--accent-color);
            color: white;
            border-color: var(--accent-color);
        }
        
        /* Info display styles */
        .info-display {
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.1);
            color: var(--accent-color);
            padding: 8px 12px;
            border-radius: 4px;
            font-size: 12px;
            font-weight: 500;
            text-align: center;
            min-height: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        /* Presets Container */
        .presets-container {
            background: rgba(255, 255, 255, 0.02);
            border-radius: 6px;
            padding: 10px;
            border: 1px solid rgba(255, 255, 255, 0.05);
            margin-bottom: 12px;
        }

        .preset-buttons {
            display: flex;
            flex-wrap: wrap;
            gap: 6px;
            align-items: flex-start;
        }

        /* Color Scheme Container */
        .color-scheme-container {
            background: rgba(255, 255, 255, 0.02);
            border-radius: 6px;
            padding: 10px;
            border: 1px solid rgba(255, 255, 255, 0.05);
            margin-bottom: 12px;
        }

        /* Morph Controls */
        .morph-controls {
            background: rgba(255, 255, 255, 0.02);
            border-radius: 6px;
            padding: 10px;
            border: 1px solid rgba(255, 255, 255, 0.05);
            margin-bottom: 12px;
        }

        .morph-buttons {
            display: flex;
            gap: 6px;
            align-items: flex-start;
        }

        .logo {
            display: flex;
            align-items: center;
            gap: 8px;
            flex-shrink: 0;
        }

        .logo img {
            width: 36px;
            height: 36px;
            border-radius: 50%;
        }

        .logo h1 {
            font-size: 22px;
            font-weight: 700;
            color: var(--accent-color);
        }

        .info-button {
            position: absolute;
            top: 12px;
            right: 16px;
            width: 28px;
            height: 28px;
            border-radius: 50%;
            background: var(--hover-color);
            border: 1px solid var(--border-color, #898989);
            color: var(--text-secondary);
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 14px;
            font-style: italic;
            transition: all 0.3s ease;
            z-index: 100;
        }

        .info-button.gradient-mode {
            background: linear-gradient(135deg, var(--hover-color) 0%, #202020 100%);
        }

        .info-button:hover {
            background: var(--accent-color);
            color: var(--primary-bg, #f5f3e9);
            transform: scale(1.1);
        }

        .info-button:hover.gradient-mode {
            background: linear-gradient(135deg, var(--accent-color) 0%, var(--accent-color) 100%);
        }

        .info-popup {
            display: none;
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: var(--secondary-bg, #1a1a1a);
            padding: 24px;
            border-radius: 12px;
            border: 2px solid var(--accent-color);
            text-align: center;
            z-index: 1000;
            max-width: 90%;
            width: 400px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.9);
        }

        .info-popup.gradient-mode {
            background: linear-gradient(135deg, var(--secondary-bg, #1a1a1a) 0%, #252525 100%);
        }

        .info-popup.active {
            display: block;
        }

        .info-popup h3 {
            color: var(--accent-color);
            margin-bottom: 16px;
            font-size: 18px;
        }

        .info-popup p {
            color: var(--text-primary);
            line-height: 1.6;
            margin-bottom: 20px;
        }

        .info-popup button {
            background: var(--accent-color);
            color: var(--primary-bg, #f5f3e9);
            border: none;
            padding: 8px 20px;
            border-radius: 20px;
            cursor: pointer;
            font-weight: 600;
            transition: all 0.3s ease;
        }

        .info-popup button.gradient-mode {
            background: linear-gradient(135deg, var(--accent-color) 0%, var(--accent-color) 100%);
        }

        .info-popup button:hover {
            transform: scale(1.05);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
        }

        .popup-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            z-index: 999;
        }

        .popup-overlay.active {
            display: block;
        }

        /* New dropdown styles */
        .dropdown {
            position: relative;
            display: inline-block;
            z-index: 200;
        }

        .dropdown-toggle {
            background: var(--hover-color);
            border: 1px solid var(--border-color, #898989);
            color: var(--text-secondary);
            padding: 8px 16px;
            border-radius: 20px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 12px;
            white-space: nowrap;
            user-select: none;
            min-width: 120px;
            text-align: center;
        }

        .dropdown-toggle.gradient-mode {
            background: linear-gradient(135deg, var(--hover-color) 0%, #202020 100%);
        }

        .dropdown-toggle:hover {
            background: var(--accent-color);
            color: var(--primary-bg, #f5f3e9);
            transform: translateY(-2px);
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.4);
        }

        .dropdown-content {
            display: none;
            position: absolute;
            background: var(--secondary-bg, #1a1a1a);
            min-width: 200px;
            box-shadow: 0 8px 16px rgba(0, 0, 0, 0.5);
            border: 1px solid var(--border-color, #898989);
            border-radius: 8px;
            z-index: 1000;
            max-height: 300px;
            overflow-y: auto;
            margin-top: 4px;
        }

        .dropdown-content.show {
            display: block;
        }

        .dropdown-item {
            color: var(--text-primary);
            padding: 12px 16px;
            text-decoration: none;
            display: block;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 12px;
        }

        .dropdown-item:hover {
            background: var(--hover-color);
        }

        .dropdown-item.active {
            background: var(--accent-color);
            color: var(--primary-bg, #f5f3e9);
        }

        .dropdown-label {
            font-size: 10px;
            color: var(--text-secondary);
            margin-bottom: 4px;
            text-transform: uppercase;
            letter-spacing: 1px;
            opacity: 0.7;
        }


        .playlist-dropdown .dropdown-content {
            right: 0;
            width: 300px;
            max-height: 600px;
        }

        .playlist-dropdown-item {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 12px 16px;
            cursor: pointer;
            transition: all 0.3s ease;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }

        .playlist-dropdown-item:hover {
            background: var(--hover-color);
        }

        .playlist-dropdown-item.active {
            background: var(--accent-color);
            color: var(--primary-bg, #f5f3e9);
        }
        .playlist-album-cover {
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            padding: 0;
            border-bottom: 1px solid rgba(255, 255, 255, 0.2);
        }

        .playlist-album-cover img {
            width: 100%;
            height: auto;
            display: block;
        }

        .playlist-album-name {
            color: var(--text-primary);
            font-size: 14px;
            font-weight: 600;
            padding: 12px;
            text-align: center;
            width: 100%;
        }

        .playlist-album-icon {
            width: 40px;
            height: 40px;
            background: var(--hover-color);
            border-radius: 4px;
            display: flex;
            align-items: center;
            justify-content: center;
            flex-shrink: 0;
        }

        .playlist-album-icon svg {
            width: 24px;
            height: 24px;
            fill: var(--text-secondary);
            opacity: 0.7;
        }

        .playlist-dropdown-item.active .playlist-album-icon svg {
            fill: var(--primary-bg, #f5f3e9);
            opacity: 1;
        }

        .playlist-track-name {
            flex: 1;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
            font-size: 14px;
            color: var(--text-primary);
        }

        .playlist-album-cover {
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 16px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.2);
        }

        .playlist-album-cover img {
            height: auto;
            border-radius: 4px;
        }

        .playlist-album-icon {
            width: 28px;
            height: 28px;
            display: flex;
            align-items: center;
            justify-content: center;
            flex-shrink: 0;
        }

        .playlist-album-icon img {
            width: 28px;
            height: 28px;
            border-radius: 4px;
            object-fit: cover;
        }

        .viz-toggle-btn {
            min-width: 50px !important;
            text-align: center;
            font-weight: 600;
            margin-left: 8px;
        }

        .viz-toggle-btn.active {
            background: var(--accent-color);
            color: var(--primary-bg, #f5f3e9);
        }

        /* Video Input Controls */
        .video-controls-panel {
            position: absolute;
            top: calc(100% + 10px);
            left: 50%;
            transform: translateX(-50%);
            background: var(--secondary-bg, #1a1a1a);
            border: 1px solid var(--border-color, #898989);
            border-radius: 8px;
            padding: 16px;
            z-index: 6000;
            min-width: 280px;
            max-width: 350px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.5);
        }

        .slider-container {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 8px;
        }

        .slider-container label {
            font-size: 11px;
            color: var(--text-secondary);
            min-width: 60px;
        }

        .slider-container input[type="range"] {
            flex: 1;
            height: 4px;
        }

        .slider-container span {
            font-size: 10px;
            color: var(--text-secondary);
            min-width: 35px;
            text-align: right;
        }

        #bgVideo {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            object-fit: cover;
            z-index: 0; /* Changed from -1 to 0 */
            opacity: 0;
            transition: opacity 3s linear;
            pointer-events: none;
        }

        /* When video is active, make backgrounds transparent */
        .video-active {
            background: transparent !important;
        }

        .video-active .main-area {
            background: transparent !important;
        }

        .video-active #visualizer {
            background: transparent !important;
        }

        .input-mode-btn.video-active {
            background: #4CAF50;
            color: white;
        }

        .panel-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 12px;
            padding-bottom: 8px;
            border-bottom: 1px solid var(--border-color, #898989);
        }

        .panel-header span {
            font-size: 12px;
            color: var(--text-primary);
            font-weight: 600;
        }

        .panel-close-btn {
            background: transparent;
            border: none;
            color: var(--text-secondary);
            font-size: 20px;
            cursor: pointer;
            padding: 0;
            width: 20px;
            height: 20px;
            line-height: 18px;
            text-align: center;
            transition: all 0.2s ease;
        }

        .panel-close-btn:hover {
            color: var(--accent-color);
            transform: scale(1.2);
        }


        /* Video Controls */
        .control-group {
            margin-bottom: 12px;
            padding-bottom: 12px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }

        .control-group:last-child {
            border-bottom: none;
        }

        .group-label {
            font-size: 11px;
            color: var(--accent-color);
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-bottom: 8px;
            opacity: 0.8;
        }

        .button-container {
            display: flex;
            gap: 8px;
            margin-top: 8px;
        }

        .beat-button-container {
            display: flex;
            gap: 8px;
            margin-top: 14px;
        }

        .effect-toggle-btn {
            flex: 1;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: var(--text-secondary);
            padding: 6px 12px;
            border-radius: 16px;
            cursor: pointer;
            font-size: 11px;
            transition: all 0.2s ease;
        }

        .effect-toggle-btn:hover {
            background: rgba(255, 255, 255, 0.2);
        }

        .effect-toggle-btn.active {
            background: var(--accent-color);
            color: white;
        }

        .preset-buttons {
            display: flex;
            flex-wrap: wrap;
            gap: 6px;
        }

        .video-preset-btn {
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: var(--text-secondary);
            padding: 4px 10px;
            border-radius: 12px;
            cursor: pointer;
            font-size: 10px;
            transition: all 0.2s ease;
        }

        .video-preset-btn:hover {
            background: var(--accent-color);
            color: white;
        }

        .video-vignette {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 2;
        }

        #bgVideo.mirror-horizontal {
            transform: scaleX(-1);
        }

        #bgVideo.mirror-vertical {
            transform: scaleY(-1);
        }

        #bgVideo.mirror-both {
            transform: scale(-1, -1);
        }

        @keyframes videoPulse {
            0,
            100% {
                transform: scale(1);
            }
            50% {
                transform: scale(1.02);
            }
        }

        #bgVideo.pulse-active {
            animation: videoPulse var(--pulse-duration, 2s) ease-in-out infinite;
        }

        .audio-device-select.video-active {
            border-color: #4CAF50;
            background: rgba(76, 175, 80, 0.1);
        }


        /* Fullscreen exit button */
        .fullscreen-exit-btn {
            display: none;
            position: fixed;
            top: 20px;
            right: 20px;
            width: 40px;
            height: 40px;
            background: rgba(255, 255, 255, 0.15);
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            cursor: pointer;
            z-index: 10002;
            align-items: center;
            justify-content: center;
            transition: all 0.3s ease;
        }

        .fullscreen-exit-btn:hover {
            background: rgba(255, 255, 255, 0.25);
            transform: scale(1.1);
        }

        .fullscreen-exit-btn svg {
            width: 20px;
            height: 20px;
            fill: rgba(255, 255, 255, 0.9);
        }

        body.fullscreen-mode .fullscreen-exit-btn {
            display: flex;
        }

        /* Hide old button styles */
        .color-schemes,
        .viz-selector,
        .playlist-container {
            display: none;
        }

        .random-viz-btn {
            margin-left: 8px;
        }

        .color-btn {
            background: var(--hover-color);
            border: 1px solid var(--border-color, #898989);
            color: var(--text-secondary);
            padding: 6px 12px;
            border-radius: 16px;
            cursor: pointer;
            transition: all 0.4s ease;
            font-size: 11px;
            white-space: nowrap;
            user-select: none;
            position: relative;
            overflow: hidden;
        }

        .color-btn.gradient-mode {
            background: linear-gradient(135deg, var(--hover-color) 0%, #202020 100%);
        }

        .color-btn:hover,
        .color-btn.active {
            transform: translateY(-2px);
            box-shadow: 0 4px 15px rgba(255, 255, 255, 0.2);
        }

        .color-btn.default:hover,
        .color-btn.default.active {
            background: var(--accent-color);
            color: var(--primary-bg, #f5f3e9);
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.4);
        }

        .color-btn.earthtones:hover,
        .color-btn.earthtones.active {
            background: #D2691E;
            color: white;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.4);
        }

        .color-btn.luigi:hover,
        .color-btn.luigi.active {
            background: #0000FF;
            color: white;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.4);
        }

        .color-btn.metal:hover,
        .color-btn.metal.active {
            background: linear-gradient(135deg, #C0C0C0 0%, #808080 100%);
            color: #222;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.4);
        }

        .color-btn.psychedelic:hover,
        .color-btn.psychedelic.active {
            background: linear-gradient(135deg, #FF1493 0%, #9400D3 50%, #00CED1 100%);
            color: white;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.4);
        }

        .viz-btn {
            background: var(--hover-color);
            border: 1px solid var(--border-color, #898989);
            color: var(--text-secondary);
            padding: 8px 16px;
            border-radius: 20px;
            cursor: pointer;
            transition: all 0.4s ease;
            font-size: 12px;
            white-space: nowrap;
            user-select: none;
            position: relative;
            overflow: hidden;
        }

        .viz-btn.gradient-mode {
            background: linear-gradient(135deg, var(--hover-color) 0%, #202020 100%);
        }

        .viz-btn:hover,
        .viz-btn.active {
            background: var(--accent-color);
            color: var(--primary-bg, #f5f3e9);
            transform: translateY(-2px);
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.4);
        }

        .viz-btn:hover.gradient-mode,
        .viz-btn.active.gradient-mode {
            background: linear-gradient(135deg, var(--accent-color) 0%, var(--accent-color) 100%);
        }

        .viz-btn.random {
            background: var(--accent-color);
            color: var(--primary-bg, #f5f3e9);
            font-weight: 600;
        }

        .viz-btn.random.gradient-mode {
            background: linear-gradient(135deg, var(--accent-color) 0%, var(--accent-color) 100%);
        }

        .viz-btn.random:hover {
            animation: pulse 0.5s ease-in-out;
        }
        .video-settings-toggle {
            background: var(--hover-color);
            border: 1px solid var(--border-color, #898989);
            color: var(--text-secondary);
            width: 32px;
            height: 32px;
            border-radius: 50%;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 16px;
            margin-left: 4px;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            vertical-align: middle;
        }

        .video-settings-toggle:hover {
            background: var(--accent-color);
            color: var(--primary-bg, #f5f3e9);
            transform: rotate(90deg) scale(1.1);
        }

        .video-settings-toggle:active {
            transform: rotate(90deg) scale(0.95);
        }

        /* When video is active, keep the gear visible */
        .video-active + .video-settings-toggle {
            opacity: 1;
        }

        /* Mobile adjustments */
        @media(max-width: 768px) {
            .video-settings-toggle {
                width: 28px;
                height: 28px;
                font-size: 14px;
            }
        }

        .fullscreen-controls {
            display: none;
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(30, 30, 30, 0.95);
            border: 1px solid rgba(137, 137, 137, 0.5);
            border-radius: 25px;
            padding: 12px 20px;
            backdrop-filter: blur(15px);
            z-index: 10001;
            flex-direction: row;
            align-items: center;
            gap: 20px;
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.7);
            max-width: 90%;
            width: auto;
        }

        #fullscreenControls {
            transition: opacity 0.3s ease;
        }

        #fullscreenControls.hidden {
            opacity: 0;
            pointer-events: none;
        }

        .visualization-container .fullscreen-controls {
            display: flex !important;
        }

        .fs-section {
            display: flex;
            align-items: center;
            gap: 8px;
            position: relative;
        }

        .fs-section::after {
            content: '';
            position: absolute;
            right: -10px;
            top: 50%;
            transform: translateY(-50%);
            width: 1px;
            height: 24px;
            background: rgba(255, 255, 255, 0.1);
        }

        .fs-section:last-child::after {
            display: none;
        }

        /* Control Buttons */
        .fs-control-btn {
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: #ffffff;
            width: 36px;
            height: 36px;
            border-radius: 50%;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.3s ease;
            font-size: 14px;
            position: relative;
        }

        .fs-control-btn:hover {
            background: rgba(255, 255, 255, 0.2);
            transform: scale(1.1);
        }

        .fs-control-btn.active {
            background: rgba(41, 105, 176, 0.8);
        }

        .fs-control-btn svg {
            width: 18px;
            height: 18px;
            fill: currentColor;
        }

        .fs-loop-indicator {
            position: absolute;
            top: 2px;
            right: 2px;
            font-size: 10px;
            font-weight: bold;
            background: rgba(0, 0, 0, 0.5);
            border-radius: 50%;
            width: 14px;
            height: 14px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        /* Track Info */
        .fs-track-info {
            min-width: 200px;
            max-width: 300px;
        }

        .fs-track-title {
            font-size: 12px;
            color: #2969b0;
            margin-bottom: 4px;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .fs-progress-container {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .fs-progress-bar {
            flex: 1;
            height: 4px;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 2px;
            cursor: pointer;
            position: relative;
        }

        .fs-progress-fill {
            height: 100%;
            background: #2969b0;
            border-radius: 2px;
            width: 0;
            transition: width 0.2s ease;
        }

        .fs-time-display {
            font-size: 10px;
            color: rgba(255, 255, 255, 0.7);
            min-width: 60px;
            font-family: monospace;
        }

        /* Volume */
        .fs-volume {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .fs-volume-slider {
            width: 80px;
            height: 4px;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 2px;
            cursor: pointer;
            position: relative;
        }

        .fs-volume-fill {
            height: 100%;
            background: #2969b0;
            border-radius: 2px;
            width: 70%;
            transition: width 0.2s ease;
        }

        /* Dropdowns */
        .fs-select {
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: #ffffff;
            padding: 6px 10px;
            border-radius: 18px;
            font-size: 11px;
            cursor: pointer;
        }

        .fs-select option {
            background: #2a2a2a;
            color: #ffffff;
        }


        .fs-morph-speed {
            width: 70px;
        }

        /* Color Picker */
        .fs-eyedropper-icon::before {
            content: '';
            position: absolute;
            width: 12px;
            height: 12px;
            background: linear-gradient(135deg, transparent 40%, currentColor 40%, currentColor 60%, transparent 60%);
            transform: rotate(45deg);
        }

        .fs-eyedropper-icon::after {
            content: '';
            position: absolute;
            width: 4px;
            height: 4px;
            border: 2px solid currentColor;
            border-radius: 50%;
            top: 1px;
            left: 1px;
        }

        .fs-color-picker {
            position: absolute;
            width: 0;
            height: 0;
            opacity: 0;
            pointer-events: none;
        }

        /* Random Button */
        .fs-random-btn {
            /* background: rgba(41, 105, 176, 0.9);*/
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.3);
            color: #ffffff;
            padding: 8px 16px;
            border-radius: 20px;
            cursor: pointer;
            font-size: 12px;
            font-weight: 600;
            transition: all 0.3s ease;
        }

        .fs-random-btn:hover {
            background: rgba(41, 105, 176, 1);
            transform: scale(1.05);
        }

        /* Mobile adjustments */
        @media(max-width: 1024px) {
            .fullscreen-controls {
                padding: 8px 12px;
                gap: 12px;
                font-size: 10px;
            }

            .fs-track-info {
                min-width: 150px;
            }

            .fs-select {
                padding: 4px 8px;
                font-size: 10px;
            }
        }

        @media(max-width: 768px) {
            .fullscreen-controls {
                flex-wrap: wrap;
                justify-content: center;
            }

            .fs-section::after {
                display: none;
            }
        }


        /* Mobile responsive */
        @media(max-width: 768px) {
            .fullscreen-controls {
                left: 10px;
                right: 90px;
                padding: 6px 10px;
                gap: 8px;
            }

            .fs-control-btn {
                width: 32px;
                height: 32px;
                font-size: 12px;
            }

            .fs-volume-control {
                display: none; /* Hide volume on mobile to save space */
            }

            .fs-viz-select {
                font-size: 11px;
                padding: 4px 8px;
            }
        }

        @keyframes pulse {
            0% {
                transform: scale(1) translateY(-2px);
            }
            50% {
                transform: scale(1.05) translateY(-2px);
            }
            100% {
                transform: scale(1) translateY(-2px);
            }
        }
        .input-mode-container {
            display: flex;
            align-items: center;
            gap: 8px;
            position: relative;
        }

        .input-mode-btn {
            background: var(--hover-color);
            border: 1px solid var(--border-color, #898989);
            color: var(--text-secondary);
            padding: 8px 16px;
            border-radius: 20px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 12px;
            min-width: 100px;
        }

        .input-mode-btn:hover {
            background: var(--accent-color);
            color: var(--primary-bg, #f5f3e9);
            transform: translateY(-2px);
        }

        .input-mode-btn.live-mode {
            background: #ff3333;
            color: white;
            animation: pulse-live 2s infinite;
        }

        @keyframes pulse-live {
            0,
            100% {
                opacity: 1;
            }
            50% {
                opacity: 0.7;
            }
        }

        .audio-device-select {
            background: var(--hover-color);
            border: 1px solid var(--border-color, #898989);
            color: var(--text-primary);
            padding: 6px 12px;
            border-radius: 20px;
            font-size: 12px;
            min-width: 200px;
        }

        /* Video file controls */
        .video-file-info {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-top: 8px;
            padding: 8px;
            background: var(--hover-color);
            border: 1px solid var(--border-color, #898989);
            border-radius: 20px;
            font-size: 12px;
        }

        .video-file-name {
            flex: 1;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            color: var(--text-primary);
        }

        .video-file-controls-inline {
            display: flex;
            gap: 4px;
        }

        .video-file-control-btn {
            background: var(--hover-color);
            border: 1px solid var(--border-color, #898989);
            color: var(--text-secondary);
            padding: 4px 8px;
            border-radius: 10px;
            font-size: 11px;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .video-file-control-btn:hover {
            border-color: var(--accent-color);
            color: var(--text-primary);
        }

        .video-file-control-btn.active {
            border-color: #4CAF50;
            background: rgba(76, 175, 80, 0.1);
            color: var(--text-primary);
        }


        #displaySettingsBtn {
            display: inline-flex !important;
            visibility: visible !important;
            opacity: 1 !important;
        }

        .main-area {
            flex: 1;
            position: relative;
            min-height: 300px;
            background: #0a0a0a;
            display: flex;
            gap: 0;
            transition: background 0.3s ease;
        }

        .visualization-container {
            flex: 1;
            position: relative;
            min-width: 0;
            background: #000000;
            transition: background 0.3s ease;
        }

        #visualizer {
            width: 100%;
            height: 100%;
            background: transparent;
            display: block;
            /* position: relative; */
            position: absolute;
            top: 0;
            left: 0;
            z-index: 1;
        }

        .loading,
        .error-message {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: var(--secondary-bg, #1a1a1a);
            padding: 24px;
            border-radius: 12px;
            border: 1px solid var(--border-color, #898989);
            text-align: center;
            z-index: 10;
            backdrop-filter: blur(15px);
            max-width: 80%;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.7);
        }

        .loading.gradient-mode,
        .error-message.gradient-mode {
            background: linear-gradient(135deg, var(--secondary-bg, #1a1a1a) 0%, #252525 100%);
        }

        .morph-controls {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .morph-btn {
            background: var(--hover-color);
            border: 1px solid var(--border-color, #898989);
            color: var(--text-secondary);
            padding: 8px 16px;
            border-radius: 20px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 12px;
            min-width: 100px;
        }

        .morph-btn:hover {
            background: var(--accent-color);
            color: var(--primary-bg, #f5f3e9);
            transform: translateY(-2px);
        }

        .morph-btn.active {
            background: linear-gradient(90deg, #ff0080, #ff8c00, #ffd700, #00ff00, #00ffff, #0080ff, #8000ff, #ff0080);
            background-size: 200% 100%;
            animation: morph-gradient 3s linear infinite;
            color: white;
        }

        @keyframes morph-gradient {
            0% {
                background-position: 0 50%;
            }
            100% {
                background-position: 200% 50%;
            }
        }

        .morph-speed-select {
            background: var(--hover-color);
            border: 1px solid var(--border-color, #898989);
            color: var(--text-primary);
            padding: 6px 12px;
            border-radius: 20px;
            font-size: 12px;
        }

        .energy-container {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .energy-label {
            font-size: 11px;
            color: var(--text-secondary);
        }

        .energy-bar {
            width: 100px;
            height: 8px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 4px;
            overflow: hidden;
        }

        .energy-indicator {
            height: 100%;
            width: 0;
            background: #00ff00;
            transition: width 0.1s ease, background 0.3s ease;
        }


        .error-message {
            color: var(--error-color);
            border-color: var(--error-color);
        }

        .footer {
            background: var(--secondary-bg, #1a1a1a);
            padding: 16px 20px;
            border-top: 2px solid var(--border-color, #898989);
            flex-shrink: 0;
            box-shadow: 0 -2px 10px rgba(0, 0, 0, 0.5);
            transition: background 0.3s ease;
        }

        .footer.gradient-mode {
            background: linear-gradient(135deg, var(--secondary-bg, #1a1a1a) 0%, #151515 100%);
        }

        .controls {
            display: flex;
            align-items: center;
            gap: 20px;
            flex-wrap: wrap;
            justify-content: center;
        }

        .playback-controls {
            display: flex;
            gap: 12px;
            align-items: center;
        }

        .control-btn,
        .fullscreen-btn,
        .loop-btn,
        .transparent-btn {
            background: var(--hover-color);
            border: none;
            color: var(--text-primary);
            width: 44px;
            height: 44px;
            border-radius: 50%;
            cursor: pointer;
            transition: all 0.4s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 14px;
            user-select: none;
            position: relative;
            overflow: hidden;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
        }

        .control-btn.gradient-mode,
        .fullscreen-btn.gradient-mode,
        .loop-btn.gradient-mode,
        .transparent-btn.gradient-mode {
            background: linear-gradient(135deg, var(--hover-color) 0%, #303030 100%);
        }

        .control-btn svg,
        .loop-btn svg {
            pointer-events: none;
        }

        .control-btn:hover,
        .fullscreen-btn:hover,
        .loop-btn:hover,
        .transparent-btn:hover {
            background: #404040;
            transform: scale(1.1);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.5);
        }

        .control-btn:hover.gradient-mode,
        .fullscreen-btn:hover.gradient-mode,
        .loop-btn:hover.gradient-mode,
        .transparent-btn:hover.gradient-mode {
            background: linear-gradient(135deg, #404040 0%, #505050 100%);
        }

        .control-btn.active,
        .loop-btn.active,
        .transparent-btn.active {
            background: var(--accent-color);
            color: var(--primary-bg, #f5f3e9);
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.4);
        }

        .control-btn.active.gradient-mode,
        .loop-btn.active.gradient-mode,
        .transparent-btn.active.gradient-mode {
            background: linear-gradient(135deg, var(--accent-color) 0%, var(--accent-color) 100%);
        }

        .presets-container {
            display: flex;
            align-items: center;
            gap: 10px;
            flex-wrap: wrap;
        }

        .preset-btn {
            background: var(--hover-color);
            border: 1px solid var(--border-color, #898989);
            color: var(--text-secondary);
            padding: 6px 12px;
            border-radius: 16px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 11px;
            white-space: nowrap;
        }

        .preset-btn:hover {
            background: var(--accent-color);
            color: var(--primary-bg, #f5f3e9);
            transform: translateY(-1px);
        }

        .preset-selector {
            background: var(--hover-color);
            border: 1px solid var(--border-color, #898989);
            color: var(--text-primary);
            padding: 4px 8px;
            border-radius: 8px;
            font-size: 11px;
            cursor: pointer;
            min-width: 120px;
        }

        .preset-selector option {
            background: var(--secondary-bg, #1a1a1a);
            color: var(--text-primary);
        }

        .color-picker-wrapper {
            position: relative;
        }

        .color-picker-input {
            position: absolute;
            width: 0;
            height: 0;
            opacity: 0;
            pointer-events: none;
        }

        .eyedropper-icon {
            width: 20px;
            height: 20px;
            position: relative;
        }

        .eyedropper-icon::before {
            content: '';
            position: absolute;
            width: 16px;
            height: 16px;
            background: linear-gradient(135deg, transparent 40%, currentColor 40%, currentColor 60%, transparent 60%);
            transform: rotate(45deg);
            top: 2px;
            left: 2px;
        }

        .eyedropper-icon::after {
            content: '';
            position: absolute;
            width: 6px;
            height: 6px;
            border: 2px solid currentColor;
            border-radius: 50%;
            top: 1px;
            left: 1px;
        }

        .error-message {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: var(--secondary-bg, #1a1a1a);
            padding: 24px;
            border-radius: 12px;
            border: 1px solid var(--border-color, #898989);
            text-align: center;
            z-index: 10;
            backdrop-filter: blur(15px);
            max-width: 80%;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.7);
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .error-message:hover {
            transform: translate(-50%, -50%) scale(1.02);
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.8);
        }

        .error-message::after {
            content: "Click to dismiss";
            display: block;
            font-size: 10px;
            opacity: 0.6;
            margin-top: 10px;
        }


        .fullscreen-random-btn {
            display: none;
            position: fixed;
            bottom: 20px;
            right: 20px;
            background: rgba(42, 42, 42, 0.9);
            border: 1px solid rgba(137, 137, 137, 0.5);
            color: #ffffff;
            padding: 12px 20px;
            border-radius: 25px;
            cursor: pointer;
            z-index: 10001;
            font-size: 14px;
            font-weight: 600;
            backdrop-filter: blur(10px);
            transition: all 0.3s ease;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.5);
        }

        .fullscreen-random-btn:hover {
            background: rgba(41, 105, 176, 0.9);
            transform: scale(1.05);
            box-shadow: 0 6px 16px rgba(0, 0, 0, 0.7);
        }

        .visualization-container .fullscreen-random-btn {
            display: block !important;
            position: fixed !important;
            z-index: 10001 !important;
        }

        .loop-btn svg {
            width: 20px;
            height: 20px;
            fill: currentColor;
        }

        .loop-indicator {
            position: absolute;
            top: 2px;
            right: 2px;
            font-size: 10px;
            font-weight: bold;
            background: rgba(0, 0, 0, 0.5);
            border-radius: 50%;
            width: 14px;
            height: 14px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .track-info {
            flex: 1;
            max-width: 350px;
            min-width: 250px;
        }

        .track-title {
            font-size: 16px;
            font-weight: 600;
            margin-bottom: 8px;
            text-align: center;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            color: var(--accent-color);
        }

        .progress-container {
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .progress-bar {
            flex: 1;
            height: 6px;
            background: var(--hover-color);
            border-radius: 3px;
            cursor: pointer;
            position: relative;
            overflow: hidden;
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.5);
        }

        .progress-bar.gradient-mode {
            background: linear-gradient(90deg, var(--hover-color), #252525);
        }

        .progress-fill {
            height: 100%;
            background: var(--accent-color);
            border-radius: 3px;
            width: 0;
            transition: width 0.2s ease;
        }

        .progress-fill.gradient-mode {
            background: linear-gradient(90deg, var(--accent-color), #00cc70);
        }

        .time-display {
            font-size: 11px;
            color: var(--text-secondary);
            min-width: 80px;
            text-align: center;
            font-family: monospace;
        }

        .volume-control {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .volume-slider {
            width: 80px;
            height: 6px;
            background: var(--hover-color);
            border-radius: 3px;
            cursor: pointer;
            position: relative;
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.5);
        }

        .volume-slider.gradient-mode {
            background: linear-gradient(90deg, var(--hover-color), #252525);
        }

        .volume-fill {
            height: 100%;
            background: var(--accent-color);
            border-radius: 3px;
            width: 70%;
            transition: width 0.2s ease;
        }

        .volume-fill.gradient-mode {
            background: linear-gradient(90deg, var(--accent-color), #00cc70);
        }

        .playlist-header {
            padding: 16px;
            border-bottom: 1px solid var(--border-color, #898989);
            background: var(--primary-bg, #f5f3e9);
            flex-shrink: 0;
            transition: background 0.3s ease;
        }

        .playlist-header.gradient-mode {
            background: linear-gradient(135deg, var(--primary-bg, #f5f3e9) 0%, #151515 100%);
        }

        .playlist-header h3 {
            color: var(--accent-color);
            text-align: center;
            font-size: 16px;
        }

        .playlist-items {
            flex: 1;
            overflow-y: auto;
            padding: 8px;
        }

        .playlist-items::-webkit-scrollbar {
            width: 6px;
        }

        .playlist-items::-webkit-scrollbar-track {
            background: var(--primary-bg, #f5f3e9);
        }

        .playlist-items::-webkit-scrollbar-thumb {
            background: var(--accent-color);
            border-radius: 3px;
        }

        .playlist-items::-webkit-scrollbar-thumb:hover {
            background: #00cc70;
        }

        .playlist-item {
            padding: 16px;
            cursor: pointer;
            border-radius: 8px;
            margin-bottom: 6px;
            transition: all 0.3s ease;
            border: 1px solid transparent;
            font-size: 14px;
            position: relative;
            overflow: hidden;
            background: var(--secondary-bg, #1a1a1a);
            color: var(--text-primary);
        }

        .playlist-item:hover {
            background: var(--hover-color);
            border-color: var(--border-color, #898989);
            transform: translateX(5px);
            color: var(--text-primary);
        }

        .playlist-item.active {
            background: var(--accent-color);
            color: var(--primary-bg, #f5f3e9);
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.4);
        }

        .playlist-item.active.luigi-scheme {
            background: #00A000;
            color: white;
        }

        .playlist-item.active.gradient-mode {
            background: linear-gradient(135deg, var(--accent-color) 0%, var(--accent-color) 100%);
        }

        .kaleidoscope-controls {
            position: relative;
            background: rgba(255, 255, 255, 0.02);
            border-radius: 6px;
            padding: 10px;
            border: 1px solid rgba(255, 255, 255, 0.05);
            margin-bottom: 12px;
            display: flex;
            flex-direction: column;
            align-items: flex-start;
            gap: 4px;
        }

        .kaleidoscope-btn {
            min-width: 120px;
        }

        .kaleidoscope-settings-btn {
            background: var(--hover-color);
            border: 1px solid var(--border-color, #898989);
            color: var(--text-secondary);
            width: 32px;
            height: 32px;
            border-radius: 50%;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 16px;
            display: inline-flex;
            align-items: center;
            justify-content: center;
        }

        .kaleidoscope-settings-btn:hover {
            background: var(--accent-color);
            color: var(--primary-bg, #f5f3e9);
            transform: rotate(90deg) scale(1.1);
        }

        .kaleidoscope-panel {
            position: absolute;
            top: calc(100% + 0px);
            left: 0;
            background: var(--secondary-bg, #1a1a1a);
            border: 1px solid var(--border-color, #898989);
            border-radius: 8px;
            padding: 12px;
            margin-top: 8px;
            z-index: 1000;
            min-width: 250px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.5);
        }
        
        .kaleidoscope-panel .dropdown-select {
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 4px;
            color: white;
            padding: 8px;
            font-size: 14px;
            width: 100%;
        }
        
        .kaleidoscope-panel .dropdown-select option {
            background: #333;
            color: white;
        }
        
        .kaleidoscope-panel .toggle-btn {
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 4px;
            color: white;
            padding: 8px 12px;
            font-size: 14px;
            cursor: pointer;
            transition: all 0.3s ease;
            width: 100%;
        }
        
        .kaleidoscope-panel .toggle-btn:hover {
            background: rgba(255, 255, 255, 0.2);
        }
        
        .kaleidoscope-panel .toggle-btn.active {
            background: var(--accent-color, #ff6b6b);
            border-color: var(--accent-color, #ff6b6b);
        }

        /* Kaleidoscope canvas overlay */
        .kaleidoscope-canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 1; /* Default to behind viz */
            background: transparent;
        }

        .kaleidoscope-preset-btn {
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: var(--text-secondary);
            padding: 4px 10px;
            border-radius: 12px;
            cursor: pointer;
            font-size: 10px;
            transition: all 0.2s ease;
        }

        .kaleidoscope-preset-btn:hover {
            background: linear-gradient(135deg, #2a2a2a 0%, #3a3a3a 100%);
            border-color: var(--accent-color, #2969b0);
            transform: translateY(-1px);
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
        }

        .kaleidoscope-preset-btn:active {
            transform: translateY(0);
            background: linear-gradient(135deg, #0a0a0a 0%, #1a1a1a 100%);
        }

        .kaleidoscope-preset-btn.active {
            background: linear-gradient(135deg, var(--accent-color, #2969b0) 0%, #1a4a7a 100%);
            border-color: var(--accent-color, #2969b0);
        }

        .apply-container {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 12px;
            padding-bottom: 12px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }

        #kaleidoscopeBeatBtn,
        #kaleidoscopeBeatRotationBtn,
        #kaleidoscopeBeatShapeBtn {
            padding: 6px 12px;
            margin: 2px;
            background: linear-gradient(135deg, #1a1a1a 0%, #2a2a2a 100%);
            color: #ffffff;
            border: 1px solid #3a3a3a;
            border-radius: 3px;
            cursor: pointer;
            font-size: 12px;
            transition: all 0.2s ease;
            white-space: nowrap;
        }

        #kaleidoscopeBeatBtn:hover,
        #kaleidoscopeBeatRotationBtn:hover,
        #kaleidoscopeBeatShapeBtn:hover {
            background: linear-gradient(135deg, #2a2a2a 0%, #3a3a3a 100%);
            border-color: var(--accent-color, #2969b0);
            transform: translateY(-1px);
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
        }

        #kaleidoscopeBeatBtn.active,
        #kaleidoscopeBeatRotationBtn.active,
        #kaleidoscopeBeatShapeBtn.active {
            background: linear-gradient(135deg, var(--accent-color, #2969b0) 0%, #1a4a7a 100%);
            border-color: var(--accent-color, #2969b0);
        }


        .kaleidoscope-video {
            z-index: 2 !important; /* Video kaleidoscope above video but below viz */
        }

        .kaleidoscope-viz {
            z-index: 3 !important; /* Viz kaleidoscope on top */
        }

        /* Record Controls Styles */
        .record-controls {
            display: flex;
            align-items: center;
            gap: 4px;
            position: relative;
        }

        #recordBtn {
            min-width: 120px;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            transition: all 0.3s ease;
        }

        #recordBtn.recording {
            background: #ff3030 !important;
            color: white !important;
            animation: pulse-record 1.5s ease-in-out infinite;
        }

        @keyframes pulse-record {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.8; }
        }

        .record-timer {
            font-family: 'Courier New', monospace;
            font-size: 12px;
            font-weight: bold;
            letter-spacing: 0.5px;
        }

        /* Record Settings Panel */
        .record-settings-panel {
            position: absolute;
            top: calc(100% + 10px);
            left: 0;
            background: var(--secondary-bg, #1a1a1a);
            border: 1px solid var(--border-color, #898989);
            border-radius: 8px;
            padding: 16px;
            z-index: 1000;
            min-width: 320px;
            max-width: 400px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.5);
        }

        .aspect-ratio-btn, .framerate-btn {
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: var(--text-secondary);
            padding: 6px 12px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
            transition: all 0.2s ease;
            margin: 2px;
        }

        .aspect-ratio-btn:hover, .framerate-btn:hover {
            background: rgba(255, 255, 255, 0.2);
            border-color: var(--accent-color);
        }

        .aspect-ratio-btn.active, .framerate-btn.active {
            background: var(--accent-color);
            border-color: var(--accent-color);
            color: white;
        }

        .control-select {
            width: 100%;
            padding: 8px;
            background: var(--hover-color, #2a2a2a);
            border: 1px solid var(--border-color, #898989);
            border-radius: 4px;
            color: var(--text-primary);
            font-size: 12px;
        }

        .control-btn {
            background: var(--hover-color, #2a2a2a);
            border: 1px solid var(--border-color, #898989);
            color: var(--text-secondary);
            padding: 8px 12px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
            transition: all 0.2s ease;
            margin-top: 8px;
            width: 100%;
        }

        .control-btn:hover {
            background: var(--accent-color);
            color: white;
        }

        .control-input {
            flex: 1;
            padding: 8px;
            background: var(--hover-color, #2a2a2a);
            border: 1px solid var(--border-color, #898989);
            border-radius: 4px 0 0 4px;
            color: var(--text-primary);
            font-size: 12px;
        }

        .file-extension {
            padding: 8px 12px;
            background: var(--secondary-bg, #1a1a1a);
            border: 1px solid var(--border-color, #898989);
            border-left: none;
            border-radius: 0 4px 4px 0;
            color: var(--text-secondary);
            font-size: 12px;
        }

        .input-container {
            display: flex;
            align-items: center;
            margin-top: 8px;
        }

        .input-container label {
            display: block;
            margin-bottom: 4px;
            font-size: 12px;
            color: var(--text-secondary);
        }

        .file-location-display {
            background: var(--hover-color, #2a2a2a);
            border: 1px solid var(--border-color, #898989);
            border-radius: 4px;
            padding: 8px;
            font-size: 12px;
            color: var(--text-secondary);
            margin-bottom: 8px;
        }

        .recording-info {
            display: flex;
            flex-direction: column;
            gap: 6px;
            margin-top: 8px;
            font-size: 12px;
        }

        .info-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .info-label {
            color: var(--text-secondary);
            font-weight: 500;
        }

        /* Playlist Actions in Dropdown */
        .playlist-actions-dropdown {
            display: flex !important;
            gap: 6px;
            margin-bottom: 12px;
            padding: 8px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }

        /* Ensure playlist dropdown content is properly sized */
        .playlist-dropdown .dropdown-content {
            min-width: 400px;
            max-width: 500px;
            min-height: 400px;
            max-height: 600px;
            padding: 12px;
            left: 0;
            right: auto;
            transform: none;
        }

        /* Fix positioning for playlist dropdown */
        .playlist-dropdown {
            position: relative;
        }

        .playlist-dropdown .dropdown-content {
            position: absolute;
            top: 100%;
            left: 0;
            z-index: 1000;
            background: var(--secondary-bg, #1a1a1a);
            border: 1px solid var(--border-color, #898989);
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.5);
            display: none;
        }

        .playlist-dropdown .dropdown-content.show {
            display: block;
        }

        .playlist-actions {
            display: flex;
            gap: 6px;
            margin-bottom: 12px;
        }

        .playlist-scan-btn, .playlist-import-btn, .playlist-export-btn {
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: var(--text-secondary);
            padding: 6px 10px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 11px;
            transition: all 0.2s ease;
        }

        .playlist-scan-btn:hover, .playlist-import-btn:hover, .playlist-export-btn:hover {
            background: var(--accent-color);
            color: white;
            border-color: var(--accent-color);
        }

        .playlist-progress {
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 6px;
            padding: 12px;
            margin-bottom: 16px;
        }

        .progress-bar-container {
            width: 100%;
            height: 6px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 3px;
            margin-bottom: 8px;
            overflow: hidden;
        }

        .progress-bar {
            height: 100%;
            background: linear-gradient(90deg, var(--accent-color) 0%, #4CAF50 100%);
            width: 0%;
            transition: width 0.3s ease;
            border-radius: 3px;
        }

        .progress-info {
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 11px;
            color: var(--text-secondary);
            margin-bottom: 8px;
        }

        .progress-cancel-btn {
            background: #ff4444;
            border: none;
            color: white;
            padding: 4px 12px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 11px;
        }

        .playlist-stats {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 12px;
            font-size: 12px;
            color: var(--text-secondary);
            padding: 8px 12px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 4px;
        }

        .dropdown-content .playlist-stats {
            margin: 8px 0;
            display: flex !important;
        }

        .dropdown-content .playlist-tracks-container {
            display: block !important;
        }

        .dropdown-content .empty-playlist {
            display: flex !important;
        }

        /* Ensure panel header and close button are visible in playlist dropdown */
        .playlist-dropdown .panel-header {
            display: flex !important;
            justify-content: space-between !important;
            align-items: center !important;
            margin-bottom: 12px;
            padding-bottom: 8px;
            border-bottom: 1px solid var(--border-color, #898989);
        }

        .playlist-dropdown .panel-close-btn {
            display: block !important;
            background: transparent !important;
            border: none !important;
            color: var(--text-secondary) !important;
            font-size: 20px !important;
            cursor: pointer !important;
            width: 24px !important;
            height: 24px !important;
            line-height: 18px !important;
            text-align: center !important;
            transition: all 0.2s ease !important;
        }

        .playlist-dropdown .panel-close-btn:hover {
            color: var(--accent-color) !important;
            transform: scale(1.2) !important;
        }

        /* Prevent dropdown close on internal clicks */
        .playlist-dropdown .dropdown-content * {
            pointer-events: auto;
        }

        .track-selector {
            margin-bottom: 16px;
        }

        .playlist-tracks-container {
            max-height: 250px;
            overflow-y: auto;
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 6px;
            background: rgba(0, 0, 0, 0.3);
            margin-top: 8px;
        }

        .dropdown-content .playlist-tracks-container {
            max-height: 400px; /* Doubled height for better usability */
        }

        .playlist-tracks {
            padding: 8px;
        }

        .empty-playlist {
            text-align: center;
            padding: 20px;
            color: var(--text-secondary);
            min-height: 100px;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
        }

        .dropdown-content .empty-playlist {
            padding: 15px;
            min-height: 80px;
        }

        .empty-playlist-icon {
            font-size: 48px;
            margin-bottom: 12px;
            opacity: 0.5;
        }

        .empty-playlist-text {
            font-size: 16px;
            margin-bottom: 8px;
            color: var(--text-primary);
        }

        .empty-playlist-subtext {
            font-size: 12px;
            opacity: 0.7;
        }

        .artist-group {
            margin-bottom: 16px;
        }

        .artist-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px 12px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 4px;
            margin-bottom: 8px;
            cursor: pointer;
        }

        .artist-name {
            font-weight: 600;
            color: var(--text-primary);
        }

        .artist-track-count {
            font-size: 11px;
            color: var(--text-secondary);
        }

        .artist-tracks {
            padding-left: 12px;
        }

        .track-item {
            display: flex;
            align-items: center;
            padding: 8px;
            margin-bottom: 4px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.2s ease;
            border: 1px solid transparent;
        }

        .track-item:hover {
            background: rgba(255, 255, 255, 0.1);
            border-color: var(--accent-color);
        }

        .track-item.active {
            background: rgba(41, 105, 176, 0.3);
            border-color: var(--accent-color);
        }

        .track-item.dragging {
            opacity: 0.5;
            transform: scale(0.95);
        }

        .track-artwork {
            width: 40px;
            height: 40px;
            border-radius: 4px;
            margin-right: 12px;
            object-fit: cover;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .track-info {
            flex: 1;
            min-width: 0;
        }

        .track-title {
            font-size: 13px;
            font-weight: 500;
            color: var(--text-primary);
            margin-bottom: 2px;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .track-details {
            display: flex;
            gap: 8px;
            font-size: 11px;
            color: var(--text-secondary);
        }

        .track-artist, .track-album, .track-duration {
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .track-actions {
            display: flex;
            gap: 4px;
            opacity: 0;
            transition: opacity 0.2s ease;
        }

        .track-item:hover .track-actions {
            opacity: 1;
        }

        .track-play-btn, .track-remove-btn {
            background: rgba(255, 255, 255, 0.1);
            border: none;
            color: var(--text-secondary);
            width: 24px;
            height: 24px;
            border-radius: 3px;
            cursor: pointer;
            font-size: 10px;
            transition: all 0.2s ease;
        }

        .track-play-btn:hover {
            background: var(--accent-color);
            color: white;
        }

        .track-remove-btn:hover {
            background: #ff4444;
            color: white;
        }

        /* Drag and Drop Styles */
        .track-item.dragging {
            opacity: 0.5;
            transform: scale(0.95);
            z-index: 1000;
        }

        .track-item.drag-over {
            border-color: var(--accent-color);
            background: rgba(41, 105, 176, 0.2);
        }

        .track-item.drop-not-allowed {
            border-color: #ff4444;
            background: rgba(255, 68, 68, 0.1);
            cursor: not-allowed;
        }

        .artist-tracks.drag-over {
            background: rgba(41, 105, 176, 0.1);
            border: 2px dashed var(--accent-color);
            border-radius: 4px;
        }

        /* Tracks that need rescanning */
        .track-item.needs-rescan {
            opacity: 0.7;
            background: rgba(255, 165, 0, 0.1);
            border-color: rgba(255, 165, 0, 0.3);
        }

        .track-item.needs-rescan .track-play-btn {
            background: rgba(255, 165, 0, 0.2);
            cursor: not-allowed;
        }

        .track-item.needs-rescan .track-play-btn:disabled {
            opacity: 0.5;
        }

        /* Rescan notification */
        .rescan-notification {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 12px;
            margin-bottom: 12px;
            background: rgba(255, 165, 0, 0.1);
            border: 1px solid rgba(255, 165, 0, 0.3);
            border-radius: 6px;
            color: var(--text-primary);
        }

        .notification-icon {
            font-size: 20px;
        }

        .notification-text strong {
            color: var(--text-primary);
        }

        .notification-text small {
            color: var(--text-secondary);
        }

        /* Background scan indicator */
        .background-scan-indicator {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-top: 8px;
            padding: 6px 12px;
            background: rgba(76, 175, 80, 0.1);
            border: 1px solid rgba(76, 175, 80, 0.3);
            border-radius: 4px;
            font-size: 11px;
            color: var(--text-primary);
        }

        .scan-icon {
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            from { transform: rotate(0deg); }
            to { transform: rotate(360deg); }
        }

        /* Tabbed Header Interface - Phase 1 Foundation (Hidden) */
        .tab-header {
            display: flex; /* Activated in Phase 4 */
            height: 100px;
            background: var(--secondary-bg, #1a1a1a);
            border-bottom: 2px solid var(--border-color, #898989);
            padding: 0 20px;
            align-items: center;
            justify-content: space-between;
        }

        .app-icon {
            width: 60px;
            height: 60px;
            border-radius: 8px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            flex-shrink: 0;
        }

        .tab-group {
            display: flex;
            align-items: center;
            gap: 8px;
            justify-content: center;
            flex: 1;
            /* Removed grey background */
        }

        .tab-spacer {
            width: 60px;
            flex-shrink: 0;
        }

        .tab-item {
            padding: 12px 24px;
            background: transparent;
            border: none;
            color: var(--text-secondary);
            font-size: 14px;
            font-weight: 700;
            cursor: pointer;
            border-radius: 6px;
            transition: all 0.2s ease;
            white-space: nowrap;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .tab-item:hover {
            background: rgba(255, 255, 255, 0.15);
            color: var(--text-primary);
            transform: translateY(-1px);
        }

        .tab-item.active {
            background: var(--accent-color);
            color: white;
            box-shadow: 0 2px 8px rgba(41, 105, 176, 0.4);
            transform: translateY(-2px);
        }

        .section-panel {
            display: none; /* Hidden until opened */
            position: absolute;
            top: 100px;
            width: auto;
            min-width: 320px;
            max-width: 85vw;
            background: var(--secondary-bg, #1a1a1a);
            border: 1px solid var(--border-color, #898989);
            border-radius: 0 0 12px 12px;
            box-shadow: 0 6px 25px rgba(0, 0, 0, 0.6);
            z-index: 2000;
            padding: 24px 32px 28px 32px;
            max-height: calc(100vh - 180px);
            overflow: visible; /* Allow dropdowns to extend outside panel */
        }

        .section-panel.show {
            display: block;
        }

        .panel-content {
            display: flex;
            flex-direction: column;
            gap: 12px;
        }

        .panel-row {
            display: flex;
            flex-direction: column;
            gap: 6px;
        }

        /* Better spacing for different panel types */
        .section-panel .input-mode-container {
            margin-bottom: 8px;
        }

        .section-panel .dropdown {
            margin-bottom: 8px;
        }

        .section-panel .morph-controls {
            margin-bottom: 8px;
        }

        .section-panel .record-controls {
            margin-bottom: 8px;
        }

        /* Secondary Control Positioning */
        .secondary-control {
            position: absolute;
            z-index: 3000;
            background: var(--secondary-bg, #1a1a1a);
            border: 1px solid var(--border-color, #898989);
            border-radius: 4px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.3);
        }

        /* Fix dropdown clipping in tab panels */
        .section-panel .dropdown-content {
            z-index: 3500 !important;
            position: absolute !important;
        }

        .section-panel .playlist-dropdown .dropdown-content {
            z-index: 4000 !important;
            position: absolute !important;
            max-height: 400px !important;
            overflow-y: auto !important;
            top: 100% !important;
            left: 0 !important;
        }

        /* Ensure playlist dropdown content is visible */
        .section-panel .playlist-dropdown .dropdown-content.show {
            display: block !important;
        }

        /* Global Button Size Reduction - 10% smaller */
        .tab-interface-active button:not(.tab-item):not(.app-icon) {
            transform: scale(0.9);
            transform-origin: center;
        }

        .tab-interface-active .dropdown-toggle,
        .tab-interface-active .input-mode-btn,
        .tab-interface-active .preset-btn {
            font-size: 12px;
            padding: 8px 14px;
            line-height: 1.2;
        }

        .tab-interface-active .effect-toggle-btn {
            font-size: 11px;
            padding: 6px 10px;
        }

        .tab-interface-active .video-settings-toggle {
            width: 28px;
            height: 28px;
            font-size: 12px;
        }

        /* Transport button size reduction - 10% smaller */
        .tab-interface-active .footer .control-btn {
            width: 36px;
            height: 36px;
        }

        /* Better alignment and spacing in panels */
        .section-panel .button-container {
            display: flex;
            gap: 8px;
            align-items: center;
            flex-wrap: wrap;
        }

        .section-panel .preset-buttons {
            display: flex;
            gap: 6px;
            flex-wrap: wrap;
            align-items: center;
        }

        .section-panel .slider-container {
            display: flex;
            align-items: center;
            gap: 12px;
            margin-bottom: 8px;
        }

        .section-panel .slider-container label {
            min-width: 80px;
            font-size: 12px;
            color: var(--text-secondary);
        }

        /* Enhanced visual hierarchy for panel elements */
        .section-panel .dropdown-label {
            font-weight: 600;
            color: var(--text-primary);
            margin-bottom: 4px;
        }

        .section-panel .dropdown-toggle:hover {
            background: rgba(255, 255, 255, 0.15);
            border-color: var(--accent-color);
            transform: translateY(-1px);
        }

        .section-panel .dropdown-toggle.active {
            background: rgba(41, 105, 176, 0.2);
            border-color: var(--accent-color);
            color: var(--text-primary);
        }

        .section-panel .input-mode-btn:hover {
            background: rgba(255, 255, 255, 0.15);
            border-color: var(--accent-color);
            transform: translateY(-1px);
        }

        .section-panel .input-mode-btn.live-mode {
            background: #4CAF50;
            color: white;
            box-shadow: 0 2px 6px rgba(76, 175, 80, 0.3);
        }

        /* Better visual separation for panel sections */
        .panel-row {
            background: rgba(255, 255, 255, 0.02);
            border-radius: 6px;
            padding: 12px;
            border: 1px solid rgba(255, 255, 255, 0.05);
        }

        .panel-row:hover {
            background: rgba(255, 255, 255, 0.04);
            border-color: rgba(255, 255, 255, 0.1);
        }

        /* Display Settings Panel Styles */
        .display-settings-panel {
            position: absolute;
            top: calc(100% + 10px);
            left: 50%;
            transform: translateX(-50%);
            background: var(--secondary-bg, #1a1a1a);
            border: 1px solid var(--border-color, #898989);
            border-radius: 8px;
            padding: 12px;
            z-index: 5000;
            min-width: 320px;
            max-width: 400px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.5);
        }

        .display-mode-btn,
        .aspect-ratio-btn,
        .display-preset-btn {
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: var(--text-secondary);
            padding: 6px 12px;
            border-radius: 12px;
            cursor: pointer;
            font-size: 11px;
            transition: all 0.2s ease;
            margin: 2px;
        }

        .display-mode-btn:hover,
        .aspect-ratio-btn:hover,
        .display-preset-btn:hover {
            background: rgba(255, 255, 255, 0.2);
        }

        .display-mode-btn.active,
        .aspect-ratio-btn.active {
            background: var(--accent-color);
            color: white;
        }

        /* Camera Stats Styles */
        .stats-container {
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            padding: 12px;
            font-size: 11px;
        }

        .stats-row {
            display: flex;
            justify-content: space-between;
            margin-bottom: 6px;
            align-items: center;
        }

        .stats-row:last-child {
            margin-bottom: 0;
        }

        .stats-label {
            color: var(--text-secondary);
            font-weight: 500;
        }

        .stats-value {
            color: var(--accent-color);
            font-weight: 600;
            font-family: 'Courier New', monospace;
        }

        .stats-placeholder {
            color: var(--text-secondary);
            font-style: italic;
            text-align: center;
            opacity: 0.7;
        }


        /* Display Settings Button */
        .display-settings-btn {
            background: var(--hover-color);
            border: 1px solid var(--border-color, #898989);
            color: var(--text-secondary);
            width: 32px;
            height: 32px;
            border-radius: 50%;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 16px;
            margin-left: 4px;
            display: inline-flex;
            align-items: center;
            justify-content: center;
        }

        .display-settings-btn:hover {
            background: var(--accent-color);
            color: var(--primary-bg, #f5f3e9);
            transform: rotate(90deg) scale(1.1);
        }

        @media(max-width: 768px) {
            .info-button {
                top: 8px;
                right: 8px;
                width: 24px;
                height: 24px;
                font-size: 12px;
            }

            .header-left {
                flex-direction: column;
                gap: 10px;
                align-items: flex-start;
            }

            .header-content {
                flex-direction: column;
                gap: 10px;
                padding-right: 40px;
            }

            .controls {
                flex-direction: column;
                gap: 16px;
            }

            .presets-container {
                width: 100%;
                justify-content: center;
            }

            .preset-selector {
                flex: 1;
                max-width: 200px;
            }

            .track-info {
                order: -1;
                max-width: none;
                width: 100%;
            }

            .main-area {
                flex-direction: column;
            }

            .footer {
                order: -1;
            }

            .playlist-dropdown {
                position: static;
                transform: none;
                margin-top: 10px;
            }
        }

        @media(max-width: 480px) {
            .header {
                padding: 8px 12px;
            }

            .footer {
                padding: 8px 12px;
            }

            .viz-btn {
                font-size: 10px;
                padding: 6px 12px;
            }

            .control-btn,
            .fullscreen-btn,
            .loop-btn,
            .transparent-btn {
                width: 40px;
                height: 40px;
                font-size: 12px;
            }

            .color-btn {
                font-size: 10px;
                padding: 4px 8px;
            }

            .logo h1 {
                font-size: 18px;
            }

            .logo img {
                width: 30px;
                height: 30px;
            }
        }
    </style>
</header>
<div class="app-container">

    <main class="main-area">
        <div class="visualization-container" id="visualizationContainer">
            <div id="visualizer"></div>

            <div class="loading" id="loading" style="display: none;">
                <div>Loading audio visualizer...</div>
            </div>

            <div class="error-message" id="error" style="display: none;">
                <div id="error-text">Error initializing visualizer</div>
            </div>
        </div>
    </main>
</div>


<!-- Info Popup -->
<div class="popup-overlay" id="popupOverlay"></div>
<div class="info-popup" id="infoPopup">
    <h3>GitItUp Music Visualizer</h3>
    <p>Created by Stel Furet</p>
    <p>Try selecting the Mirror Wave then Radial Spectrum for a cool effect!</p>
    <button onclick="closeInfoPopup()">Close</button>
</div>

<!-- Fullscreen Controls (comprehensive) -->
<div
    class="fullscreen-controls" id="fullscreenControls">
    <!-- Playback Controls -->
    <div class="fs-section fs-playback">
        <button class="fs-control-btn" id="fsPrevBtn" title="Previous">⏮</button>
        <button class="fs-control-btn" id="fsPlayBtn" title="Play/Pause">▶</button>
        <button class="fs-control-btn" id="fsNextBtn" title="Next">⏭</button>
        <button class="fs-control-btn" id="fsLoopBtn" title="Loop">
            <svg viewbox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                <path d="M17 17H7V14L3 18L7 22V19H19V13H17M7 7H17V10L21 6L17 2V5H5V11H7V7Z"/>
            </svg>
            <span class="fs-loop-indicator" id="fsLoopIndicator" style="display: none;">1</span>
        </button>
    </div>

    <!-- Track Info & Progress -->
    <div class="fs-section fs-track-info">
        <div class="fs-track-title" id="fsTrackTitle">Select a track to start</div>
        <div class="fs-progress-container">
            <div class="fs-progress-bar" id="fsProgressBar">
                <div class="fs-progress-fill" id="fsProgressFill"></div>
            </div>
            <div class="fs-time-display" id="fsTimeDisplay">0:00 / 0:00</div>
        </div>
    </div>

    <!-- Volume -->
    <div class="fs-section fs-volume">
        <span>🔊</span>
        <div class="fs-volume-slider" id="fsVolumeSlider">
            <div class="fs-volume-fill" id="fsVolumeFill"></div>
        </div>
    </div>

    <!-- Dropdowns -->
    <div
        class="fs-section fs-dropdowns">
        <!-- Playlist -->
        <select class="fs-select" id="fsPlaylistSelect">
            <option value="">Select Track...</option>
        </select>

        <!-- Color Scheme -->
        <select class="fs-select" id="fsColorSelect">
            <option value="default">Default</option>
            <option value="earthtones">Earthtones</option>
            <option value="luigi">Luigi</option>
            <option value="metal">Heavy Metal</option>
            <option value="psychedelic">Psychedelic</option>
        </select>

        <!-- Visualization -->
        <select class="fs-select" id="fsVizSelect">
            <option value="0">Spectrum</option>
            <option value="1">Mirror Wave</option>
            <option value="2">Classic LED</option>
            <option value="3">Stereo</option>
            <option value="4">Radial Spectrum</option>
            <option value="5">Energy</option>
            <option value="6">Mirror</option>
        </select>

        <!-- Presets -->
        <select class="fs-select" id="fsPresetSelect">
            <option value="">Load Preset...</option>
        </select>
    </div>

    <!-- Additional Controls -->
    <div
        class="fs-section fs-extra">
        <!-- <button class="fs-control-btn" id="fsBgColorBtn" title="Background Color">
                            <div class="fs-eyedropper-icon"></div>
                        </button>
                        <input type="color" class="fs-color-picker" id="fsBgColorPicker" value="#000000">-->

        <button id="fsMorphBtn" class="morph-btn">
            <span class="morph-btn-text">Morph</span>
        </button>
        <select class="fs-select fs-morph-speed" id="fsMorphSpeed">
            <option value="slow">Slow</option>
            <option value="medium" selected="selected">Medium</option>
            <option value="fast">Fast</option>
            <option value="ultra">Ultra</option>
            <option value="energy">Energy</option>
        </select>

        <button class="fs-random-btn" id="fsRandomBtn">Random</button>
    </div>
</div>

<!-- Fullscreen Exit Button -->
<div class="fullscreen-exit-btn" id="fullscreenExitBtn">
    <svg viewbox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
        <path d="M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"/>
    </svg>
</div>

<footer class="footer">
    <div class="controls">
        <div class="playback-controls">
            <button class="control-btn" id="prevBtn" title="Previous track">⏮</button>
            <button class="control-btn" id="playBtn" title="Play/Pause">▶</button>
            <button class="control-btn" id="nextBtn" title="Next track">⏭</button>
            <button class="loop-btn" id="loopBtn" title="Toggle Loop (Off)">
                <svg viewbox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <path d="M17 17H7V14L3 18L7 22V19H19V13H17M7 7H17V10L21 6L17 2V5H5V11H7V7Z"/>
                </svg>
                <span class="loop-indicator" id="loopIndicator" style="display: none;">1</span>
            </button>
        </div>

        <div class="track-info">
            <div class="track-title" id="trackTitle">Select a track to start</div>
            <div class="progress-container">
                <div class="progress-bar" id="progressBar">
                    <div class="progress-fill" id="progressFill"></div>
                </div>
                <div class="time-display" id="timeDisplay">0:00 / 0:00</div>
            </div>
        </div>

        <div class="volume-control">
            <span title="Volume">🔊</span>
            <div class="volume-slider" id="volumeSlider">
                <div class="volume-fill" id="volumeFill"></div>
            </div>
        </div>

        <div class="color-picker-wrapper">
            <button class="transparent-btn" id="bgColorBtn" title="Set Background Color">
                <div class="eyedropper-icon"></div>
            </button>
            <input type="color" class="color-picker-input" id="bgColorPicker" value="#000000">
        </div>
        <button class="fullscreen-btn" id="fullscreenBtn" title="Toggle Fullscreen">⛶</button>
    </div>
</footer>
<script>
    // Enhanced Audio Spectrum Analyzer with Fixed channelLayout Support
    class SpectrumAnalyzer {
        constructor(container, options = {}) {
            this.container = container;
            this.canvas = document.createElement('canvas');
            this.ctx = this.canvas.getContext('2d');
            this.audioCtx = null;
            this.analyser = null;
            this.analyserRight = null; // For stereo/dual channel
            this.dataArray = null;
            this.dataArrayRight = null; // For stereo/dual channel
            this.source = null;
            this.splitter = null; // For channel splitting
            this.isConnected = false;
            this.connectedElement = null;
            this.currentColorScheme = 'default';
            this.backgroundColor = '#000000';

            // Initialize all parameters with defaults
            this.resetToDefaults();

            // Apply provided options
            if (options) {
                this.setOptions(options);
            }

            // Setup
            this.setupCanvas();
            this.setupAudio();
            this.initializePeaks();
            this.calculateFrequencyBands();
            this.animate();

            // Live Audio
            this.inputMode = 'playlist'; // 'playlist' or 'microphone'
            this.audioStream = null;
            this.streamSource = null;
            this.availableDevices = [];

            // Handle resize
            window.addEventListener('resize', () => this.handleResize());

            console.log('Enhanced SpectrumAnalyzer created with channelLayout support');
        }

        resetToDefaults() { // Full AudioMotion parameter set with single quotes for strings
            this.alphaBars = false;
            this.ansiBands = false;
            this.barSpace = 0.1;
            this.bgAlpha = 0.7;
            this.channelLayout = 'single';
            this.colorMode = 'gradient';
            this.fadePeaks = false;
            this.fftSize = 8192;
            this.fillAlpha = 1;
            this.frequencyScale = 'log';
            this.gradient = 'classic';
            this.gravity = 3.8;
            this.ledBars = false;
            this.linearAmplitude = false;
            this.linearBoost = 1;
            this.lineWidth = 0;
            this.loRes = false;
            this.lumiBars = false;
            this.maxDecibels = -25;
            this.maxFPS = 0;
            this.maxFreq = 22000;
            this.minDecibels = -85;
            this.minFreq = 20;
            this.mirror = 0;
            this.mode = 0;
            this.noteLabels = false;
            this.outlineBars = false;
            this.overlay = false;
            this.peakFadeTime = 750;
            this.peakHoldTime = 500;
            this.peakLine = false;
            this.radial = false;
            this.radialInvert = false;
            this.radius = 0.3;
            this.reflexAlpha = 1;
            this.reflexBright = 1;
            this.reflexFit = true;
            this.reflexRatio = 0;
            this.roundBars = false;
            this.showBgColor = false;
            this.showFPS = false;
            this.showPeaks = true;
            this.showScaleX = false;
            this.showScaleY = false;
            this.smoothing = 0.5;
            this.spinSpeed = 0;
            this.splitGradient = false;
            this.trueLeds = false;
            this.useCanvas = true;
            this.volume = 1;
            this.weightingFilter = '';

            // Additional properties for stereo
            this.gradientLeft = 'steelblue';
            this.gradientRight = 'orangered';

            // Peak tracking
            this.peaks = [];
            this.peaksRight = [];
            this.peakDecay = [];
            this.peakDecayRight = [];
            this.lastPeakTime = [];
            this.lastPeakTimeRight = [];

            // Animation
            this.spinAngle = 0;
            this.animationFrame = null;

            // Frequency bands
            this.frequencyBands = [];
        }

        setColorScheme(scheme) {
            this.currentColorScheme = scheme;
        }

        setBackgroundColor(color) {
            this.backgroundColor = color;
            const visualizationContainer = document.getElementById('visualizationContainer');
            const mainArea = document.querySelector('.main-area');

            // Update backdrop if video is active
            const backdrop = document.getElementById('videoBackdrop');
            if (backdrop) {
                backdrop.style.background = color;
            }

            // Only apply to containers if video is NOT active
            if (!this.videoMode || this.videoMode === 'off') {
                visualizationContainer.style.backgroundColor = color;
                mainArea.style.backgroundColor = color;
            }

            // Save to localStorage using existing method
            try {
                localStorage.setItem('gitup_bgcolor', this.backgroundColor);
            } catch (e) {
                console.error('Error saving background color:', e);
            }

            if (this.audioMotion && (!this.videoMode || this.videoMode === 'off')) {
                this.audioMotion.setBackgroundColor(color);
            }
        }

        setupCanvas() {
            const rect = this.container.getBoundingClientRect();
            this.canvas.width = rect.width || 800;
            this.canvas.height = rect.height || 400;
            this.canvas.style.width = '100%';
            this.canvas.style.height = '100%';
            this.canvas.style.position = 'absolute';
            this.canvas.style.top = '0';
            this.canvas.style.left = '0';
            this.canvas.style.background = 'transparent';
            this.container.appendChild(this.canvas);
        }

        setupAudio() {
            try {
                this.audioCtx = new(window.AudioContext || window.webkitAudioContext)();

                // Main analyser (left channel or mono)
                this.analyser = this.audioCtx.createAnalyser();
                this.analyser.fftSize = this.fftSize;
                this.analyser.smoothingTimeConstant = this.smoothing;
                this.analyser.minDecibels = this.minDecibels;
                this.analyser.maxDecibels = this.maxDecibels;
                this.dataArray = new Uint8Array(this.analyser.frequencyBinCount);

                // Right channel analyser for stereo modes
                this.analyserRight = this.audioCtx.createAnalyser();
                this.analyserRight.fftSize = this.fftSize;
                this.analyserRight.smoothingTimeConstant = this.smoothing;
                this.analyserRight.minDecibels = this.minDecibels;
                this.analyserRight.maxDecibels = this.maxDecibels;
                this.dataArrayRight = new Uint8Array(this.analyserRight.frequencyBinCount);

                // Channel splitter for stereo
                this.splitter = this.audioCtx.createChannelSplitter(2);

                console.log('Audio context initialized with stereo support:', {
                    sampleRate: this.audioCtx.sampleRate,
                    fftSize: this.analyser.fftSize,
                    frequencyBinCount: this.analyser.frequencyBinCount
                });
            } catch (error) {
                console.error('Audio context setup failed:', error);
                this.dataArray = new Uint8Array(128);
                this.dataArrayRight = new Uint8Array(128);
            }
        }

        calculateFrequencyBands() {
            if (!this.analyser) {
                this.frequencyBands = [];
                return;
            }

            const nyquist = this.audioCtx ?. sampleRate / 2 || 22050;
            const binCount = this.analyser.frequencyBinCount;
            const binWidth = nyquist / binCount;

            this.frequencyBands = [];

            if (this.frequencyScale === 'log') {
                const minLog = Math.log10(Math.max(this.minFreq, 20));
                const maxLog = Math.log10(Math.min(this.maxFreq, nyquist));
                // Use all available bins for mode 0 to get smooth fluid appearance
                const bandCount = this.ansiBands ? 31 : (this.mode === 0 ? Math.min(binCount, 512) : 64);

                for (let i = 0; i < bandCount; i++) {
                    const logFreq = minLog + (maxLog - minLog) * (i / bandCount);
                    const freq = Math.pow(10, logFreq);
                    const bin = Math.floor(freq / binWidth);
                    this.frequencyBands.push({
                        freq: freq,
                        bin: Math.min(bin, binCount - 1),
                        width: 1 / bandCount
                    });
                }
            } else if (this.frequencyScale === 'bark') {
                const bandCount = 24;
                for (let i = 0; i < bandCount; i++) {
                    const bark = i + 0.5;
                    const freq = 600 * Math.sinh(bark / 4);
                    if (freq < this.minFreq || freq > this.maxFreq) 
                        continue;
                    

                    const bin = Math.floor(freq / binWidth);
                    this.frequencyBands.push({
                        freq: freq,
                        bin: Math.min(bin, binCount - 1),
                        width: 1 / bandCount
                    });
                }
            } else {
                const bandCount = this.mode === 0 ? Math.min(binCount, 256) : 64;
                for (let i = 0; i < bandCount; i++) {
                    const freq = (i / bandCount) * nyquist;
                    if (freq < this.minFreq || freq > this.maxFreq) 
                        continue;
                    

                    this.frequencyBands.push({
                        freq: freq,
                        bin: Math.min(i, binCount - 1),
                        width: 1 / bandCount
                    });
                }
            }

            if (this.frequencyBands.length === 0) {
                const fallbackCount = 64;
                for (let i = 0; i < fallbackCount; i++) {
                    this.frequencyBands.push({
                        freq: (i / fallbackCount) * nyquist,
                        bin: Math.floor(
                            (i / fallbackCount) * binCount
                        ),
                        width: 1 / fallbackCount
                    });
                }
            }
        }

        initializePeaks() {
            const length = (this.frequencyBands && this.frequencyBands.length > 0) ? this.frequencyBands.length : 64;
            this.peaks = new Array(length).fill(0);
            this.peaksRight = new Array(length).fill(0);
            this.peakDecay = new Array(length).fill(0);
            this.peakDecayRight = new Array(length).fill(0);
            this.lastPeakTime = new Array(length).fill(0);
            this.lastPeakTimeRight = new Array(length).fill(0);
        }

        connectInput(audioElement) {
            if (!this.audioCtx || !audioElement) 
                return;
            


            try { // Always disconnect previous source
                if (this.source) {
                    try {
                        this.source.disconnect();
                    } catch (e) { // Ignore disconnect errors
                    }
                    this.source = null;
                    this.isConnected = false;
                }

                if (this.audioCtx.state === 'suspended') {
                    this.audioCtx.resume();
                }

                // Create new source if needed
                if (!audioElement._audioSourceNode) {
                    this.source = this.audioCtx.createMediaElementSource(audioElement);
                    audioElement._audioSourceNode = this.source;
                } else {
                    this.source = audioElement._audioSourceNode;
                }

                // Connect based on channel layout
                if (this.channelLayout === 'dual-vertical' || this.channelLayout === 'dual-horizontal') { // Stereo mode: split channels
                    this.source.connect(this.splitter);
                    this.splitter.connect(this.analyser, 0); // Left channel
                    this.splitter.connect(this.analyserRight, 1); // Right channel
                    this.source.connect(this.audioCtx.destination);
                } else { // Mono mode
                    this.source.connect(this.analyser);
                    this.source.connect(this.audioCtx.destination);
                }

                this.connectedElement = audioElement;
                this.isConnected = true;
                console.log('Audio connected successfully with channelLayout:', this.channelLayout);
            } catch (error) {
                console.error('Failed to connect audio:', error);
                this.isConnected = false;
            }
        }

        disconnectInput() {
            if (this.source) {
                try {
                    this.source.disconnect();
                } catch (error) { // Ignore disconnect errors
                }
                this.source = null;
            }
            this.isConnected = false;
            this.connectedElement = null;
        }

        setOptions(options) { // Save critical animation state before any reset
            const savedSpinAngle = this.spinAngle;
            const savedFrequencyBands = this.frequencyBands;
            const wasConnected = this.isConnected;
            const savedConnectedElement = this.connectedElement;

            // Check if this is a morph update
            const isMorphing = options._isMorphing || false;

            // Only reset to defaults if NOT morphing
            if (! isMorphing) { // First, reset all parameters to their defaults
                this.resetToDefaults();
            }

            // Then apply the new options
            Object.keys(options).forEach(key => {
                if (key !== '_isMorphing' && this.hasOwnProperty(key)) {
                    this[key] = options[key];
                }
            });

            // Restore animation state during morphing
            if (isMorphing) {
                this.spinAngle = savedSpinAngle;
                // Don't reset frequency bands during morph to prevent recalculation
                if (savedFrequencyBands && savedFrequencyBands.length > 0) {
                    this.frequencyBands = savedFrequencyBands;
                }
            }

            // Restore connection state
            this.isConnected = wasConnected;
            this.connectedElement = savedConnectedElement;

            // Always force showScaleX to false
            this.showScaleX = false;

            // Update audio settings if needed
            if (options.fftSize && this.analyser) {
                this.analyser.fftSize = this.fftSize;
                this.analyserRight.fftSize = this.fftSize;
                this.dataArray = new Uint8Array(this.analyser.frequencyBinCount);
                this.dataArrayRight = new Uint8Array(this.analyserRight.frequencyBinCount);
            }

            if (options.smoothing !== undefined && this.analyser) {
                this.analyser.smoothingTimeConstant = this.smoothing;
                this.analyserRight.smoothingTimeConstant = this.smoothing;
            }

            if (options.minDecibels !== undefined && this.analyser) {
                this.analyser.minDecibels = this.minDecibels;
                this.analyserRight.minDecibels = this.minDecibels;
            }

            if (options.maxDecibels !== undefined && this.analyser) {
                this.analyser.maxDecibels = this.maxDecibels;
                this.analyserRight.maxDecibels = this.maxDecibels;
            }

            // Recalculate frequency bands if needed (but not during morphing)
            if (! isMorphing && (options.frequencyScale || options.minFreq || options.maxFreq || options.ansiBands !== undefined || options.mode !== undefined)) {
                this.calculateFrequencyBands();
                this.initializePeaks();
            }

            // Reset spin angle when changing modes (but not during morphing)
            if (! isMorphing && options.mode !== undefined) {
                this.spinAngle = 0;
            }

            // Reconnect audio if channel layout changed
            if (options.channelLayout && this.connectedElement) {
                this.connectInput(this.connectedElement);
            }
        }

        handleResize() {
            const rect = this.container.getBoundingClientRect();
            this.canvas.width = rect.width || 800;
            this.canvas.height = rect.height || 400;
        }
        
        generateBasicAudioFeatures() {
            if (!this.analyser || !this.dataArray) {
                console.log('🔍 No analyser or dataArray available - analyser:', !!this.analyser, 'dataArray:', !!this.dataArray);
                return {
                    energy: 0,
                    beat: false,
                    tempo: 0,
                    dominantFrequency: 0
                };
            }
            
            // Get fresh audio data
            this.analyser.getByteFrequencyData(this.dataArray);
            
            // Calculate basic energy from frequency data
            let sum = 0;
            for (let i = 0; i < this.dataArray.length; i++) {
                sum += this.dataArray[i];
            }
            const energy = sum / (this.dataArray.length * 255);
            
            // Debug: check if we're getting real audio data
            const maxDataValue = Math.max(...this.dataArray);
            console.log('🔍 Audio data - Energy:', energy.toFixed(3), 'Max value:', maxDataValue, 'DataArray length:', this.dataArray.length);
            
            // Simple beat detection based on energy spikes (more sensitive)
            const now = Date.now();
            const timeSinceLastBeat = now - (this.lastBeatTime || 0);
            const beatThreshold = 0.1; // Lowered from 0.3 to 0.1 for more sensitivity
            const beatInterval = 300; // Reduced from 500ms to 300ms for more frequent beats
            
            let beat = false;
            if (energy > beatThreshold && timeSinceLastBeat > beatInterval) {
                beat = true;
                this.lastBeatTime = now;
            }
            
            // Calculate dominant frequency
            let maxValue = 0;
            let dominantBin = 0;
            for (let i = 0; i < this.dataArray.length; i++) {
                if (this.dataArray[i] > maxValue) {
                    maxValue = this.dataArray[i];
                    dominantBin = i;
                }
            }
            const dominantFrequency = (dominantBin / this.dataArray.length) * 22050; // Assuming 44.1kHz sample rate
            
            const features = {
                energy: Math.min(energy, 1),
                beat: beat,
                tempo: 120, // Default tempo
                dominantFrequency: dominantFrequency
            };
            
            console.log('🔍 Generated audio features - Energy:', energy.toFixed(3), 'Beat:', beat, 'DataArray length:', this.dataArray.length);
            
            return features;
        }

        animate() { // Check if visualization is enabled through parent visualizer
            if (window.visualizer && !window.visualizer.visualizationEnabled) {
                // Still update Infinite Zoom even when main visualization is off
                if (window.visualizer.infiniteZoom && window.visualizer.infiniteZoom.isActive) {
                    let audioFeatures = null;
                    
                    // Try to get audio features from AI Autopilot first
                    if (window.visualizer.aiAutopilot && window.visualizer.aiAutopilot.audioAnalyzer) {
                        audioFeatures = window.visualizer.aiAutopilot.audioAnalyzer.getCurrentFeatures();
                    }
                    
                    // Fallback: generate basic audio features from main audio analyzer
                    if (!audioFeatures && this.analyser && this.dataArray) {
                        audioFeatures = this.generateBasicAudioFeatures();
                        console.log('🔍 Generated basic audio features (disabled viz):', audioFeatures);
                    } else if (!audioFeatures) {
                        console.log('🔍 No audio data available (disabled viz) - analyser:', !!this.analyser, 'dataArray:', !!this.dataArray);
                    } else if (audioFeatures && audioFeatures.energy === 0) {
                        // Try to generate basic audio features if AI features have no energy
                        console.log('🔍 AI features have no energy (disabled viz), trying basic audio features...');
                        const basicFeatures = this.generateBasicAudioFeatures();
                        if (basicFeatures.energy > 0) {
                            audioFeatures = basicFeatures;
                            console.log('🔍 Using basic audio features instead (disabled viz):', audioFeatures);
                        }
                    }
                    
                    window.visualizer.infiniteZoom.update(audioFeatures);
                    window.visualizer.infiniteZoom.draw();
                }
                this.animationFrame = requestAnimationFrame(() => this.animate());
                return; // Skip main drawing but keep loop running for quick resume
            }

            this.getAudioData();
            this.updatePeaks();
            
            // Update and draw Infinite Zoom if active and not captured via kaleidoscope
            if (window.visualizer && window.visualizer.infiniteZoom && window.visualizer.infiniteZoom.isActive) {
                // Check if Infinite Zoom is being captured via kaleidoscope
                const isCapturedViaKaleidoscope = window.visualizer.kaleidoscopeEnabled && 
                                                window.visualizer.kaleidoscopeApplyToViz && 
                                                window.visualizer.kaleidoscopeApplyToInfiniteZoom;
                
                let audioFeatures = null;
                
                // Try to get audio features from AI Autopilot first
                if (window.visualizer.aiAutopilot && window.visualizer.aiAutopilot.audioAnalyzer) {
                    audioFeatures = window.visualizer.aiAutopilot.audioAnalyzer.getCurrentFeatures();
                }
                
                // Fallback: generate basic audio features from main audio analyzer
                if (!audioFeatures && this.analyser && this.dataArray) {
                    audioFeatures = this.generateBasicAudioFeatures();
                    if (!isCapturedViaKaleidoscope) {
                        console.log('🔍 Generated basic audio features:', audioFeatures);
                    }
                } else if (!audioFeatures) {
                    if (!isCapturedViaKaleidoscope) {
                        console.log('🔍 No audio data available - analyser:', !!this.analyser, 'dataArray:', !!this.dataArray);
                    }
                } else if (audioFeatures && audioFeatures.energy === 0) {
                    // Try to generate basic audio features if AI features have no energy
                    if (!isCapturedViaKaleidoscope) {
                        console.log('🔍 AI features have no energy, trying basic audio features...');
                    }
                    const basicFeatures = this.generateBasicAudioFeatures();
                    if (basicFeatures.energy > 0) {
                        audioFeatures = basicFeatures;
                        if (!isCapturedViaKaleidoscope) {
                            console.log('🔍 Using basic audio features instead:', audioFeatures);
                        }
                    }
                }
                
                // Always update Infinite Zoom (needed for kaleidoscope to capture)
                window.visualizer.infiniteZoom.update(audioFeatures);
                
                // Always draw Infinite Zoom (needed for kaleidoscope to capture)
                window.visualizer.infiniteZoom.draw();
                
                // Hide/show canvas based on whether it's being captured via kaleidoscope
                if (isCapturedViaKaleidoscope) {
                    window.visualizer.infiniteZoom.canvas.style.display = 'none';
                } else {
                    window.visualizer.infiniteZoom.canvas.style.display = 'block';
                }
            }
            
            this.draw();
            this.animationFrame = requestAnimationFrame(() => this.animate());
        }

        getAudioData() {
            if (this.analyser && this.dataArray && this.isConnected) { // Get data for main channel
                if (this.mode === 10) {
                    this.analyser.getByteTimeDomainData(this.dataArray);
                } else {
                    this.analyser.getByteFrequencyData(this.dataArray);
                }

                // Get data for right channel if in stereo mode
                if ((this.channelLayout === 'dual-vertical' || this.channelLayout === 'dual-horizontal') && this.analyserRight) {
                    if (this.mode === 10) {
                        this.analyserRight.getByteTimeDomainData(this.dataArrayRight);
                    } else {
                        this.analyserRight.getByteFrequencyData(this.dataArrayRight);
                    }
                }

                // Apply volume adjustment
                if (this.volume !== 1 && this.mode !== 10) {
                    for (let i = 0; i < this.dataArray.length; i++) {
                        this.dataArray[i] = Math.min(255, this.dataArray[i] * this.volume);
                    }
                    if (this.dataArrayRight) {
                        for (let i = 0; i < this.dataArrayRight.length; i++) {
                            this.dataArrayRight[i] = Math.min(255, this.dataArrayRight[i] * this.volume);
                        }
                    }
                }
            } else { // Demo data when not connected
                if (!this.dataArray) 
                    this.dataArray = new Uint8Array(128);
                

                if (!this.dataArrayRight) 
                    this.dataArrayRight = new Uint8Array(128);
                


                const time = Date.now() * 0.001;
                if (this.mode === 10) { // Demo waveform
                    for (let i = 0; i < this.dataArray.length; i++) {
                        const t = i / this.dataArray.length;
                        this.dataArray[i] = 128 + 64 * Math.sin(time * 3 + t * Math.PI * 4) * Math.sin(time * 0.7);
                        this.dataArrayRight[i] = 128 + 64 * Math.sin(time * 2.5 + t * Math.PI * 3) * Math.sin(time * 0.9);
                    }
                } else { // Demo frequency bars
                    for (let i = 0; i < this.dataArray.length; i++) {
                        const freq = i / this.dataArray.length;
                        const intensity = 0.3 + 0.4 * Math.sin(time * 2 + freq * 10) * Math.exp(- freq * 2) * (0.5 + 0.5 * Math.sin(time * 0.5));
                        this.dataArray[i] = Math.max(0, Math.min(255, intensity * 255));
                        this.dataArrayRight[i] = Math.max(0, Math.min(255, intensity * 255 * 0.8));
                    }
                }
            }
        }

        updatePeaks() {
            if (!this.showPeaks) 
                return;
            


            const currentTime = Date.now();
            // Make sure we're using the actual frequency band count
            const dataLength = this.frequencyBands.length;

            // Ensure peaks array matches current band count
            if (this.peaks.length !== dataLength) {
                this.initializePeaks();
            }

            // Update peaks for left/main channel
            for (let i = 0; i < dataLength; i++) {
                let currentValue;

                if (this.frequencyBands && this.frequencyBands.length > 0) {
                    const band = this.frequencyBands[i];
                    currentValue = band ? this.dataArray[band.bin] / 255 : 0;
                } else {
                    const dataIndex = Math.floor(i * this.dataArray.length / dataLength);
                    currentValue = this.dataArray[dataIndex] / 255;
                }

                if (currentValue > this.peaks[i]) {
                    this.peaks[i] = currentValue;
                    this.lastPeakTime[i] = currentTime;
                    this.peakDecay[i] = 0;
                } else {
                    const timeSincePeak = currentTime - this.lastPeakTime[i];
                    if (timeSincePeak > this.peakHoldTime) {
                        const decayTime = timeSincePeak - this.peakHoldTime;
                        const decayRate = this.gravity / 1000;
                        this.peakDecay[i] = Math.min(this.peaks[i], decayRate * decayTime);
                        this.peaks[i] = Math.max(currentValue, this.peaks[i] - this.peakDecay[i]);
                    }
                }
            }

            // Update peaks for right channel if in stereo mode
            if (this.channelLayout === 'dual-vertical' || this.channelLayout === 'dual-horizontal') { // Ensure right channel peaks array matches too
                if (this.peaksRight.length !== dataLength) {
                    this.initializePeaks();
                }

                for (let i = 0; i < dataLength; i++) {
                    let currentValue;

                    if (this.frequencyBands && this.frequencyBands.length > 0) {
                        const band = this.frequencyBands[i];
                        currentValue = band ? this.dataArrayRight[band.bin] / 255 : 0;
                    } else {
                        const dataIndex = Math.floor(i * this.dataArrayRight.length / dataLength);
                        currentValue = this.dataArrayRight[dataIndex] / 255;
                    }

                    if (currentValue > this.peaksRight[i]) {
                        this.peaksRight[i] = currentValue;
                        this.lastPeakTimeRight[i] = currentTime;
                        this.peakDecayRight[i] = 0;
                    } else {
                        const timeSincePeak = currentTime - this.lastPeakTimeRight[i];
                        if (timeSincePeak > this.peakHoldTime) {
                            const decayTime = timeSincePeak - this.peakHoldTime;
                            const decayRate = this.gravity / 1000;
                            this.peakDecayRight[i] = Math.min(this.peaksRight[i], decayRate * decayTime);
                            this.peaksRight[i] = Math.max(currentValue, this.peaksRight[i] - this.peakDecayRight[i]);
                        }
                    }
                }
            }
        }

        drawFluidSpectrum() {
            const width = this.canvas.width;
            const height = this.canvas.height;
            const bandCount = this.frequencyBands.length;

            // Create gradient
            const gradient = this.ctx.createLinearGradient(0, height, 0, 0);
            gradient.addColorStop(0, 'hsl(120, 100%, 50%)'); // Green at bottom
            gradient.addColorStop(0.5, 'hsl(60, 100%, 50%)'); // Yellow in middle
            gradient.addColorStop(1, 'hsl(0, 100%, 50%)');
            // Red at top

            // Draw as continuous path
            this.ctx.beginPath();
            this.ctx.moveTo(0, height);

            for (let i = 0; i < bandCount; i++) {
                const band = this.frequencyBands[i];
                const value = band ? this.dataArray[band.bin] / 255 : 0;
                const amplitude = this.linearAmplitude ? value * this.linearBoost : value;

                const x = (i / bandCount) * width;
                const y = height - (amplitude * height * 0.9);

                if (i === 0) {
                    this.ctx.lineTo(x, y);
                } else { // Smooth curve between points
                    const prevX = ((i - 1) / bandCount) * width;
                    const midX = (prevX + x) / 2;
                    this.ctx.quadraticCurveTo(prevX, this.lastY || y, midX, y);
                }
                this.lastY = y;
            }

            this.ctx.lineTo(width, height);
            this.ctx.closePath();

            this.ctx.fillStyle = gradient;
            this.ctx.fill();

            // Draw peaks as individual dots/lines, not connected
            if (this.showPeaks) {
                this.ctx.fillStyle = '#ffffff';

                for (let i = 0; i < bandCount; i++) {
                    if (this.peaks[i] > 0.01) {
                        const x = (i / bandCount) * width;
                        const peakY = height - (this.peaks[i] * height * 0.9);
                        const barWidth = width / bandCount;

                        // Draw a small horizontal line for each peak
                        this.ctx.fillRect(x - barWidth / 2, peakY - 1, barWidth, 2);
                    }
                }
            }
        }

        draw() {
            const width = this.canvas.width;
            const height = this.canvas.height;

            // Check if video is active
            const container = document.getElementById('visualizationContainer');
            const isVideoActive = container && container.classList.contains('video-active');

            if (! isVideoActive) { // Only fill background when video is NOT active
                this.ctx.fillStyle = this.backgroundColor;
                this.ctx.fillRect(0, 0, width, height);

                if (this.showBgColor && this.backgroundColor !== '#ffffff') {
                    this.ctx.fillStyle = `rgba(0, 0, 0, ${
                        this.bgAlpha
                    })`;
                    this.ctx.fillRect(0, 0, width, height);
                }
            } else { // Clear canvas for transparency when video is active
                this.ctx.clearRect(0, 0, width, height);
            }

            // Clear canvas with background color
            this.ctx.fillStyle = this.backgroundColor;
            this.ctx.fillRect(0, 0, width, height);

            // Only apply overlay if showBgColor is true AND background is not pure white
            if (this.showBgColor && this.backgroundColor !== '#ffffff') {
                this.ctx.fillStyle = `rgba(0, 0, 0, ${
                    this.bgAlpha
                })`;
                this.ctx.fillRect(0, 0, width, height);
            }

            // Draw based on mode - radial takes precedence over channel layout
            if (this.radial) {
                this.drawRadial();
            } else if (this.channelLayout === 'dual-vertical') {
                this.drawDualVertical();
            } else if (this.channelLayout === 'dual-horizontal') {
                this.drawDualHorizontal();
            } else if (this.mode === 10) {
                this.drawLineGraph();
            } else if (this.mode === 6 && this.ledBars) {
                this.drawLEDBars();
            } else if (this.mode === 0 && this.barSpace === 0) {
                this.drawFluidSpectrum(); // Use fluid drawing for mode 0 with no bar space
            } else {
                this.drawBars();
            }
        }

        drawDualVertical() {
            const width = this.canvas.width;
            const height = this.canvas.height;
            const halfHeight = height / 2;

            // Check if this is the Mirror visualization (mode 1 with dual-vertical)
            const isMirrorMode = this.mode === 1;

            if (isMirrorMode) {
                // Mirror mode: bars start from center
                // Left channel goes up from center
                this.ctx.save();
                this.ctx.translate(0, halfHeight);
                this.ctx.scale(1, -1);
                this.drawChannelBars(0, 0, width, halfHeight, this.dataArray, this.peaks, 'left');
                this.ctx.restore();

                // Right channel goes down from center
                this.drawChannelBars(0, halfHeight, width, halfHeight, this.dataArrayRight, this.peaksRight, 'right');
            } else {
                // Standard dual-vertical: top and bottom separate
                // Draw top half (left channel)
                this.ctx.save();
                this.ctx.translate(0, halfHeight);
                this.ctx.scale(1, -1);
                this.drawChannelBars(0, 0, width, halfHeight, this.dataArray, this.peaks, 'left');
                this.ctx.restore();

                // Draw bottom half (right channel)
                this.drawChannelBars(0, halfHeight, width, halfHeight, this.dataArrayRight, this.peaksRight, 'right');
            }
        }

        drawDualHorizontal() {
            const width = this.canvas.width;
            const height = this.canvas.height;
            const halfWidth = width / 2;

            // Draw left half (left channel)
            this.drawChannelBars(0, 0, halfWidth, height, this.dataArray, this.peaks, 'left');

            // Draw right half (right channel)
            this.ctx.save();
            this.ctx.translate(width, 0);
            this.ctx.scale(-1, 1);
            this.drawChannelBars(0, 0, halfWidth, height, this.dataArrayRight, this.peaksRight, 'right');
            this.ctx.restore();
        }

        drawChannelBars(x, y, width, height, dataArray, peaks, channel) {
            const bandCount = (this.frequencyBands && this.frequencyBands.length > 0) ? this.frequencyBands.length : 64;

            const barWidth = (width / bandCount) * (1 - this.barSpace);
            const barSpacing = width / bandCount;

            // Check if this is Mirror mode
            const isMirrorMode = this.mode === 1 && this.channelLayout === 'dual-vertical';

            for (let i = 0; i < bandCount; i++) {
                let value;

                if (this.frequencyBands && this.frequencyBands.length > 0) {
                    const band = this.frequencyBands[i];
                    value = band ? dataArray[band.bin] / 255 : 0;
                } else {
                    const dataIndex = Math.floor(i * dataArray.length / bandCount);
                    value = dataArray[dataIndex] / 255;
                }

                const amplitude = this.linearAmplitude ? value * this.linearBoost : value;

                const barHeight = amplitude * height * 0.9;
                const barX = x + i * barSpacing + (barSpacing - barWidth) / 2;
                let barY;

                if (isMirrorMode) { // Mirror mode: bars start from y position (which is the center)
                    barY = y;
                } else { // Standard mode: bars grow from bottom
                    barY = y + height - barHeight;
                }

                // Draw bar with channel-specific color
                if (this.fillAlpha > 0) {
                    if (this.colorMode === 'bar-level') { // Color based on bar level
                        const levelColor = this.getBarLevelColor(amplitude);
                        this.ctx.fillStyle = levelColor;
                    } else { // Use gradient based on channel
                        const gradient = channel === 'left' ? this.gradientLeft : this.gradientRight;
                        this.ctx.fillStyle = this.getGradientColor(gradient, i, bandCount, amplitude);
                    }

                    if (this.roundBars) {
                        this.ctx.beginPath();
                        if (isMirrorMode) { // For mirror mode, just draw the bars from center position
                            this.ctx.roundRect(barX, barY, barWidth, barHeight, barWidth / 4);
                        } else {
                            this.ctx.roundRect(barX, barY, barWidth, barHeight, barWidth / 4);
                        }
                        this.ctx.fill();
                    } else {
                        this.ctx.fillRect(barX, barY, barWidth, barHeight);
                    }
                }

                // Draw outline
                if (this.outlineBars || this.lineWidth > 0) {
                    this.ctx.strokeStyle = this.getColor(i, bandCount, amplitude);
                    this.ctx.lineWidth = this.lineWidth || 1;
                    if (this.roundBars) {
                        this.ctx.beginPath();
                        this.ctx.roundRect(barX, barY, barWidth, barHeight, barWidth / 4);
                        this.ctx.stroke();
                    } else {
                        this.ctx.strokeRect(barX, barY, barWidth, barHeight);
                    }
                }

                // Draw peak
                if (this.showPeaks && peaks[i] > 0.01) {
                    let peakY;
                    if (isMirrorMode) { // For mirror mode, peaks are at the end of the bars
                        if (channel === 'left') {
                            peakY = y -(peaks[i] * height * 0.9);
                        } else {
                            peakY = y + (peaks[i] * height * 0.9);
                        }
                    } else {
                        peakY = y + height -(peaks[i] * height * 0.9);
                    }
                    this.ctx.fillStyle = '#ffffff';
                    this.ctx.fillRect(barX, peakY - 2, barWidth, 3);
                }
            }
        }

        getBarLevelColor(level) { // Color based on intensity level (green -> yellow -> red)
            if (level < 0.33) {
                return `hsl(120, 100%, ${
                    50 * level * 3
                }%)`;
            } else if (level < 0.66) {
                return `hsl(${
                    120 - (level - 0.33) * 360
                }, 100%, 50%)`;
            } else {
                return `hsl(0, 100%, ${
                    50 + (level - 0.66) * 50
                }%)`;
            }
        }

        getGradientColor(gradientType, index, total, intensity) {
            switch (gradientType) {
                case 'steelblue':
                    return `rgba(${
                        70 * intensity
                    }, ${
                        130 * intensity
                    }, ${
                        180 * intensity
                    }, ${
                        this.fillAlpha
                    })`;
                case 'orangered':
                    const orange = 255 * intensity;
                    const red = Math.min(255, orange * 1.5);
                    return `rgba(${red}, ${
                        orange * 0.6
                    }, 0, ${
                        this.fillAlpha
                    })`;
                default:
                    return this.getColor(index, total, intensity);
            }
        }

        drawBars() {
            const width = this.canvas.width;
            const height = this.canvas.height;
            const bandCount = (this.frequencyBands && this.frequencyBands.length > 0) ? this.frequencyBands.length : 64;

            const barWidth = (width / bandCount) * (1 - this.barSpace);
            const barSpacing = width / bandCount;

            // Array to store peak positions for peakLine
            const peakPositions = [];

            for (let i = 0; i < bandCount; i++) {
                let value;

                if (this.frequencyBands && this.frequencyBands.length > 0) {
                    const band = this.frequencyBands[i];
                    value = band ? this.dataArray[band.bin] / 255 : 0;
                } else {
                    const dataIndex = Math.floor(i * this.dataArray.length / bandCount);
                    value = this.dataArray[dataIndex] / 255;
                }

                const amplitude = this.linearAmplitude ? value * this.linearBoost : value;

                const barHeight = amplitude * height * 0.9;
                const x = i * barSpacing + (barSpacing - barWidth) / 2;
                const y = height - barHeight;

                if (this.fillAlpha > 0) {
                    this.ctx.fillStyle = this.getColor(i, bandCount, amplitude);
                    if (this.roundBars) {
                        this.ctx.beginPath();
                        this.ctx.roundRect(x, y, barWidth, barHeight, barWidth / 4);
                        this.ctx.fill();
                    } else {
                        this.ctx.fillRect(x, y, barWidth, barHeight);
                    }
                }

                if (this.outlineBars || this.lineWidth > 0) {
                    this.ctx.strokeStyle = this.getColor(i, bandCount, amplitude);
                    this.ctx.lineWidth = this.lineWidth || 1;
                    if (this.roundBars) {
                        this.ctx.beginPath();
                        this.ctx.roundRect(x, y, barWidth, barHeight, barWidth / 4);
                        this.ctx.stroke();
                    } else {
                        this.ctx.strokeRect(x, y, barWidth, barHeight);
                    }
                }

                if (this.showPeaks && this.peaks[i] > 0.01) {
                    const peakY = height - (this.peaks[i] * height * 0.9);

                    // Store peak position for peakLine
                    if (this.peakLine) {
                        peakPositions.push({
                            x: x + barWidth / 2,
                            y: peakY
                        });
                    } else { // Draw individual peak bars
                        this.ctx.fillStyle = '#ffffff';
                        this.ctx.fillRect(x, peakY - 2, barWidth, 3);
                    }
                }
            }

            // Draw connected peak line if enabled
            if (this.peakLine && peakPositions.length > 1) {
                this.ctx.strokeStyle = '#ffffff';
                this.ctx.lineWidth = 2;
                this.ctx.beginPath();
                this.ctx.moveTo(peakPositions[0].x, peakPositions[0].y);

                for (let i = 1; i < peakPositions.length; i++) {
                    this.ctx.lineTo(peakPositions[i].x, peakPositions[i].y);
                }

                this.ctx.stroke();
            }
        }

        drawLEDBars() {
            const width = this.canvas.width;
            const height = this.canvas.height;
            const bandCount = (this.frequencyBands && this.frequencyBands.length > 0) ? this.frequencyBands.length : 64;

            const barWidth = (width / bandCount) * (1 - this.barSpace);
            const barSpacing = width / bandCount;
            const ledSize = this.trueLeds ? 4 : 6;
            const ledGap = 2;
            const ledsPerBar = Math.floor(height / (ledSize + ledGap));

            for (let i = 0; i < bandCount; i++) {
                let value;

                if (this.frequencyBands && this.frequencyBands.length > 0) {
                    const band = this.frequencyBands[i];
                    value = band ? this.dataArray[band.bin] / 255 : 0;
                } else {
                    const dataIndex = Math.floor(i * this.dataArray.length / bandCount);
                    value = this.dataArray[dataIndex] / 255;
                }

                const litLeds = Math.floor(value * ledsPerBar);
                const x = i * barSpacing + (barSpacing - barWidth) / 2;

                for (let j = 0; j < litLeds; j++) {
                    const ledY = height - (j + 1) * (ledSize + ledGap);
                    const intensity = 1 - (j / ledsPerBar) * 0.3;

                    let color;
                    const ledPercent = j / ledsPerBar;
                    if (ledPercent < 0.5) {
                        color = `hsl(120, 100%, ${
                            50 * intensity
                        }%)`;
                    } else if (ledPercent < 0.8) {
                        color = `hsl(60, 100%, ${
                            50 * intensity
                        }%)`;
                    } else {
                        color = `hsl(0, 100%, ${
                            50 * intensity
                        }%)`;
                    }

                    this.ctx.fillStyle = color;
                    this.ctx.fillRect(x, ledY, barWidth, ledSize);
                }

                if (this.showPeaks && this.peaks[i] > 0.01) {
                    const peakLed = Math.floor(this.peaks[i] * ledsPerBar);
                    const peakY = height - (peakLed + 1) * (ledSize + ledGap);
                    this.ctx.fillStyle = '#ffffff';
                    this.ctx.fillRect(x, peakY, barWidth, ledSize);
                }
            }
        }

        drawLineGraph() {
            const width = this.canvas.width;
            const height = this.canvas.height;

            const points = Math.min(512, this.dataArray.length);
            const step = this.dataArray.length / points;

            this.ctx.globalAlpha = this.fillAlpha;

            const gradient = this.ctx.createLinearGradient(0, 0, width, 0);
            this.applyColorSchemeGradient(gradient);

            this.ctx.strokeStyle = gradient;
            this.ctx.lineWidth = this.lineWidth || 2;
            this.ctx.beginPath();

            for (let i = 0; i < points; i++) {
                const dataIndex = Math.floor(i * step);
                const x = (i / (points - 1)) * width;

                const value = (this.dataArray[dataIndex] - 128) / 128;
                const y = (height / 2) + (value * height * 0.35);

                if (i === 0) {
                    this.ctx.moveTo(x, y);
                } else {
                    this.ctx.lineTo(x, y);
                }
            }

            this.ctx.stroke();

            if (this.fillAlpha > 0 && this.fillAlpha < 1) {
                this.ctx.globalAlpha = this.fillAlpha * 0.3;
                this.ctx.beginPath();

                for (let i = 0; i < points; i++) {
                    const dataIndex = Math.floor(i * step);
                    const x = (i / (points - 1)) * width;
                    const value = (this.dataArray[dataIndex] - 128) / 128;
                    const y = (height / 2) + (value * height * 0.35);

                    if (i === 0) {
                        this.ctx.moveTo(x, height / 2);
                        this.ctx.lineTo(x, y);
                    } else {
                        this.ctx.lineTo(x, y);
                    }
                }

                this.ctx.lineTo(width, height / 2);
                this.ctx.closePath();
                this.ctx.fillStyle = gradient;
                this.ctx.fill();
            }

            this.ctx.globalAlpha = 1;
        }

        drawRadial() {
            const width = this.canvas.width;
            const height = this.canvas.height;
            const centerX = width / 2;
            const centerY = height / 2;
            const maxRadius = Math.min(width, height) / 2 * (this.radius + 0.4);
            const bandCount = (this.frequencyBands && this.frequencyBands.length > 0) ? this.frequencyBands.length : 64;

            if (this.spinSpeed) {
                this.spinAngle += this.spinSpeed * 0.02;
            }

            // Calculate angle step
            const angleStep = (Math.PI * 2) / bandCount;

            for (let i = 0; i < bandCount; i++) {
                let value;

                if (this.frequencyBands && this.frequencyBands.length > 0) {
                    const band = this.frequencyBands[i];
                    value = band ? this.dataArray[band.bin] / 255 : 0;
                } else {
                    const dataIndex = Math.floor(i * this.dataArray.length / bandCount);
                    value = this.dataArray[dataIndex] / 255;
                }

                // Apply linear amplitude if needed
                const amplitude = this.linearAmplitude ? value * this.linearBoost : value;

                const angle = i * angleStep + this.spinAngle;
                const barLength = amplitude * maxRadius * 0.6;
                const innerRadius = this.radialInvert ? maxRadius : maxRadius * 0.2;
                const outerRadius = this.radialInvert ? maxRadius - barLength : innerRadius + barLength;

                const x1 = centerX + Math.cos(angle) * innerRadius;
                const y1 = centerY + Math.sin(angle) * innerRadius;
                const x2 = centerX + Math.cos(angle) * outerRadius;
                const y2 = centerY + Math.sin(angle) * outerRadius;

                // Draw the radial bar
                this.ctx.strokeStyle = this.getColor(i, bandCount, amplitude);
                this.ctx.lineWidth = this.lineWidth || 3;
                this.ctx.lineCap = this.roundBars ? 'round' : 'butt';
                this.ctx.beginPath();
                this.ctx.moveTo(x1, y1);
                this.ctx.lineTo(x2, y2);
                this.ctx.stroke();

                // Draw peak if enabled
                if (this.showPeaks && this.peaks[i] > 0.01) {
                    const peakAmplitude = this.linearAmplitude ? this.peaks[i] * this.linearBoost : this.peaks[i];
                    const peakLength = peakAmplitude * maxRadius * 0.6;
                    const peakRadius = this.radialInvert ? maxRadius - peakLength : innerRadius + peakLength;
                    const px = centerX + Math.cos(angle) * peakRadius;
                    const py = centerY + Math.sin(angle) * peakRadius;

                    this.ctx.fillStyle = '#ffffff';
                    this.ctx.beginPath();
                    this.ctx.arc(px, py, 2, 0, Math.PI * 2);
                    this.ctx.fill();
                }
            }
        }

        applyMirror() {
            const width = this.canvas.width;
            const height = this.canvas.height;

            if (this.mirror === -1) { // Horizontal mirror
                const tempCanvas = document.createElement('canvas');
                tempCanvas.width = width;
                tempCanvas.height = height;
                const tempCtx = tempCanvas.getContext('2d');

                tempCtx.drawImage(this.canvas, 0, 0);

                this.ctx.save();
                this.ctx.globalAlpha = 0.9;
                this.ctx.scale(1, -1);
                this.ctx.drawImage(tempCanvas, 0, - height, width, height);
                this.ctx.restore();
            } else if (this.mirror === 1) { // Vertical mirror
                const tempCanvas = document.createElement('canvas');
                tempCanvas.width = width;
                tempCanvas.height = height;
                const tempCtx = tempCanvas.getContext('2d');

                tempCtx.drawImage(this.canvas, 0, 0);

                this.ctx.save();
                this.ctx.globalAlpha = 0.5;
                this.ctx.scale(-1, 1);
                this.ctx.translate(- width, 0);
                this.ctx.drawImage(tempCanvas, 0, 0);
                this.ctx.restore();
            }
        }

        applyReflection() {
            const width = this.canvas.width;
            const height = this.canvas.height;
            const reflexHeight = height * this.reflexRatio;

            if (reflexHeight <= 0) 
                return;
            


            this.ctx.save();

            this.ctx.translate(0, height);
            this.ctx.scale(1, -1);

            this.ctx.globalAlpha = this.reflexAlpha;

            this.ctx.drawImage(this.canvas, 0, - reflexHeight, width, reflexHeight, 0, 0, width, reflexHeight);

            this.ctx.globalCompositeOperation = 'destination-out';
            const gradient = this.ctx.createLinearGradient(0, 0, 0, reflexHeight);
            gradient.addColorStop(0, 'rgba(0,0,0,0)');
            gradient.addColorStop(1, 'rgba(0,0,0,1)');
            this.ctx.fillStyle = gradient;
            this.ctx.fillRect(0, 0, width, reflexHeight);

            this.ctx.restore();
        }

        applyColorSchemeGradient(gradient) {
            switch (this.currentColorScheme) {
                case 'earthtones':
                    gradient.addColorStop(0, '#8B4513');
                    gradient.addColorStop(0.25, '#D2691E');
                    gradient.addColorStop(0.5, '#CD853F');
                    gradient.addColorStop(0.75, '#F4A460');
                    gradient.addColorStop(1, '#DEB887');
                    break;
                case 'luigi':
                    gradient.addColorStop(0, '#00A000');
                    gradient.addColorStop(0.33, '#00FF00');
                    gradient.addColorStop(0.66, '#0000FF');
                    gradient.addColorStop(1, '#FFFF00');
                    break;
                case 'metal':
                    gradient.addColorStop(0, '#2C2C2C');
                    gradient.addColorStop(0.25, '#606060');
                    gradient.addColorStop(0.5, '#808080');
                    gradient.addColorStop(0.75, '#C0C0C0');
                    gradient.addColorStop(1, '#E5E5E5');
                    break;
                case 'psychedelic':
                    gradient.addColorStop(0, '#FF1493');
                    gradient.addColorStop(0.2, '#9400D3');
                    gradient.addColorStop(0.4, '#00CED1');
                    gradient.addColorStop(0.6, '#FFD700');
                    gradient.addColorStop(0.8, '#FF69B4');
                    gradient.addColorStop(1, '#00FFFF');
                    break;
                default:
                    gradient.addColorStop(0, 'hsl(0, 100%, 60%)');
                    gradient.addColorStop(0.17, 'hsl(60, 100%, 60%)');
                    gradient.addColorStop(0.33, 'hsl(120, 100%, 60%)');
                    gradient.addColorStop(0.5, 'hsl(180, 100%, 60%)');
                    gradient.addColorStop(0.67, 'hsl(240, 100%, 60%)');
                    gradient.addColorStop(0.83, 'hsl(300, 100%, 60%)');
                    gradient.addColorStop(1, 'hsl(360, 100%, 60%)');
                    break;
            }
        }

        getColor(index, total, value) {
            const intensity = 0.4 + value * 0.6;

            switch (this.currentColorScheme) {
                case 'earthtones':
                    const earthColors = [
                        '#8B4513',
                        '#D2691E',
                        '#CD853F',
                        '#F4A460',
                        '#DEB887'
                    ];
                    const earthIndex = Math.floor((index / total) * earthColors.length);
                    return earthColors[earthIndex];

                case 'luigi':
                    const luigiColors = ['#00A000', '#00FF00', '#0000FF', '#FFFF00'];
                    const luigiIndex = Math.floor((index / total) * luigiColors.length);
                    return luigiColors[luigiIndex];

                case 'metal':
                    const metalColors = [
                        '#2C2C2C',
                        '#606060',
                        '#808080',
                        '#C0C0C0',
                        '#E5E5E5'
                    ];
                    const metalIndex = Math.floor((index / total) * metalColors.length);
                    return metalColors[metalIndex];

                case 'psychedelic':
                    const psychColors = [
                        '#FF1493',
                        '#9400D3',
                        '#00CED1',
                        '#FFD700',
                        '#FF69B4',
                        '#00FFFF'
                    ];
                    const psychIndex = Math.floor((index / total) * psychColors.length);
                    return psychColors[psychIndex];

                default:
                    switch (this.gradient) {
                        case 'classic':
                            const hue = 120 - (index / total) * 120;
                            return `hsla(${hue}, 100%, ${
                                50 * intensity
                            }%, ${
                                this.fillAlpha
                            })`;

                        case 'rainbow':
                            const rainbowHue = (index / total) * 360;
                            return `hsla(${rainbowHue}, 100%, ${60}%, ${
                                this.fillAlpha
                            })`;

                        case 'prism':
                            const prismHue = 180 + (index / total) * 180;
                            return `hsla(${prismHue}, 80%, ${
                                60 * intensity
                            }%, ${
                                this.fillAlpha
                            })`;

                        case 'steelblue':
                            return `rgba(${
                                70 * intensity
                            }, ${
                                130 * intensity
                            }, ${
                                180 * intensity
                            }, ${
                                this.fillAlpha
                            })`;

                        case 'orangered':
                            const orange = 255 * intensity;
                            const red = Math.min(255, orange * 1.5);
                            return `rgba(${red}, ${
                                orange * 0.6
                            }, 0, ${
                                this.fillAlpha
                            })`;

                        default:
                            const defaultHue = (index / total) * 120;
                            return `hsla(${
                                120 + defaultHue
                            }, 100%, ${
                                50 * intensity
                            }%, ${
                                this.fillAlpha
                            })`;
                    }
            }
        }

        destroy() {
            if (this.animationFrame) {
                cancelAnimationFrame(this.animationFrame);
            }
            this.disconnectInput();
            if (this.canvas && this.canvas.parentNode) {
                this.canvas.parentNode.removeChild(this.canvas);
            }
        }
    }

    // ****
    // ****

    // Enhanced Parameter Mapping System
    const VISUALIZATION_PARAMETERS = {
        // Bars Scope Parameters
        bars: {
            gradient: { min: 0, max: 1, default: 0.5, type: 'float', audioMotion: 'gradient' },
            peakShowTime: { min: 0, max: 2000, default: 500, type: 'int', audioMotion: 'peakHoldTime' },
            barWidth: { min: 1, max: 20, default: 8, type: 'int', audioMotion: 'lineWidth' },
            barSpacing: { min: 0, max: 10, default: 2, type: 'int', audioMotion: 'barSpace' },
            barHeight: { min: 0.1, max: 2.0, default: 1.0, type: 'float', audioMotion: 'linearBoost' },
            mirrorMode: { values: ['off', 'x', 'y', 'xy'], default: 'off', type: 'enum', audioMotion: 'mirror' },
            smoothing: { min: 0, max: 1, default: 0.3, type: 'float', audioMotion: 'smoothing' },
            colormode: { values: ['spectrum', 'rainbow', 'fire', 'ocean', 'neon'], default: 'spectrum', type: 'enum', audioMotion: 'colorMode' },
            fadepeaks: { min: 0, max: 1, default: 0.5, type: 'float', audioMotion: 'fadePeaks' },
            showpeaks: { default: true, type: 'boolean', audioMotion: 'showPeaks' },
            peakdecay: { min: 0, max: 1, default: 0.7, type: 'float', audioMotion: 'peakFadeTime' }
        },
        
        // Radial Scope Parameters  
        radial: {
            gradient: { min: 0, max: 1, default: 0.5, type: 'float', audioMotion: 'gradient' },
            peakShowTime: { min: 0, max: 2000, default: 500, type: 'int', audioMotion: 'peakHoldTime' },
            radialSensitivity: { min: 0.1, max: 3.0, default: 1.0, type: 'float', audioMotion: 'linearBoost' },
            radialSmoothing: { min: 0, max: 1, default: 0.4, type: 'float', audioMotion: 'smoothing' },
            centerGlow: { min: 0, max: 1, default: 0.3, type: 'float', audioMotion: 'reflexAlpha' },
            outerGlow: { min: 0, max: 1, default: 0.6, type: 'float', audioMotion: 'reflexBright' },
            radialinvert: { default: false, type: 'boolean', audioMotion: 'radialInvert' },
            radius: { min: 50, max: 300, default: 150, type: 'int', audioMotion: 'radius' },
            colormode: { values: ['spectrum', 'rainbow', 'fire', 'ocean', 'neon'], default: 'spectrum', type: 'enum', audioMotion: 'colorMode' },
            fadepeaks: { min: 0, max: 1, default: 0.5, type: 'float', audioMotion: 'fadePeaks' },
            showpeaks: { default: true, type: 'boolean', audioMotion: 'showPeaks' },
            peakdecay: { min: 0, max: 1, default: 0.7, type: 'float', audioMotion: 'peakFadeTime' },
            smoothing: { min: 0, max: 1, default: 0.3, type: 'float', audioMotion: 'smoothing' }
        },
        
        // Energy Scope Parameters
        energy: {
            gradient: { min: 0, max: 1, default: 0.5, type: 'float', audioMotion: 'gradient' },
            peakShowTime: { min: 0, max: 2000, default: 500, type: 'int', audioMotion: 'peakHoldTime' },
            energySensitivity: { min: 0.1, max: 3.0, default: 1.0, type: 'float', audioMotion: 'linearBoost' },
            energySmoothing: { min: 0, max: 1, default: 0.5, type: 'float', audioMotion: 'smoothing' },
            particleCount: { min: 10, max: 200, default: 50, type: 'int', audioMotion: 'fftSize' },
            particleSpeed: { min: 0.1, max: 2.0, default: 1.0, type: 'float', audioMotion: 'gravity' },
            colormode: { values: ['spectrum', 'rainbow', 'fire', 'ocean', 'neon'], default: 'spectrum', type: 'enum', audioMotion: 'colorMode' },
            fadepeaks: { min: 0, max: 1, default: 0.5, type: 'float', audioMotion: 'fadePeaks' },
            showpeaks: { min: 0, max: 1, default: 0.7, type: 'float', audioMotion: 'showPeaks' },
            peakdecay: { min: 0, max: 1, default: 0.7, type: 'float', audioMotion: 'peakFadeTime' },
            smoothing: { min: 0, max: 1, default: 0.3, type: 'float', audioMotion: 'smoothing' }
        },
        
        // Global Parameters (affect all scopes)
        global: {
            backgroundColor: { type: 'color', default: '#000000', audioMotion: 'showBgColor' },
            colorScheme: { values: ['default', 'neon', 'fire', 'ocean', 'sunset'], default: 'default', type: 'enum', audioMotion: 'gradient' },
            brightness: { min: 0.1, max: 2.0, default: 1.0, type: 'float', audioMotion: 'linearBoost' },
            contrast: { min: 0.1, max: 2.0, default: 1.0, type: 'float', audioMotion: 'maxDecibels' },
            saturation: { min: 0, max: 2.0, default: 1.0, type: 'float', audioMotion: 'fillAlpha' }
        }
    };

    // Enhanced Genre Mappings with 7 New Genres
    const GENRE_MAPPINGS = {
        // Heavy Metal
        'heavy-metal': {
            visualization: {
                bars: { gradient: 0.8, peakShowTime: 200, barWidth: 12, smoothing: 0.1, colormode: 'fire', fadepeaks: 0.2, showpeaks: true, peakdecay: 0.3 },
                radial: { gradient: 0.9, radialSensitivity: 2.5, centerGlow: 0.8, radialinvert: false, radius: 200, colormode: 'fire', fadepeaks: 0.1, showpeaks: true, peakdecay: 0.2 },
                energy: { energySensitivity: 2.8, particleCount: 150, particleSpeed: 1.8, colormode: 'fire', fadepeaks: 0.1, showpeaks: 0.9, peakdecay: 0.2, smoothing: 0.1 },
                global: { colorScheme: 'fire', brightness: 1.3, contrast: 1.4, saturation: 1.2 }
            },
            video: {
                colorEffects: { grayscale: 0.3, invert: 0.2, contrast: 1.5, brightness: 0.8 },
                artisticEffects: { posterize: 0.6, edgeDetection: 0.4 },
                blendModes: { multiply: 0.3, overlay: 0.2 }
            },
            audioCharacteristics: { energy: 'high', tempo: 'fast', frequency: 'bass-heavy', dynamics: 'aggressive' }
        },
        
        // Rock
        'rock': {
            visualization: {
                bars: { gradient: 0.7, peakShowTime: 300, barWidth: 10, smoothing: 0.2, colormode: 'fire', fadepeaks: 0.3, showpeaks: true, peakdecay: 0.4 },
                radial: { gradient: 0.8, radialSensitivity: 2.0, centerGlow: 0.7, radialinvert: false, radius: 180, colormode: 'fire', fadepeaks: 0.2, showpeaks: true, peakdecay: 0.3 },
                energy: { energySensitivity: 2.2, particleCount: 120, particleSpeed: 1.5, colormode: 'fire', fadepeaks: 0.2, showpeaks: 0.8, peakdecay: 0.3, smoothing: 0.2 },
                global: { colorScheme: 'fire', brightness: 1.2, contrast: 1.3, saturation: 1.1 }
            },
            video: {
                colorEffects: { grayscale: 0.2, invert: 0.1, contrast: 1.3, brightness: 0.9 },
                artisticEffects: { posterize: 0.4, edgeDetection: 0.3 },
                blendModes: { multiply: 0.2, overlay: 0.1 }
            },
            audioCharacteristics: { energy: 'high', tempo: 'medium-fast', frequency: 'balanced', dynamics: 'energetic' }
        },
        
        // Electronic/Dance
        'electronic': {
            visualization: {
                bars: { gradient: 0.6, peakShowTime: 100, barWidth: 6, smoothing: 0.8, colormode: 'neon', fadepeaks: 0.1, showpeaks: true, peakdecay: 0.1 },
                radial: { gradient: 0.7, radialSensitivity: 1.8, centerGlow: 0.9, radialinvert: true, radius: 160, colormode: 'neon', fadepeaks: 0.05, showpeaks: true, peakdecay: 0.1 },
                energy: { energySensitivity: 2.2, particleCount: 100, particleSpeed: 1.5, colormode: 'neon', fadepeaks: 0.05, showpeaks: 0.9, peakdecay: 0.1, smoothing: 0.8 },
                global: { colorScheme: 'neon', brightness: 1.5, contrast: 1.2, saturation: 1.4 }
            },
            video: {
                colorEffects: { hue: 60, saturation: 1.6, brightness: 1.3 },
                artisticEffects: { blur: 2, sharpen: 0.5 },
                blendModes: { screen: 0.4, overlay: 0.3 }
            },
            audioCharacteristics: { energy: 'very-high', tempo: 'very-fast', frequency: 'treble-heavy', dynamics: 'pulsing' }
        },
        
        // Reggae
        'reggae': {
            visualization: {
                bars: { gradient: 0.4, peakShowTime: 600, barWidth: 8, smoothing: 0.6, colormode: 'ocean', fadepeaks: 0.6, showpeaks: true, peakdecay: 0.8 },
                radial: { gradient: 0.5, radialSensitivity: 1.2, centerGlow: 0.4, radialinvert: false, radius: 140, colormode: 'ocean', fadepeaks: 0.5, showpeaks: true, peakdecay: 0.7 },
                energy: { energySensitivity: 1.5, particleCount: 60, particleSpeed: 0.8, colormode: 'ocean', fadepeaks: 0.5, showpeaks: 0.6, peakdecay: 0.8, smoothing: 0.6 },
                global: { colorScheme: 'ocean', brightness: 1.0, contrast: 1.0, saturation: 1.1 }
            },
            video: {
                colorEffects: { hue: 120, saturation: 1.2, brightness: 1.0 },
                artisticEffects: { blur: 1, emboss: 0.2 },
                blendModes: { overlay: 0.1 }
            },
            audioCharacteristics: { energy: 'medium', tempo: 'slow-medium', frequency: 'bass-heavy', dynamics: 'relaxed' }
        },
        
        // Country
        'country': {
            visualization: {
                bars: { gradient: 0.3, peakShowTime: 800, barWidth: 6, smoothing: 0.7, colormode: 'sunset', fadepeaks: 0.7, showpeaks: true, peakdecay: 0.9 },
                radial: { gradient: 0.4, radialSensitivity: 1.0, centerGlow: 0.3, radialinvert: false, radius: 120, colormode: 'sunset', fadepeaks: 0.6, showpeaks: true, peakdecay: 0.8 },
                energy: { energySensitivity: 1.2, particleCount: 40, particleSpeed: 0.6, colormode: 'sunset', fadepeaks: 0.6, showpeaks: 0.5, peakdecay: 0.9, smoothing: 0.7 },
                global: { colorScheme: 'sunset', brightness: 0.9, contrast: 0.9, saturation: 0.8 }
            },
            video: {
                colorEffects: { sepia: 0.3, saturation: 0.9, brightness: 0.9 },
                artisticEffects: { blur: 0.5, emboss: 0.1 },
                blendModes: { multiply: 0.1 }
            },
            audioCharacteristics: { energy: 'low-medium', tempo: 'slow-medium', frequency: 'mid-heavy', dynamics: 'gentle' }
        },
        
        // Funk
        'funk': {
            visualization: {
                bars: { gradient: 0.6, peakShowTime: 150, barWidth: 9, smoothing: 0.4, colormode: 'rainbow', fadepeaks: 0.2, showpeaks: true, peakdecay: 0.3 },
                radial: { gradient: 0.7, radialSensitivity: 1.6, centerGlow: 0.6, radialinvert: true, radius: 170, colormode: 'rainbow', fadepeaks: 0.1, showpeaks: true, peakdecay: 0.2 },
                energy: { energySensitivity: 1.8, particleCount: 80, particleSpeed: 1.2, colormode: 'rainbow', fadepeaks: 0.1, showpeaks: 0.7, peakdecay: 0.3, smoothing: 0.4 },
                global: { colorScheme: 'neon', brightness: 1.1, contrast: 1.1, saturation: 1.3 }
            },
            video: {
                colorEffects: { hue: 180, saturation: 1.4, brightness: 1.1 },
                artisticEffects: { sharpen: 0.3, emboss: 0.2 },
                blendModes: { screen: 0.2, overlay: 0.1 }
            },
            audioCharacteristics: { energy: 'medium-high', tempo: 'medium', frequency: 'bass-heavy', dynamics: 'groovy' }
        },
        
        // Ambient
        'ambient': {
            visualization: {
                bars: { gradient: 0.2, peakShowTime: 1500, barWidth: 4, smoothing: 0.95, colormode: 'ocean', fadepeaks: 0.9, showpeaks: false, peakdecay: 0.95 },
                radial: { gradient: 0.1, radialSensitivity: 0.5, centerGlow: 0.1, radialinvert: false, radius: 100, colormode: 'ocean', fadepeaks: 0.8, showpeaks: false, peakdecay: 0.9 },
                energy: { energySensitivity: 0.8, particleCount: 20, particleSpeed: 0.3, colormode: 'ocean', fadepeaks: 0.8, showpeaks: 0.2, peakdecay: 0.95, smoothing: 0.95 },
                global: { colorScheme: 'ocean', brightness: 0.6, contrast: 0.7, saturation: 0.6 }
            },
            video: {
                colorEffects: { grayscale: 0.4, sepia: 0.2, brightness: 0.7 },
                artisticEffects: { blur: 3, emboss: 0.1 },
                blendModes: { multiply: 0.2 }
            },
            audioCharacteristics: { energy: 'very-low', tempo: 'very-slow', frequency: 'balanced', dynamics: 'ethereal' }
        },
        
        // Punk
        'punk': {
            visualization: {
                bars: { gradient: 0.9, peakShowTime: 100, barWidth: 14, smoothing: 0.05, colormode: 'fire', fadepeaks: 0.1, showpeaks: true, peakdecay: 0.1 },
                radial: { gradient: 0.95, radialSensitivity: 2.8, centerGlow: 0.9, radialinvert: true, radius: 220, colormode: 'fire', fadepeaks: 0.05, showpeaks: true, peakdecay: 0.1 },
                energy: { energySensitivity: 3.0, particleCount: 180, particleSpeed: 2.0, colormode: 'fire', fadepeaks: 0.05, showpeaks: 0.95, peakdecay: 0.1, smoothing: 0.05 },
                global: { colorScheme: 'fire', brightness: 1.4, contrast: 1.5, saturation: 1.3 }
            },
            video: {
                colorEffects: { grayscale: 0.4, invert: 0.3, contrast: 1.6, brightness: 0.7 },
                artisticEffects: { posterize: 0.8, edgeDetection: 0.6 },
                blendModes: { multiply: 0.4, overlay: 0.3 }
            },
            audioCharacteristics: { energy: 'very-high', tempo: 'very-fast', frequency: 'treble-heavy', dynamics: 'chaotic' }
        },
        
        // Jazz (existing)
        'jazz': {
            visualization: {
                bars: { gradient: 0.4, peakShowTime: 800, barWidth: 4, smoothing: 0.9, colormode: 'ocean', fadepeaks: 0.7, showpeaks: true, peakdecay: 0.8 },
                radial: { gradient: 0.3, radialSensitivity: 0.8, centerGlow: 0.2, radialinvert: false, radius: 110, colormode: 'ocean', fadepeaks: 0.6, showpeaks: true, peakdecay: 0.7 },
                energy: { energySensitivity: 0.9, particleCount: 30, particleSpeed: 0.6, colormode: 'ocean', fadepeaks: 0.6, showpeaks: 0.4, peakdecay: 0.8, smoothing: 0.9 },
                global: { colorScheme: 'ocean', brightness: 0.8, contrast: 0.9, saturation: 0.7 }
            },
            video: {
                colorEffects: { sepia: 0.4, saturation: 0.8, brightness: 0.9 },
                artisticEffects: { blur: 1, emboss: 0.3 },
                blendModes: { multiply: 0.2 }
            },
            audioCharacteristics: { energy: 'medium', tempo: 'variable', frequency: 'mid-heavy', dynamics: 'smooth' }
        },
        
        // Classical (existing)
        'classical': {
            visualization: {
                bars: { gradient: 0.2, peakShowTime: 1200, barWidth: 3, smoothing: 0.95, colormode: 'spectrum', fadepeaks: 0.8, showpeaks: true, peakdecay: 0.9 },
                radial: { gradient: 0.1, radialSensitivity: 0.6, centerGlow: 0.1, radialinvert: false, radius: 90, colormode: 'spectrum', fadepeaks: 0.7, showpeaks: true, peakdecay: 0.8 },
                energy: { energySensitivity: 0.7, particleCount: 20, particleSpeed: 0.4, colormode: 'spectrum', fadepeaks: 0.7, showpeaks: 0.3, peakdecay: 0.9, smoothing: 0.95 },
                global: { colorScheme: 'default', brightness: 0.7, contrast: 0.8, saturation: 0.6 }
            },
            video: {
                colorEffects: { grayscale: 0.2, sepia: 0.3, brightness: 0.8 },
                artisticEffects: { blur: 0.5, emboss: 0.2 },
                blendModes: { multiply: 0.1 }
            },
            audioCharacteristics: { energy: 'low-medium', tempo: 'slow-medium', frequency: 'balanced', dynamics: 'gentle' }
        }
    };

    // Predictive Behavior System for AI Autopilot
    class PredictiveBehaviorSystem {
        constructor(autopilot) {
            this.autopilot = autopilot;
            this.predictionHistory = [];
            this.userBehaviorPatterns = [];
            this.contextPredictions = [];
            this.predictionAccuracy = 0;
            this.lastPrediction = 0;
            this.predictionCooldown = 10000; // 10 seconds between predictions
            this.confidenceThreshold = 0.8; // Only act on high-confidence predictions
            this.anticipationWindow = 5000; // Look 5 seconds ahead
            
            this.loadPredictionData();
        }

        // Analyze audio context and predict optimal actions
        predictOptimalActions(audioFeatures, currentMode, currentParams) {
            const now = Date.now();
            if (now - this.lastPrediction < this.predictionCooldown) {
                return null;
            }

            try {
                const predictions = {
                    modeChange: this.predictModeChange(audioFeatures, currentMode),
                    parameterAdjustment: this.predictParameterAdjustment(audioFeatures, currentParams),
                    timing: this.predictOptimalTiming(audioFeatures),
                    confidence: 0
                };

                // Calculate overall confidence
                predictions.confidence = this.calculatePredictionConfidence(predictions, audioFeatures);
                
                // Only return predictions with high confidence
                if (predictions.confidence >= this.confidenceThreshold) {
                    this.lastPrediction = now;
                    this.recordPrediction(predictions, audioFeatures);
                    return predictions;
                }

                return null;
            } catch (error) {
                console.error('Error in predictive behavior:', error);
                return null;
            }
        }

        // Predict if a mode change would be beneficial
        predictModeChange(audioFeatures, currentMode) {
            const { energy, beat, tempo, dominantFreq, energyTrend } = audioFeatures;
            
            // Analyze current mode effectiveness
            const currentModeEffectiveness = this.analyzeModeEffectiveness(currentMode, audioFeatures);
            
            // Predict better modes based on audio context
            const suggestedModes = this.getContextualModeSuggestions(audioFeatures);
            
            // Find the best alternative mode
            let bestMode = null;
            let bestScore = currentModeEffectiveness;
            
            for (const mode of suggestedModes) {
                if (mode !== currentMode) {
                    const modeScore = this.analyzeModeEffectiveness(mode, audioFeatures);
                    if (modeScore > bestScore) {
                        bestMode = mode;
                        bestScore = modeScore;
                    }
                }
            }

            return {
                suggested: bestMode,
                confidence: bestMode ? Math.min(0.9, (bestScore - currentModeEffectiveness) * 2) : 0,
                reason: this.getModeChangeReason(bestMode, audioFeatures),
                timing: this.predictModeChangeTiming(audioFeatures)
            };
        }

        // Predict parameter adjustments that would improve performance
        predictParameterAdjustment(audioFeatures, currentParams) {
            const adjustments = {};
            const { energy, beat, tempo, dominantFreq } = audioFeatures;
            
            // Predict linearBoost adjustment
            if (energy > 0.7 && currentParams.linearBoost < 0.8) {
                adjustments.linearBoost = {
                    suggested: Math.min(1.0, currentParams.linearBoost + 0.2),
                    confidence: energy * 0.8,
                    reason: 'High energy detected - boost linear response'
                };
            } else if (energy < 0.3 && currentParams.linearBoost > 0.3) {
                adjustments.linearBoost = {
                    suggested: Math.max(0.1, currentParams.linearBoost - 0.2),
                    confidence: (1 - energy) * 0.8,
                    reason: 'Low energy detected - reduce linear boost'
                };
            }

            // Predict gradient adjustment
            if (beat && currentParams.gradient < 0.8) {
                adjustments.gradient = {
                    suggested: Math.min(1.0, currentParams.gradient + 0.15),
                    confidence: 0.7,
                    reason: 'Beat detected - enhance gradient response'
                };
            }

            // Predict smoothing adjustment based on tempo
            if (tempo > 120 && currentParams.smoothing > 0.3) {
                adjustments.smoothing = {
                    suggested: Math.max(0.1, currentParams.smoothing - 0.1),
                    confidence: 0.6,
                    reason: 'High tempo - reduce smoothing for responsiveness'
                };
            } else if (tempo < 80 && currentParams.smoothing < 0.7) {
                adjustments.smoothing = {
                    suggested: Math.min(0.9, currentParams.smoothing + 0.1),
                    confidence: 0.6,
                    reason: 'Low tempo - increase smoothing for smoothness'
                };
            }

            return adjustments;
        }

        // Predict optimal timing for changes
        predictOptimalTiming(audioFeatures) {
            const { beat, energy, tempo } = audioFeatures;
            
            // Prefer timing changes on beats
            if (beat) {
                return {
                    immediate: true,
                    confidence: 0.9,
                    reason: 'Beat detected - optimal timing for change'
                };
            }

            // For high energy, immediate changes are usually good
            if (energy > 0.7) {
                return {
                    immediate: true,
                    confidence: 0.7,
                    reason: 'High energy - immediate change recommended'
                };
            }

            // For low energy, wait for a better moment
            return {
                immediate: false,
                confidence: 0.6,
                reason: 'Low energy - waiting for better timing',
                delay: 2000 // Wait 2 seconds
            };
        }

        // Analyze how effective a mode is for current audio context
        analyzeModeEffectiveness(mode, audioFeatures) {
            const { energy, beat, tempo, dominantFreq } = audioFeatures;
            let effectiveness = 0.5; // Base effectiveness

            // Mode-specific effectiveness analysis
            switch (mode) {
                case 0: // Spectrum/Bars
                    effectiveness = energy * 0.8 + (beat ? 0.2 : 0);
                    break;
                case 1: // Mirror Wave
                    effectiveness = (1 - energy) * 0.7 + (tempo > 100 ? 0.3 : 0);
                    break;
                case 2: // Classic LED
                    effectiveness = beat ? 0.9 : 0.4;
                    break;
                case 3: // Stereo
                    effectiveness = 0.6 + (dominantFreq > 0.5 ? 0.3 : 0);
                    break;
                case 4: // Radial Spectrum
                    effectiveness = energy * 0.9 + (beat ? 0.1 : 0);
                    break;
                case 5: // Energy
                    effectiveness = energy * 1.0;
                    break;
                case 6: // Mirror
                    effectiveness = (1 - energy) * 0.8 + (tempo < 80 ? 0.2 : 0);
                    break;
                case 7: // Kaleidoscope
                    effectiveness = energy * 0.7 + (beat ? 0.3 : 0);
                    break;
            }

            return Math.min(1.0, effectiveness);
        }

        // Get mode suggestions based on audio context
        getContextualModeSuggestions(audioFeatures) {
            const { energy, beat, tempo, dominantFreq } = audioFeatures;
            const suggestions = [];

            // High energy contexts
            if (energy > 0.7) {
                suggestions.push(0, 4, 5, 7); // Spectrum, Radial, Energy, Kaleidoscope
            }

            // Beat-heavy contexts
            if (beat) {
                suggestions.push(0, 2, 4, 5); // Spectrum, LED, Radial, Energy
            }

            // Low energy contexts
            if (energy < 0.3) {
                suggestions.push(1, 6); // Mirror Wave, Mirror
            }

            // High tempo contexts
            if (tempo > 120) {
                suggestions.push(0, 2, 4); // Spectrum, LED, Radial
            }

            // Low tempo contexts
            if (tempo < 80) {
                suggestions.push(1, 6, 7); // Mirror Wave, Mirror, Kaleidoscope
            }

            // Remove duplicates and return
            return [...new Set(suggestions)];
        }

        // Get reason for mode change suggestion
        getModeChangeReason(suggestedMode, audioFeatures) {
            const { energy, beat, tempo } = audioFeatures;
            
            if (!suggestedMode) return 'No change needed';
            
            const modeNames = {
                0: 'Spectrum', 1: 'Mirror Wave', 2: 'LED', 3: 'Stereo',
                4: 'Radial', 5: 'Energy', 6: 'Mirror', 7: 'Kaleidoscope'
            };

            let reason = `Switch to ${modeNames[suggestedMode]}`;
            
            if (energy > 0.7) reason += ' for high energy';
            else if (beat) reason += ' for beat response';
            else if (tempo > 120) reason += ' for high tempo';
            else if (tempo < 80) reason += ' for low tempo';
            
            return reason;
        }

        // Predict timing for mode changes
        predictModeChangeTiming(audioFeatures) {
            const { beat, energy } = audioFeatures;
            
            if (beat) return 'immediate';
            if (energy > 0.6) return 'soon';
            return 'wait';
        }

        // Calculate overall prediction confidence
        calculatePredictionConfidence(predictions, audioFeatures) {
            let totalConfidence = 0;
            let count = 0;

            if (predictions.modeChange && predictions.modeChange.confidence > 0) {
                totalConfidence += predictions.modeChange.confidence;
                count++;
            }

            if (predictions.parameterAdjustment && Object.keys(predictions.parameterAdjustment).length > 0) {
                const paramConfidences = Object.values(predictions.parameterAdjustment).map(p => p.confidence);
                totalConfidence += paramConfidences.reduce((a, b) => a + b, 0) / paramConfidences.length;
                count++;
            }

            if (predictions.timing && predictions.timing.confidence > 0) {
                totalConfidence += predictions.timing.confidence;
                count++;
            }

            return count > 0 ? totalConfidence / count : 0;
        }

        // Record prediction for learning
        recordPrediction(predictions, audioFeatures) {
            this.predictionHistory.push({
                timestamp: Date.now(),
                predictions,
                audioFeatures,
                executed: false
            });

            // Keep only last 100 predictions
            if (this.predictionHistory.length > 100) {
                this.predictionHistory.shift();
            }

            this.savePredictionData();
        }

        // Execute a prediction
        executePrediction(prediction) {
            try {
                // Execute mode change if suggested
                if (prediction.modeChange && prediction.modeChange.suggested !== null) {
                    this.autopilot.visualizer.setVisualizationMode(prediction.modeChange.suggested);
                    console.log(`🎯 Predictive mode change: ${prediction.modeChange.reason}`);
                }

                // Execute parameter adjustments
                if (prediction.parameterAdjustment) {
                    for (const [param, adjustment] of Object.entries(prediction.parameterAdjustment)) {
                        if (adjustment.confidence > 0.6) {
                            this.autopilot.visualizer.audioMotion[param] = adjustment.suggested;
                            console.log(`🎯 Predictive parameter adjustment: ${param} = ${adjustment.suggested} (${adjustment.reason})`);
                        }
                    }
                }

                // Mark as executed
                prediction.executed = true;
                this.updatePredictionAccuracy();

            } catch (error) {
                console.error('Error executing prediction:', error);
            }
        }

        // Update prediction accuracy based on user feedback
        updatePredictionAccuracy() {
            const recentPredictions = this.predictionHistory.slice(-20);
            const executedPredictions = recentPredictions.filter(p => p.executed);
            
            if (executedPredictions.length > 0) {
                // Simple accuracy calculation - could be enhanced with user feedback
                this.predictionAccuracy = executedPredictions.length / recentPredictions.length;
            }
        }

        // Get prediction analytics
        getPredictionAnalytics() {
            const totalPredictions = this.predictionHistory.length;
            const executedPredictions = this.predictionHistory.filter(p => p.executed).length;
            const recentAccuracy = this.predictionAccuracy * 100;

            return {
                totalPredictions,
                executedPredictions,
                accuracy: Math.round(recentAccuracy),
                confidence: Math.round(this.confidenceThreshold * 100)
            };
        }

        // Load prediction data from localStorage
        loadPredictionData() {
            try {
                const data = localStorage.getItem('autopilot_predictions');
                if (data) {
                    const parsed = JSON.parse(data);
                    this.predictionHistory = parsed.predictionHistory || [];
                    this.predictionAccuracy = parsed.predictionAccuracy || 0;
                }
            } catch (error) {
                console.error('Error loading prediction data:', error);
            }
        }

        // Save prediction data to localStorage
        savePredictionData() {
            try {
                const data = {
                    predictionHistory: this.predictionHistory.slice(-50), // Keep last 50
                    predictionAccuracy: this.predictionAccuracy
                };
                localStorage.setItem('autopilot_predictions', JSON.stringify(data));
            } catch (error) {
                console.error('Error saving prediction data:', error);
            }
        }
    }

    // Multi-layered Intelligence System for AI Autopilot
    class MultiLayeredIntelligenceSystem {
        constructor(autopilot) {
            this.autopilot = autopilot;
            this.decisionLayers = {
                reactive: new ReactiveDecisionLayer(autopilot),
                predictive: new PredictiveDecisionLayer(autopilot),
                strategic: new StrategicDecisionLayer(autopilot)
            };
            this.metaLearning = new MetaLearningSystem(autopilot);
            this.conflictResolver = new ConflictResolver(autopilot);
            this.contextAnalyzer = new ContextAnalyzer(autopilot);
            
            this.decisionHistory = [];
            this.performanceMetrics = {};
            this.learningEnabled = true;
            
            this.loadIntelligenceData();
        }

        // Main decision-making orchestrator
        makeIntelligentDecision(audioFeatures, currentMode, currentParams) {
            try {
                // Check scope constraints first
                if (this.autopilot.scope === 'radial' || this.autopilot.scope === 'energy') {
                    const expectedMode = this.autopilot.scope === 'radial' ? 4 : 5;
                    if (currentMode !== expectedMode) {
                        console.log(`🧠 Multi-layer scope enforcement: Switching to ${this.autopilot.scope} mode (${expectedMode})`);
                        return {
                            action: 'mode_change',
                            mode: expectedMode,
                            confidence: 1.0,
                            sourceLayer: 'scope_enforcement',
                            reason: `Scope enforcement: ${this.autopilot.scope} mode required`
                        };
                    }
                    // If already in correct mode, only allow parameter adjustments
                    return this.makeScopeConstrainedDecision(audioFeatures, currentMode, currentParams);
                }
                
                // Analyze current context
                const context = this.contextAnalyzer.analyzeContext(audioFeatures, currentMode, currentParams);
                
                // Get decisions from each layer
                const layerDecisions = this.getLayerDecisions(context, audioFeatures, currentMode, currentParams);
                
                // Resolve conflicts between layers
                const resolvedDecision = this.conflictResolver.resolveConflicts(layerDecisions, context);
                
                // Apply meta-learning to improve decision quality
                const finalDecision = this.metaLearning.enhanceDecision(resolvedDecision, context);
                
                // Execute the decision
                this.executeDecision(finalDecision, context);
                
                // Learn from the outcome
                if (this.learningEnabled) {
                    this.learnFromDecision(finalDecision, context);
                }
                
                // Record decision for analysis
                this.recordDecision(finalDecision, context);
                
                return finalDecision;
                
            } catch (error) {
                console.error('Error in multi-layered intelligence:', error);
                return null;
            }
        }

        // Make decisions when scope is constrained to specific modes
        makeScopeConstrainedDecision(audioFeatures, currentMode, currentParams) {
            const { energy, beat, tempo, dominantFreq } = audioFeatures;
            
            // Only allow parameter adjustments for constrained scopes
            if (beat && energy > 0.5) {
                return {
                    action: 'parameter_adjustment',
                    parameters: {
                        linearBoost: Math.min(5.0, (this.autopilot.visualizer.audioMotion.linearBoost || 1.0) + 2.0),
                        gradient: Math.min(1.0, (this.autopilot.visualizer.audioMotion.gradient || 0.5) + 0.4),
                        fillAlpha: Math.min(1.0, (this.autopilot.visualizer.audioMotion.fillAlpha || 0.5) + 0.3),
                        volume: Math.min(3.0, (this.autopilot.visualizer.audioMotion.volume || 1.0) + 1.0),
                        peakHoldTime: Math.max(100, (this.autopilot.visualizer.audioMotion.peakHoldTime || 500) - 200)
                    },
                    confidence: 0.8,
                    sourceLayer: 'scope_constrained',
                    reason: 'Beat detected - enhancing parameters for constrained scope'
                };
            }
            
            if (energy > 0.8) {
                return {
                    action: 'parameter_adjustment',
                    parameters: {
                        linearBoost: Math.min(8.0, (this.autopilot.visualizer.audioMotion.linearBoost || 1.0) + 4.0),
                        gradient: Math.min(1.0, (this.autopilot.visualizer.audioMotion.gradient || 0.5) + 0.5),
                        fillAlpha: Math.min(1.0, (this.autopilot.visualizer.audioMotion.fillAlpha || 0.5) + 0.4),
                        volume: Math.min(5.0, (this.autopilot.visualizer.audioMotion.volume || 1.0) + 2.0),
                        smoothing: Math.max(0.1, (this.autopilot.visualizer.audioMotion.smoothing || 0.5) - 0.3),
                        peakHoldTime: Math.max(50, (this.autopilot.visualizer.audioMotion.peakHoldTime || 500) - 300)
                    },
                    confidence: 0.9,
                    sourceLayer: 'scope_constrained',
                    reason: 'High energy - maximizing parameters for constrained scope'
                };
            }
            
            if (energy < 0.3) {
                return {
                    action: 'parameter_adjustment',
                    parameters: {
                        smoothing: Math.min(0.9, (this.autopilot.visualizer.audioMotion.smoothing || 0.5) + 0.4),
                        fillAlpha: Math.max(0.1, (this.autopilot.visualizer.audioMotion.fillAlpha || 0.5) - 0.4),
                        linearBoost: Math.max(0.5, (this.autopilot.visualizer.audioMotion.linearBoost || 1.0) - 0.5),
                        volume: Math.max(0.5, (this.autopilot.visualizer.audioMotion.volume || 1.0) - 0.3),
                        peakHoldTime: Math.min(1000, (this.autopilot.visualizer.audioMotion.peakHoldTime || 500) + 300)
                    },
                    confidence: 0.7,
                    sourceLayer: 'scope_constrained',
                    reason: 'Low energy - smoothing parameters for constrained scope'
                };
            }
            
            // Add video effects for more dramatic changes
            if (energy > 0.6 && this.autopilot.videoEffectsEnabled) {
                return {
                    action: 'video_adjustment',
                    videoParameters: {
                        colorEffects: {
                            brightness: 1.0 + (energy * 0.5),
                            contrast: 1.0 + (energy * 0.3),
                            saturation: 1.0 + (energy * 0.4),
                            hue: energy * 30
                        }
                    },
                    confidence: 0.8,
                    sourceLayer: 'scope_constrained',
                    reason: 'High energy - applying video effects for constrained scope'
                };
            }
            
            return {
                action: 'no_action',
                confidence: 0.5,
                sourceLayer: 'scope_constrained',
                reason: 'No parameter adjustment needed for constrained scope'
            };
        }

        // Get decisions from all layers
        getLayerDecisions(context, audioFeatures, currentMode, currentParams) {
            const decisions = {};
            
            // Reactive layer - immediate responses
            decisions.reactive = this.decisionLayers.reactive.makeDecision(context, audioFeatures);
            
            // Predictive layer - future-focused decisions
            decisions.predictive = this.decisionLayers.predictive.makeDecision(context, audioFeatures);
            
            // Strategic layer - long-term optimization
            decisions.strategic = this.decisionLayers.strategic.makeDecision(context, audioFeatures);
            
            return decisions;
        }

        // Execute the final decision
        executeDecision(decision, context) {
            if (!decision || !decision.action) return;
            
            try {
                switch (decision.action) {
                    case 'mode_change':
                        if (decision.mode !== undefined) {
                            this.autopilot.visualizer.setVisualizationMode(decision.mode);
                            console.log(`🧠 Multi-layer decision: Mode change to ${decision.mode}`);
                        }
                        break;
                        
                    case 'parameter_adjustment':
                        if (decision.parameters) {
                            this.applyParameterAdjustments(decision.parameters);
                            console.log(`🧠 Multi-layer decision: Parameter adjustments applied`);
                        }
                        break;
                        
                    case 'video_adjustment':
                        if (decision.videoParameters && this.autopilot.videoEffectsEnabled) {
                            this.applyVideoAdjustments(decision.videoParameters);
                            console.log(`🧠 Multi-layer decision: Video adjustments applied`);
                        }
                        break;
                        
                    case 'timing_adjustment':
                        if (decision.timing) {
                            this.adjustTiming(decision.timing);
                            console.log(`🧠 Multi-layer decision: Timing adjusted`);
                        }
                        break;
                        
                    case 'no_action':
                        console.log(`🧠 Multi-layer decision: No action needed`);
                        break;
                }
            } catch (error) {
                console.error('Error executing multi-layer decision:', error);
            }
        }

        // Apply parameter adjustments
        applyParameterAdjustments(parameters) {
            if (!this.autopilot.visualizer.audioMotion) {
                console.log('🧠 No audioMotion available for parameter adjustment');
                return;
            }
            
            console.log('🧠 Applying parameters:', parameters);
            console.log('🧠 Before - audioMotion params:', {
                linearBoost: this.autopilot.visualizer.audioMotion.linearBoost,
                gradient: this.autopilot.visualizer.audioMotion.gradient,
                fillAlpha: this.autopilot.visualizer.audioMotion.fillAlpha,
                smoothing: this.autopilot.visualizer.audioMotion.smoothing
            });
            
            try {
                // Use setOptions to properly apply parameter changes
                this.autopilot.visualizer.audioMotion.setOptions(parameters);
                console.log('🧠 Multi-layer parameters applied via setOptions:', parameters);
                
                // Force a redraw to ensure changes are visible
                if (this.autopilot.visualizer.audioMotion.ctx) {
                    this.autopilot.visualizer.audioMotion.ctx.clearRect(0, 0, 
                        this.autopilot.visualizer.audioMotion.canvas.width, 
                        this.autopilot.visualizer.audioMotion.canvas.height);
                }
                
                // Verify the parameters were actually set
                setTimeout(() => {
                    console.log('🧠 After - audioMotion params:', {
                        linearBoost: this.autopilot.visualizer.audioMotion.linearBoost,
                        gradient: this.autopilot.visualizer.audioMotion.gradient,
                        fillAlpha: this.autopilot.visualizer.audioMotion.fillAlpha,
                        smoothing: this.autopilot.visualizer.audioMotion.smoothing
                    });
                }, 100);
                
            } catch (error) {
                console.error('Error applying multi-layer parameters via setOptions:', error);
                // Fallback to direct property setting
                console.log('🧠 Falling back to direct property setting');
                for (const [param, value] of Object.entries(parameters)) {
                    if (this.autopilot.visualizer.audioMotion.hasOwnProperty(param)) {
                        this.autopilot.visualizer.audioMotion[param] = value;
                        console.log(`🧠 Set ${param} = ${value}`);
                    } else {
                        console.log(`🧠 Property ${param} not found on audioMotion`);
                    }
                }
            }
        }

        // Apply video adjustments
        applyVideoAdjustments(videoParameters) {
            if (!this.autopilot.parameterController) return;
            
            try {
                this.autopilot.parameterController.applyVideoParameters(videoParameters);
                console.log('🧠 Multi-layer video parameters applied:', videoParameters);
            } catch (error) {
                console.error('Error applying multi-layer video parameters:', error);
            }
        }

        // Adjust timing settings
        adjustTiming(timing) {
            if (timing.cooldown) {
                this.autopilot.decisionEngine.decisionCooldown = timing.cooldown;
            }
            if (timing.sensitivity) {
                this.autopilot.sensitivity = timing.sensitivity;
            }
        }

        // Learn from decision outcomes
        learnFromDecision(decision, context) {
            this.metaLearning.learnFromOutcome(decision, context);
            this.updatePerformanceMetrics(decision, context);
        }

        // Record decision for analysis
        recordDecision(decision, context) {
            this.decisionHistory.push({
                timestamp: Date.now(),
                decision,
                context,
                executed: true
            });
            
            // Keep only last 100 decisions
            if (this.decisionHistory.length > 100) {
                this.decisionHistory.shift();
            }
        }

        // Update performance metrics
        updatePerformanceMetrics(decision, context) {
            const layer = decision.sourceLayer || 'unknown';
            if (!this.performanceMetrics[layer]) {
                this.performanceMetrics[layer] = {
                    totalDecisions: 0,
                    successfulDecisions: 0,
                    averageConfidence: 0
                };
            }
            
            this.performanceMetrics[layer].totalDecisions++;
            if (decision.confidence > 0.7) {
                this.performanceMetrics[layer].successfulDecisions++;
            }
            
            // Update average confidence
            const current = this.performanceMetrics[layer];
            current.averageConfidence = (current.averageConfidence * (current.totalDecisions - 1) + decision.confidence) / current.totalDecisions;
        }

        // Get intelligence analytics
        getIntelligenceAnalytics() {
            const totalDecisions = this.decisionHistory.length;
            const layerPerformance = {};
            
            for (const [layer, metrics] of Object.entries(this.performanceMetrics)) {
                layerPerformance[layer] = {
                    successRate: metrics.totalDecisions > 0 ? 
                        (metrics.successfulDecisions / metrics.totalDecisions * 100).toFixed(1) : 0,
                    averageConfidence: metrics.averageConfidence.toFixed(2),
                    totalDecisions: metrics.totalDecisions
                };
            }
            
            return {
                totalDecisions,
                layerPerformance,
                metaLearningProgress: this.metaLearning.getLearningProgress()
            };
        }

        // Load intelligence data
        loadIntelligenceData() {
            try {
                const data = localStorage.getItem('autopilot_intelligence');
                if (data) {
                    const parsed = JSON.parse(data);
                    this.decisionHistory = parsed.decisionHistory || [];
                    this.performanceMetrics = parsed.performanceMetrics || {};
                }
            } catch (error) {
                console.error('Error loading intelligence data:', error);
            }
        }

        // Save intelligence data
        saveIntelligenceData() {
            try {
                const data = {
                    decisionHistory: this.decisionHistory.slice(-50),
                    performanceMetrics: this.performanceMetrics
                };
                localStorage.setItem('autopilot_intelligence', JSON.stringify(data));
            } catch (error) {
                console.error('Error saving intelligence data:', error);
            }
        }
    }

    // Reactive Decision Layer - Immediate responses
    class ReactiveDecisionLayer {
        constructor(autopilot) {
            this.autopilot = autopilot;
            this.responseThreshold = 0.8;
        }

        makeDecision(context, audioFeatures) {
            const { energy, beat, tempo, dominantFreq } = audioFeatures;
            
            // High energy immediate response
            if (energy > 0.8) {
                return {
                    action: 'mode_change',
                    mode: this.getHighEnergyMode(context),
                    confidence: energy,
                    sourceLayer: 'reactive',
                    reason: 'High energy detected - immediate response needed'
                };
            }
            
            // Beat detection response
            if (beat && energy > 0.5) {
                return {
                    action: 'parameter_adjustment',
                    parameters: {
                        linearBoost: Math.min(1.0, this.autopilot.visualizer.audioMotion.linearBoost + 0.2),
                        gradient: Math.min(1.0, this.autopilot.visualizer.audioMotion.gradient + 0.15)
                    },
                    confidence: 0.9,
                    sourceLayer: 'reactive',
                    reason: 'Beat detected - enhancing responsiveness'
                };
            }
            
            // Low energy response
            if (energy < 0.2) {
                return {
                    action: 'parameter_adjustment',
                    parameters: {
                        smoothing: Math.min(0.9, this.autopilot.visualizer.audioMotion.smoothing + 0.1),
                        fillAlpha: Math.max(0.1, this.autopilot.visualizer.audioMotion.fillAlpha - 0.1)
                    },
                    confidence: 0.8,
                    sourceLayer: 'reactive',
                    reason: 'Low energy - smoothing response'
                };
            }
            
            return {
                action: 'no_action',
                confidence: 0.5,
                sourceLayer: 'reactive',
                reason: 'No immediate response needed'
            };
        }

        getHighEnergyMode(context) {
            const highEnergyModes = [0, 4, 5, 7]; // Spectrum, Radial, Energy, Kaleidoscope
            return highEnergyModes[Math.floor(Math.random() * highEnergyModes.length)];
        }
    }

    // Predictive Decision Layer - Future-focused decisions
    class PredictiveDecisionLayer {
        constructor(autopilot) {
            this.autopilot = autopilot;
            this.predictionWindow = 5000; // 5 seconds ahead
        }

        makeDecision(context, audioFeatures) {
            // Use existing predictive behavior system
            if (this.autopilot.predictiveBehavior) {
                const predictions = this.autopilot.predictiveBehavior.predictOptimalActions(
                    audioFeatures,
                    this.autopilot.visualizer.currentMode,
                    this.autopilot.getCurrentParameters()
                );
                
                if (predictions && predictions.confidence >= 0.8) {
                    return {
                        action: predictions.modeChange ? 'mode_change' : 'parameter_adjustment',
                        mode: predictions.modeChange?.suggested,
                        parameters: predictions.parameterAdjustment,
                        confidence: predictions.confidence,
                        sourceLayer: 'predictive',
                        reason: predictions.modeChange?.reason || 'Predictive parameter optimization'
                    };
                }
            }
            
            return {
                action: 'no_action',
                confidence: 0.3,
                sourceLayer: 'predictive',
                reason: 'No high-confidence predictions available'
            };
        }
    }

    // Strategic Decision Layer - Long-term optimization
    class StrategicDecisionLayer {
        constructor(autopilot) {
            this.autopilot = autopilot;
            this.optimizationHorizon = 30000; // 30 seconds
        }

        makeDecision(context, audioFeatures) {
            // Use adaptive tuning for strategic decisions
            if (this.autopilot.adaptiveTuning) {
                const tuningAnalytics = this.autopilot.adaptiveTuning.getOptimizationAnalytics();
                
                if (tuningAnalytics.currentPerformance < 0.6) {
                    return {
                        action: 'parameter_adjustment',
                        parameters: this.getStrategicOptimizations(context),
                        confidence: 0.7,
                        sourceLayer: 'strategic',
                        reason: 'Strategic optimization needed - performance below threshold'
                    };
                }
            }
            
            // Use pattern learning for strategic decisions
            if (this.autopilot.patternLearning) {
                const recommendations = this.autopilot.patternLearning.getPatternRecommendations(
                    context.genre || 'unknown',
                    audioFeatures
                );
                
                if (recommendations && recommendations.confidence > 0.6) {
                    return {
                        action: 'parameter_adjustment',
                        parameters: recommendations.parameters,
                        confidence: recommendations.confidence,
                        sourceLayer: 'strategic',
                        reason: 'Strategic pattern-based optimization'
                    };
                }
            }
            
            return {
                action: 'no_action',
                confidence: 0.4,
                sourceLayer: 'strategic',
                reason: 'No strategic optimization needed'
            };
        }

        getStrategicOptimizations(context) {
            // Strategic parameter adjustments based on context
            const optimizations = {};
            
            if (context.energy > 0.7) {
                optimizations.linearBoost = 0.8;
                optimizations.gradient = 0.7;
            } else if (context.energy < 0.3) {
                optimizations.smoothing = 0.8;
                optimizations.fillAlpha = 0.3;
            }
            
            return optimizations;
        }
    }

    // Context Analyzer - Determines decision context
    class ContextAnalyzer {
        constructor(autopilot) {
            this.autopilot = autopilot;
        }

        analyzeContext(audioFeatures, currentMode, currentParams) {
            const { energy, beat, tempo, dominantFreq } = audioFeatures;
            
            return {
                energy: energy,
                beat: beat,
                tempo: tempo,
                dominantFreq: dominantFreq,
                currentMode: currentMode,
                currentParams: currentParams,
                genre: this.autopilot.genreDetector?.detectedGenre?.genre || 'unknown',
                timeOfDay: this.getTimeOfDay(),
                sessionDuration: this.getSessionDuration(),
                userEngagement: this.getUserEngagement(),
                systemLoad: this.getSystemLoad()
            };
        }

        getTimeOfDay() {
            const hour = new Date().getHours();
            if (hour < 6) return 'night';
            if (hour < 12) return 'morning';
            if (hour < 18) return 'afternoon';
            return 'evening';
        }

        getSessionDuration() {
            return Date.now() - (this.autopilot.sessionStartTime || Date.now());
        }

        getUserEngagement() {
            // Calculate based on recent user interactions
            const recentFeedback = this.autopilot.parameterController?.feedbackHistory?.slice(-10) || [];
            return recentFeedback.length > 0 ? 'high' : 'low';
        }

        getSystemLoad() {
            // Simple system load estimation
            return this.autopilot.decisionHistory?.length > 50 ? 'high' : 'low';
        }
    }

    // Conflict Resolver - Resolves disagreements between layers
    class ConflictResolver {
        constructor(autopilot) {
            this.autopilot = autopilot;
            this.layerPriorities = {
                reactive: 1,    // Highest priority for immediate responses
                predictive: 2,  // Medium priority for predictions
                strategic: 3    // Lowest priority for long-term planning
            };
        }

        resolveConflicts(layerDecisions, context) {
            const validDecisions = Object.entries(layerDecisions)
                .filter(([layer, decision]) => decision.action !== 'no_action')
                .map(([layer, decision]) => ({ ...decision, layer }));
            
            if (validDecisions.length === 0) {
                return { action: 'no_action', confidence: 0.5, sourceLayer: 'conflict_resolver' };
            }
            
            if (validDecisions.length === 1) {
                return validDecisions[0];
            }
            
            // Resolve conflicts based on priority and confidence
            const sortedDecisions = validDecisions.sort((a, b) => {
                const priorityA = this.layerPriorities[a.sourceLayer] || 999;
                const priorityB = this.layerPriorities[b.sourceLayer] || 999;
                
                if (priorityA !== priorityB) {
                    return priorityA - priorityB; // Lower number = higher priority
                }
                
                return b.confidence - a.confidence; // Higher confidence wins
            });
            
            const winningDecision = sortedDecisions[0];
            
            // Merge compatible decisions
            const mergedDecision = this.mergeCompatibleDecisions(sortedDecisions);
            
            return {
                ...winningDecision,
                mergedFrom: sortedDecisions.map(d => d.sourceLayer),
                reason: `Resolved conflict between ${sortedDecisions.map(d => d.sourceLayer).join(', ')}`
            };
        }

        mergeCompatibleDecisions(decisions) {
            const merged = { ...decisions[0] };
            
            // Merge parameter adjustments
            const parameterDecisions = decisions.filter(d => d.action === 'parameter_adjustment');
            if (parameterDecisions.length > 1) {
                merged.parameters = {};
                parameterDecisions.forEach(decision => {
                    if (decision.parameters) {
                        Object.assign(merged.parameters, decision.parameters);
                    }
                });
            }
            
            return merged;
        }
    }

    // Meta-Learning System - Learns how to learn better
    class MetaLearningSystem {
        constructor(autopilot) {
            this.autopilot = autopilot;
            this.learningHistory = [];
            this.effectivenessScores = {};
            this.learningProgress = 0;
        }

        enhanceDecision(decision, context) {
            // Apply meta-learning insights to improve decision
            const enhancedDecision = { ...decision };
            
            // Adjust confidence based on historical effectiveness
            if (this.effectivenessScores[decision.sourceLayer]) {
                const effectiveness = this.effectivenessScores[decision.sourceLayer];
                enhancedDecision.confidence *= effectiveness;
            }
            
            // Add meta-learning insights
            enhancedDecision.metaInsights = this.getMetaInsights(context);
            
            return enhancedDecision;
        }

        learnFromOutcome(decision, context) {
            // Learn from decision outcomes to improve future decisions
            this.learningHistory.push({
                timestamp: Date.now(),
                decision,
                context,
                outcome: null // Will be updated when outcome is known
            });
            
            // Update effectiveness scores
            this.updateEffectivenessScores(decision);
            
            // Update learning progress
            this.updateLearningProgress();
        }

        updateEffectivenessScores(decision) {
            const layer = decision.sourceLayer;
            if (!this.effectivenessScores[layer]) {
                this.effectivenessScores[layer] = 0.5;
            }
            
            // Simple effectiveness calculation based on confidence
            const effectiveness = decision.confidence > 0.8 ? 1.0 : decision.confidence;
            this.effectivenessScores[layer] = (this.effectivenessScores[layer] + effectiveness) / 2;
        }

        updateLearningProgress() {
            const totalDecisions = this.learningHistory.length;
            const effectiveDecisions = this.learningHistory.filter(h => h.decision.confidence > 0.7).length;
            
            this.learningProgress = totalDecisions > 0 ? (effectiveDecisions / totalDecisions) * 100 : 0;
        }

        getMetaInsights(context) {
            const insights = [];
            
            if (context.userEngagement === 'high') {
                insights.push('High user engagement - prioritize user preferences');
            }
            
            if (context.systemLoad === 'high') {
                insights.push('High system load - use conservative decisions');
            }
            
            if (context.sessionDuration > 300000) { // 5 minutes
                insights.push('Long session - consider variety in decisions');
            }
            
            return insights;
        }

        getLearningProgress() {
            return {
                progress: Math.round(this.learningProgress),
                totalDecisions: this.learningHistory.length,
                effectivenessScores: { ...this.effectivenessScores }
            };
        }
    }

    // Adaptive Parameter Tuning System for AI Autopilot
    class AdaptiveTuningSystem {
        constructor(autopilot) {
            this.autopilot = autopilot;
            this.tuningData = this.loadTuningData();
            this.performanceHistory = this.tuningData.performanceHistory || [];
            this.optimizationTargets = this.tuningData.optimizationTargets || {};
            this.abTests = this.tuningData.abTests || [];
            
            // Tuning configuration
            this.optimizationInterval = 30000; // 30 seconds between optimizations
            this.minSamplesForOptimization = 10;
            this.maxOptimizationHistory = 500;
            this.learningRate = 0.1;
            this.explorationRate = 0.2; // 20% chance to try new parameters
            
            // Performance tracking
            this.currentPerformance = 0;
            this.performanceWindow = [];
            this.lastOptimization = 0;
            
            console.log('🎯 Adaptive Tuning System initialized');
        }
        
        // Track performance of current parameters
        trackPerformance(audioFeatures, userFeedback = null) {
            const performance = this.calculatePerformance(audioFeatures, userFeedback);
            
            this.performanceWindow.push({
                performance: performance,
                timestamp: Date.now(),
                audioFeatures: { ...audioFeatures },
                userFeedback: userFeedback
            });
            
            // Keep only recent performance data (last 100 samples)
            if (this.performanceWindow.length > 100) {
                this.performanceWindow = this.performanceWindow.slice(-100);
            }
            
            this.currentPerformance = performance;
            
            // Check if we should optimize
            if (this.shouldOptimize()) {
                this.optimizeParameters();
            }
        }
        
        // Calculate performance score based on audio and user feedback
        calculatePerformance(audioFeatures, userFeedback) {
            let score = 0;
            
            // Audio-based performance (60% weight)
            const energy = audioFeatures.energy || 0;
            const beat = audioFeatures.beat || false;
            const tempo = audioFeatures.tempo || 0;
            
            score += energy * 0.3; // Energy response
            if (beat) score += 0.2; // Beat detection
            score += Math.min(tempo / 200, 0.1); // Tempo stability
            
            // User feedback (40% weight)
            if (userFeedback === 'positive') {
                score += 0.4;
            } else if (userFeedback === 'negative') {
                score -= 0.2;
            }
            
            // Smooth the score
            return Math.max(0, Math.min(1, score));
        }
        
        // Check if we should run optimization
        shouldOptimize() {
            const now = Date.now();
            const hasEnoughSamples = this.performanceWindow.length >= this.minSamplesForOptimization;
            const enoughTimePassed = now - this.lastOptimization > this.optimizationInterval;
            
            return hasEnoughSamples && enoughTimePassed;
        }
        
        // Optimize parameters based on performance history
        optimizeParameters(forced = false) {
            try {
                console.log('🎯 Starting parameter optimization...', forced ? '(FORCED)' : '');
                
                // Analyze current performance trends
                const performanceAnalysis = this.analyzePerformance();
                
                // Get current parameters
                const currentParams = this.getCurrentParameters();
                console.log('🎯 Current parameters:', currentParams);
                
                // Generate optimization suggestions
                const optimizations = this.generateOptimizations(currentParams, performanceAnalysis, forced);
                console.log('🎯 Generated optimizations:', optimizations);
                
                // Apply optimizations
                this.applyOptimizations(optimizations);
                
                // Record optimization
                this.recordOptimization(optimizations, performanceAnalysis);
                
                this.lastOptimization = Date.now();
                
                console.log('🎯 Parameter optimization completed');
                
            } catch (error) {
                console.error('Error in parameter optimization:', error);
            }
        }
        
        // Analyze performance trends
        analyzePerformance() {
            if (this.performanceWindow.length < 5) {
                return { trend: 'stable', avgPerformance: 0.5 };
            }
            
            const recent = this.performanceWindow.slice(-10);
            const older = this.performanceWindow.slice(-20, -10);
            
            const recentAvg = recent.reduce((sum, p) => sum + p.performance, 0) / recent.length;
            const olderAvg = older.length > 0 ? 
                older.reduce((sum, p) => sum + p.performance, 0) / older.length : recentAvg;
            
            const trend = recentAvg > olderAvg + 0.1 ? 'improving' : 
                         recentAvg < olderAvg - 0.1 ? 'declining' : 'stable';
            
            return {
                trend: trend,
                avgPerformance: recentAvg,
                recentPerformance: recentAvg,
                olderPerformance: olderAvg,
                sampleCount: this.performanceWindow.length
            };
        }
        
        // Generate optimization suggestions
        generateOptimizations(currentParams, performanceAnalysis, forced = false) {
            const optimizations = {};
            
            // Define parameter ranges for optimization
            const parameterRanges = {
                linearBoost: { min: 0.5, max: 2.0, step: 0.1 },
                gradient: { min: 0, max: 1, step: 0.1 },
                fillAlpha: { min: 0.1, max: 1, step: 0.1 },
                peakHoldTime: { min: 0, max: 1, step: 0.1 },
                smoothing: { min: 0, max: 1, step: 0.1 },
                maxDecibels: { min: -60, max: -10, step: 5 },
                minFreq: { min: 20, max: 2000, step: 50 }
            };
            
            // Apply different optimization strategies based on performance trend
            Object.keys(parameterRanges).forEach(paramName => {
                const currentValue = currentParams[paramName] || 0.5;
                const range = parameterRanges[paramName];
                
                let newValue = currentValue;
                
                if (forced) {
                    // When forced, always make a change for demonstration
                    newValue = this.exploreParameterSpace(paramName, currentValue, range, 0.2);
                } else if (performanceAnalysis.trend === 'declining') {
                    // Try more aggressive changes when performance is declining
                    newValue = this.exploreParameterSpace(paramName, currentValue, range, 0.3);
                } else if (performanceAnalysis.trend === 'improving') {
                    // Fine-tune when performance is improving
                    newValue = this.fineTuneParameter(paramName, currentValue, range, 0.1);
                } else {
                    // Stable performance - try small improvements
                    newValue = this.exploreParameterSpace(paramName, currentValue, range, 0.15);
                }
                
                // Only change if the difference is significant (or if forced)
                if (forced || Math.abs(newValue - currentValue) > range.step) {
                    optimizations[paramName] = newValue;
                }
            });
            
            return optimizations;
        }
        
        // Explore parameter space for better values
        exploreParameterSpace(paramName, currentValue, range, explorationRate) {
            // 20% chance to try a completely new value
            if (Math.random() < this.explorationRate) {
                return range.min + Math.random() * (range.max - range.min);
            }
            
            // Otherwise, make a small adjustment
            const adjustment = (Math.random() - 0.5) * explorationRate * (range.max - range.min);
            return Math.max(range.min, Math.min(range.max, currentValue + adjustment));
        }
        
        // Fine-tune parameter with small adjustments
        fineTuneParameter(paramName, currentValue, range, tuningRate) {
            const adjustment = (Math.random() - 0.5) * tuningRate * (range.max - range.min);
            return Math.max(range.min, Math.min(range.max, currentValue + adjustment));
        }
        
        // Apply optimizations to the visualizer
        applyOptimizations(optimizations) {
            if (Object.keys(optimizations).length === 0) return;
            
            if (this.autopilot.visualizer.audioMotion) {
                this.autopilot.visualizer.audioMotion.setOptions(optimizations);
                console.log('🎯 Applied optimizations:', optimizations);
            }
        }
        
        // Record optimization for future analysis
        recordOptimization(optimizations, performanceAnalysis) {
            const optimization = {
                timestamp: Date.now(),
                optimizations: { ...optimizations },
                performanceBefore: performanceAnalysis.avgPerformance,
                performanceTrend: performanceAnalysis.trend,
                sampleCount: performanceAnalysis.sampleCount
            };
            
            this.performanceHistory.push(optimization);
            
            // Keep only recent history
            if (this.performanceHistory.length > this.maxOptimizationHistory) {
                this.performanceHistory = this.performanceHistory.slice(-this.maxOptimizationHistory);
            }
            
            // Save tuning data
            this.saveTuningData();
        }
        
        // Get current parameter values
        getCurrentParameters() {
            if (!this.autopilot.visualizer.audioMotion) return {};
            
            // Get parameters from the visualizer's current configuration
            const audioMotion = this.autopilot.visualizer.audioMotion;
            
            return {
                linearBoost: audioMotion.linearBoost || 1.0,
                gradient: audioMotion.gradient || 0.5,
                fillAlpha: audioMotion.fillAlpha || 0.8,
                peakHoldTime: audioMotion.peakHoldTime || 0.5,
                smoothing: audioMotion.smoothing || 0.5,
                maxDecibels: audioMotion.maxDecibels || -30,
                minFreq: audioMotion.minFreq || 20
            };
        }
        
        // Get optimization analytics
        getOptimizationAnalytics() {
            const totalOptimizations = this.performanceHistory.length;
            const recentOptimizations = this.performanceHistory.slice(-10);
            
            const avgPerformance = this.performanceWindow.length > 0 ?
                this.performanceWindow.reduce((sum, p) => sum + p.performance, 0) / this.performanceWindow.length : 0;
            
            const performanceTrend = this.analyzePerformance();
            
            return {
                totalOptimizations: totalOptimizations,
                currentPerformance: avgPerformance,
                performanceTrend: performanceTrend.trend,
                recentOptimizations: recentOptimizations.length,
                optimizationFrequency: totalOptimizations > 0 ? 
                    (Date.now() - this.performanceHistory[0].timestamp) / (totalOptimizations * 1000) : 0
            };
        }
        
        // Data persistence
        loadTuningData() {
            try {
                const saved = localStorage.getItem('autopilot_adaptive_tuning');
                return saved ? JSON.parse(saved) : { 
                    performanceHistory: [], 
                    optimizationTargets: {}, 
                    abTests: [] 
                };
            } catch (error) {
                console.warn('Could not load tuning data:', error);
                return { performanceHistory: [], optimizationTargets: {}, abTests: [] };
            }
        }
        
        saveTuningData() {
            try {
                const data = {
                    performanceHistory: this.performanceHistory,
                    optimizationTargets: this.optimizationTargets,
                    abTests: this.abTests,
                    lastSaved: Date.now()
                };
                localStorage.setItem('autopilot_adaptive_tuning', JSON.stringify(data));
            } catch (error) {
                console.warn('Could not save tuning data:', error);
            }
        }
    }

    // Pattern Learning System for AI Autopilot
    class PatternLearningSystem {
        constructor(autopilot) {
            this.autopilot = autopilot;
            this.learningData = this.loadLearningData();
            this.patterns = this.learningData.patterns || {};
            this.userBehavior = this.learningData.userBehavior || {};
            this.performanceMetrics = this.learningData.performanceMetrics || {};
            
            // Learning configuration
            this.learningRate = 0.1; // How quickly to adapt to new patterns
            this.minSamples = 5; // Minimum samples before making predictions
            this.maxHistory = 1000; // Maximum stored samples per pattern
            
            console.log('🧠 Pattern Learning System initialized');
        }
        
        // Learn from successful parameter combinations
        learnFromSuccess(genre, audioFeatures, parameters, effectiveness) {
            const patternKey = this.getPatternKey(genre, audioFeatures);
            
            if (!this.patterns[patternKey]) {
                this.patterns[patternKey] = {
                    samples: [],
                    successRate: 0,
                    avgEffectiveness: 0,
                    lastUpdated: Date.now()
                };
            }
            
            const pattern = this.patterns[patternKey];
            
            // Add new sample
            pattern.samples.push({
                parameters: { ...parameters },
                effectiveness: effectiveness,
                timestamp: Date.now()
            });
            
            // Keep only recent samples
            if (pattern.samples.length > this.maxHistory) {
                pattern.samples = pattern.samples.slice(-this.maxHistory);
            }
            
            // Update success rate and average effectiveness
            this.updatePatternMetrics(pattern);
            
            // Save learning data
            this.saveLearningData();
            
            console.log(`🧠 Learned pattern for ${patternKey}:`, {
                samples: pattern.samples.length,
                successRate: pattern.successRate.toFixed(3),
                avgEffectiveness: pattern.avgEffectiveness.toFixed(3)
            });
        }
        
        // Get pattern-based parameter recommendations
        getPatternRecommendations(genre, audioFeatures) {
            const patternKey = this.getPatternKey(genre, audioFeatures);
            const pattern = this.patterns[patternKey];
            
            if (!pattern || pattern.samples.length < this.minSamples) {
                return null; // Not enough data for recommendations
            }
            
            // Find most effective parameter combinations
            const effectiveSamples = pattern.samples
                .filter(s => s.effectiveness > pattern.avgEffectiveness)
                .sort((a, b) => b.effectiveness - a.effectiveness)
                .slice(0, 5); // Top 5 most effective
            
            if (effectiveSamples.length === 0) {
                return null;
            }
            
            // Calculate weighted average of effective parameters
            const recommendations = this.calculateWeightedAverage(effectiveSamples);
            
            console.log(`🧠 Pattern recommendations for ${patternKey}:`, recommendations);
            
            return {
                confidence: pattern.successRate,
                parameters: recommendations,
                source: 'pattern_learning'
            };
        }
        
        // Learn from user behavior patterns
        learnFromUserBehavior(action, context, outcome) {
            const behaviorKey = `${action}_${context}`;
            
            if (!this.userBehavior[behaviorKey]) {
                this.userBehavior[behaviorKey] = {
                    totalActions: 0,
                    positiveOutcomes: 0,
                    contexts: [],
                    lastAction: Date.now()
                };
            }
            
            const behavior = this.userBehavior[behaviorKey];
            behavior.totalActions++;
            
            if (outcome === 'positive') {
                behavior.positiveOutcomes++;
            }
            
            behavior.contexts.push({
                context: { ...context },
                outcome: outcome,
                timestamp: Date.now()
            });
            
            // Keep only recent contexts
            if (behavior.contexts.length > 100) {
                behavior.contexts = behavior.contexts.slice(-100);
            }
            
            behavior.lastAction = Date.now();
            
            console.log(`🧠 Learned user behavior: ${behaviorKey}`, {
                totalActions: behavior.totalActions,
                successRate: (behavior.positiveOutcomes / behavior.totalActions).toFixed(3)
            });
        }
        
        // Get user behavior predictions
        predictUserPreference(action, context) {
            const behaviorKey = `${action}_${context}`;
            const behavior = this.userBehavior[behaviorKey];
            
            if (!behavior || behavior.totalActions < 3) {
                return null; // Not enough data
            }
            
            const successRate = behavior.positiveOutcomes / behavior.totalActions;
            
            return {
                action: action,
                context: context,
                predictedPreference: successRate > 0.6 ? 'positive' : 'negative',
                confidence: Math.abs(successRate - 0.5) * 2, // 0-1 confidence
                totalActions: behavior.totalActions
            };
        }
        
        // Helper methods
        getPatternKey(genre, audioFeatures) {
            const energyLevel = audioFeatures.energy > 0.7 ? 'high' : audioFeatures.energy > 0.4 ? 'medium' : 'low';
            const tempoCategory = audioFeatures.tempo > 140 ? 'fast' : audioFeatures.tempo > 100 ? 'medium' : 'slow';
            return `${genre}_${energyLevel}_${tempoCategory}`;
        }
        
        updatePatternMetrics(pattern) {
            if (pattern.samples.length === 0) return;
            
            const totalEffectiveness = pattern.samples.reduce((sum, sample) => sum + sample.effectiveness, 0);
            pattern.avgEffectiveness = totalEffectiveness / pattern.samples.length;
            
            const successfulSamples = pattern.samples.filter(s => s.effectiveness > 0.7).length;
            pattern.successRate = successfulSamples / pattern.samples.length;
            pattern.lastUpdated = Date.now();
        }
        
        calculateWeightedAverage(samples) {
            const weights = samples.map(s => s.effectiveness);
            const totalWeight = weights.reduce((sum, w) => sum + w, 0);
            
            const avgParams = {};
            const paramKeys = Object.keys(samples[0].parameters);
            
            paramKeys.forEach(key => {
                const weightedSum = samples.reduce((sum, sample, index) => {
                    return sum + (sample.parameters[key] * weights[index]);
                }, 0);
                avgParams[key] = weightedSum / totalWeight;
            });
            
            return avgParams;
        }
        
        // Data persistence
        loadLearningData() {
            try {
                const saved = localStorage.getItem('autopilot_ml_patterns');
                return saved ? JSON.parse(saved) : { patterns: {}, userBehavior: {}, performanceMetrics: {} };
            } catch (error) {
                console.warn('Could not load learning data:', error);
                return { patterns: {}, userBehavior: {}, performanceMetrics: {} };
            }
        }
        
        saveLearningData() {
            try {
                const data = {
                    patterns: this.patterns,
                    userBehavior: this.userBehavior,
                    performanceMetrics: this.performanceMetrics,
                    lastSaved: Date.now()
                };
                localStorage.setItem('autopilot_ml_patterns', JSON.stringify(data));
            } catch (error) {
                console.warn('Could not save learning data:', error);
            }
        }
        
        // Get learning analytics
        getLearningAnalytics() {
            const totalPatterns = Object.keys(this.patterns).length;
            const totalSamples = Object.values(this.patterns).reduce((sum, pattern) => sum + pattern.samples.length, 0);
            const avgSuccessRate = totalPatterns > 0 ? 
                Object.values(this.patterns).reduce((sum, pattern) => sum + pattern.successRate, 0) / totalPatterns : 0;
            
            const totalBehaviors = Object.keys(this.userBehavior).length;
            const totalActions = Object.values(this.userBehavior).reduce((sum, behavior) => sum + behavior.totalActions, 0);
            
            return {
                patterns: {
                    total: totalPatterns,
                    samples: totalSamples,
                    avgSuccessRate: avgSuccessRate
                },
                userBehavior: {
                    total: totalBehaviors,
                    actions: totalActions
                },
                learningProgress: Math.min(totalSamples / 100, 1) // 0-1 progress indicator
            };
        }
    }

    // Infinite Zoom Visualization System
    class InfiniteZoomVisualization {
        constructor(visualizer) {
            this.visualizer = visualizer;
            this.isActive = false;
            this.canvas = null;
            this.ctx = null;
            
            // Settings
            this.colorRandomness = 0.5; // 0-1, how random colors are
            this.minSize = 2;
            this.maxSize = 20;
            this.density = 50; // Will be calculated based on screen area
            this.shape = 'circle'; // circle, square, rectangle, triangle, star, mushroom
            
            // Animation state
            this.zoomSpeed = 0.05; // 50% of max speed
            this.currentZoom = 0;
            this.objects = [];
            this.lastBeatTime = 0;
            
            // Beat reaction
            this.beatReact = false;
            this.baseZoomSpeed = 0.05; // Store base speed when beat react is off
            
            // Rotation
            this.rotationSpeed = 0; // -10 to 10, 0 = no rotation
            this.currentRotation = 0;
            this.baseRotationSpeed = 0;
            
            // Beat reaction controls
            this.beatZoom = false;
            this.beatRotation = false;
            this.beatDensity = false;
            this.beatShape = false;
            
            // Opacity
            this.opacity = 1.0; // 0-1 range
            
            // Beat React sensitivity (0-1, default 1.0 for 100%)
            this.sensitivity = 1.0;
            
            // Audio response
            this.energyHistory = [];
            this.beatSensitivity = 0.7;
            
            console.log('🔍 Infinite Zoom Visualization initialized');
        }
        
        initialize() {
            // Create canvas
            this.canvas = document.createElement('canvas');
            this.canvas.width = 800;
            this.canvas.height = 600;
            this.ctx = this.canvas.getContext('2d');
            
            // Set canvas style
            this.canvas.style.position = 'absolute';
            this.canvas.style.top = '0';
            this.canvas.style.left = '0';
            this.canvas.style.pointerEvents = 'none';
            this.canvas.style.zIndex = '1';
            
            // Add to visualization container
            const container = document.getElementById('visualizationContainer');
            if (container) {
                container.appendChild(this.canvas);
                
                // Resize canvas to fill container
                this.resize();
                
                // Calculate initial density based on screen area (50% of max)
                const screenArea = this.canvas.width * this.canvas.height;
                const maxDensity = Math.floor(screenArea / 100); // 1 object per 100 pixels for max density
                this.density = Math.floor(0.5 * maxDensity); // 50% of max density
            }
            
            console.log('🔍 Infinite Zoom canvas created and added to container');
        }
        
        start() {
            this.isActive = true;
            this.generateInitialObjects();
            console.log('🔍 Infinite Zoom started');
        }
        
        stop() {
            this.isActive = false;
            this.objects = [];
            if (this.canvas && this.canvas.parentNode) {
                this.canvas.parentNode.removeChild(this.canvas);
            }
            console.log('🔍 Infinite Zoom stopped');
        }
        
        generateInitialObjects() {
            this.objects = [];
            // Use the density as calculated by the slider (already based on screen area)
            for (let i = 0; i < this.density; i++) {
                this.addObject();
            }
        }
        
        addObject() {
            const object = {
                x: Math.random() * this.canvas.width,
                y: Math.random() * this.canvas.height,
                size: this.minSize + Math.random() * (this.maxSize - this.minSize),
                color: this.generateColor(),
                depth: Math.random() * 1000 + 100, // distance from camera
                rotation: Math.random() * Math.PI * 2,
                shape: this.shape
            };
            this.objects.push(object);
        }
        
        updateObjectShapes() {
            // Update all existing objects to use current shape
            this.objects.forEach(obj => {
                obj.shape = this.shape;
            });
        }
        
        generateColor() {
            if (Math.random() < this.colorRandomness) {
                // Random color
                const hue = Math.random() * 360;
                const saturation = 70 + Math.random() * 30;
                const lightness = 50 + Math.random() * 30;
                return `hsl(${hue}, ${saturation}%, ${lightness}%)`;
            } else {
                // Fixed color (white)
                return '#ffffff';
            }
        }
        
        update(audioFeatures = null) {
            if (!this.isActive) return;
            
            // Debug logging
            if (this.beatReact) {
                console.log('🔍 Infinite Zoom update called - Beat React:', this.beatReact, 'Audio Features:', !!audioFeatures);
            }
            
            // Always call audio response FIRST to calculate new speeds
            this.updateAudioResponse(audioFeatures);
            
            // Update zoom
            const oldZoom = this.currentZoom;
            this.currentZoom += this.zoomSpeed;
            if (this.beatReact && this.zoomSpeed !== 0) {
                console.log('🔍 Zoom update - Speed:', this.zoomSpeed, 'Old:', oldZoom.toFixed(3), 'New:', this.currentZoom.toFixed(3));
            }
            
            // Update rotation
            const oldRotation = this.currentRotation;
            this.currentRotation += this.rotationSpeed * 0.01; // Scale rotation speed
            if (this.beatReact && this.rotationSpeed !== 0) {
                console.log('🔍 Rotation update - Speed:', this.rotationSpeed, 'Old:', oldRotation.toFixed(3), 'New:', this.currentRotation.toFixed(3));
            }
            
            // Update object positions based on zoom direction
            this.objects.forEach(obj => {
                obj.depth -= this.zoomSpeed * 50;
                
                // Handle object recycling based on zoom direction
                if (this.zoomSpeed > 0 && obj.depth < 50) {
                    // Zoom in: reset objects that get too close
                    obj.depth = 1000 + Math.random() * 500;
                    obj.x = Math.random() * this.canvas.width;
                    obj.y = Math.random() * this.canvas.height;
                    obj.color = this.generateColor();
                } else if (this.zoomSpeed < 0 && obj.depth > 2000) {
                    // Zoom out: reset objects that get too far
                    obj.depth = 100 + Math.random() * 200;
                    obj.x = Math.random() * this.canvas.width;
                    obj.y = Math.random() * this.canvas.height;
                    obj.color = this.generateColor();
                }
            });
            
            // Add new objects on beat
            if (audioFeatures && audioFeatures.beat) {
                const now = Date.now();
                if (now - this.lastBeatTime > 200) { // Debounce
                    this.addObject();
                    this.lastBeatTime = now;
                }
            }
        }
        
        updateAudioResponse(audioFeatures) {
            console.log('🔍 updateAudioResponse called with:', audioFeatures);
            console.log('🔍 Beat React enabled:', this.beatReact);
            console.log('🔍 Beat controls - Zoom:', this.beatZoom, 'Rotation:', this.beatRotation, 'Density:', this.beatDensity, 'Shape:', this.beatShape);
            
            // Use test features only if no audio features at all
            if (!audioFeatures) {
                // Fallback: generate test audio features for debugging
                const testFeatures = {
                    energy: 0.5 + Math.sin(Date.now() / 1000) * 0.3, // Oscillating energy
                    beat: Math.random() > 0.95, // Random beats
                    tempo: 120,
                    dominantFrequency: 1000
                };
                console.log('🔍 Using test audio features (no audio features):', testFeatures);
                audioFeatures = testFeatures;
            } else if (audioFeatures.energy === 0) {
                console.log('🔍 Real audio features received but energy is 0 - using as-is');
            } else {
                console.log('🔍 Using real audio features with energy:', audioFeatures.energy);
            }
            
            // Track energy history
            this.energyHistory.push(audioFeatures.energy || 0);
            if (this.energyHistory.length > 20) {
                this.energyHistory.shift();
            }
            
            // Beat reaction - only if enabled
            if (this.beatReact) {
                const currentEnergy = audioFeatures.energy || 0;
                const avgEnergy = this.energyHistory.reduce((sum, e) => sum + e, 0) / this.energyHistory.length;
                console.log('🔍 Beat React processing - currentEnergy:', currentEnergy, 'avgEnergy:', avgEnergy, 'history length:', this.energyHistory.length);
                
                // Beat Zoom - adjust zoom speed based on current energy (scaled by sensitivity)
                if (this.beatZoom) {
                    // Map energy 0-1 to zoom speed range, scaled by sensitivity
                    // High energy = zoom in (positive), low energy = zoom out (negative)
                    const zoomRange = 1.0 * this.sensitivity; // Reduced from 2.0 to 1.0 for more balanced effect
                    // Invert the calculation: higher energy = more positive zoom (zoom in)
                    this.zoomSpeed = (0.2 - currentEnergy) * zoomRange;
                    console.log('🔍 Beat Zoom - Energy:', currentEnergy, 'Sensitivity:', this.sensitivity, 'New Speed:', this.zoomSpeed);
                } else {
                    // Restore base zoom speed when beat zoom is off
                    this.zoomSpeed = this.baseZoomSpeed;
                }
                
                // Beat Rotation - adjust rotation speed based on current energy (scaled by sensitivity)
                if (this.beatRotation) {
                    // Map energy 0-1 to rotation speed range, scaled by sensitivity
                    // High energy = clockwise (positive), low energy = counter-clockwise (negative)
                    // Use a smaller range and center it around the actual energy values we're seeing
                    const rotationRange = 20 * this.sensitivity; // Reduced from 100 to 20 for more balanced effect
                    // Invert the calculation: higher energy = more positive rotation (clockwise)
                    this.rotationSpeed = (0.2 - currentEnergy) * rotationRange;
                    console.log('🔍 Beat Rotation - Energy:', currentEnergy, 'Sensitivity:', this.sensitivity, 'New Speed:', this.rotationSpeed);
                } else {
                    // Restore base rotation speed when beat rotation is off
                    this.rotationSpeed = this.baseRotationSpeed;
                }
                
                // Beat Density - add objects based on current energy (scaled by sensitivity)
                if (this.beatDensity) {
                    // Map energy 0-1 to density multiplier, scaled by sensitivity
                    const densityRange = 5.0 * this.sensitivity; // Increased from 2.9 to 5.0 for much more dramatic effect
                    const densityMultiplier = 0.1 + currentEnergy * densityRange;
                    const targetDensity = Math.floor(this.density * densityMultiplier);
                    if (this.objects.length < targetDensity) {
                        this.addObject();
                    }
                    console.log('🔍 Beat Density - Energy:', currentEnergy, 'Sensitivity:', this.sensitivity, 'Multiplier:', densityMultiplier, 'Target Density:', targetDensity, 'Current Objects:', this.objects.length);
                }
                
                // Beat Shape - change shape on beat
                if (this.beatShape && audioFeatures.beat) {
                    const shapes = ['circle', 'square', 'rectangle', 'triangle', 'star', 'mushroom'];
                    const currentIndex = shapes.indexOf(this.shape);
                    this.shape = shapes[(currentIndex + 1) % shapes.length];
                    this.updateObjectShapes();
                    console.log(`🔍 Beat Shape changed to: ${this.shape} (beat detected!)`);
                } else if (this.beatShape) {
                    console.log('🔍 Beat Shape enabled but no beat detected - beat:', audioFeatures.beat);
                }
                
                // Add objects on beat (general)
                if (audioFeatures.beat) {
                    const now = Date.now();
                    if (now - this.lastBeatTime > 200) { // Debounce
                        this.addObject();
                        this.lastBeatTime = now;
                        console.log(`🔍 Beat detected - added object. Energy: ${avgEnergy.toFixed(2)}`);
                    }
                }
                
                // Debug logging
                if (this.beatZoom || this.beatRotation || this.beatDensity) {
                    console.log(`🔍 Beat React - Energy: ${currentEnergy.toFixed(2)}, Zoom: ${this.zoomSpeed.toFixed(3)}, Rotation: ${this.rotationSpeed.toFixed(3)}`);
                }
            } else {
                // Beat React is disabled - restore all base values
                this.zoomSpeed = this.baseZoomSpeed;
                this.rotationSpeed = this.baseRotationSpeed;
                console.log('🔍 Beat React disabled - Restored base values - Zoom:', this.zoomSpeed, 'Rotation:', this.rotationSpeed);
            }
        }
        
        draw() {
            if (!this.isActive || !this.ctx) return;
            
            // Clear canvas
            this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
            
            // Apply opacity
            this.ctx.globalAlpha = this.opacity;
            
            // Apply rotation if any
            if (this.currentRotation !== 0) {
                this.ctx.save();
                this.ctx.translate(this.canvas.width / 2, this.canvas.height / 2);
                this.ctx.rotate(this.currentRotation);
                this.ctx.translate(-this.canvas.width / 2, -this.canvas.height / 2);
            }
            
            // Draw objects
            this.objects.forEach(obj => {
                this.drawObject(obj);
            });
            
            // Restore rotation
            if (this.currentRotation !== 0) {
                this.ctx.restore();
            }
            
            // Reset alpha
            this.ctx.globalAlpha = 1.0;
        }
        
        // This method is called by the main kaleidoscope system
        drawForKaleidoscope() {
            if (!this.isActive || !this.ctx) return;
            
            // Clear canvas
            this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
            
            // Draw objects
            this.objects.forEach(obj => {
                this.drawObject(obj);
            });
        }
        
        drawObject(obj) {
            const centerX = this.canvas.width / 2;
            const centerY = this.canvas.height / 2;
            
            // Calculate screen position based on depth
            const scale = 100 / obj.depth;
            const screenX = centerX + (obj.x - centerX) * scale;
            const screenY = centerY + (obj.y - centerY) * scale;
            const screenSize = obj.size * scale;
            
            // Skip if too small or off-screen
            if (screenSize < 0.5 || screenX < -50 || screenX > this.canvas.width + 50 || 
                screenY < -50 || screenY > this.canvas.height + 50) {
                return;
            }
            
            this.ctx.save();
            this.ctx.translate(screenX, screenY);
            this.ctx.rotate(obj.rotation);
            this.ctx.fillStyle = obj.color;
            this.ctx.globalAlpha = Math.min(1, scale * 2);
            
            switch (obj.shape) {
                case 'circle':
                    this.ctx.beginPath();
                    this.ctx.arc(0, 0, screenSize / 2, 0, Math.PI * 2);
                    this.ctx.fill();
                    break;
                    
                case 'square':
                    this.ctx.fillRect(-screenSize / 2, -screenSize / 2, screenSize, screenSize);
                    break;
                    
                case 'rectangle':
                    this.ctx.fillRect(-screenSize / 2, -screenSize / 4, screenSize, screenSize / 2);
                    break;
                    
                case 'triangle':
                    this.ctx.beginPath();
                    this.ctx.moveTo(0, -screenSize / 2);
                    this.ctx.lineTo(-screenSize / 2, screenSize / 2);
                    this.ctx.lineTo(screenSize / 2, screenSize / 2);
                    this.ctx.closePath();
                    this.ctx.fill();
                    break;
                    
                case 'star':
                    this.drawStar(0, 0, screenSize / 2, 5);
                    break;
                    
                case 'mushroom':
                    this.drawMushroom(0, 0, screenSize);
                    break;
            }
            
            this.ctx.restore();
        }
        
        drawStar(x, y, radius, points) {
            this.ctx.beginPath();
            for (let i = 0; i < points * 2; i++) {
                const angle = (i * Math.PI) / points;
                const r = i % 2 === 0 ? radius : radius * 0.5;
                const px = x + Math.cos(angle) * r;
                const py = y + Math.sin(angle) * r;
                if (i === 0) {
                    this.ctx.moveTo(px, py);
                } else {
                    this.ctx.lineTo(px, py);
                }
            }
            this.ctx.closePath();
            this.ctx.fill();
        }
        
        drawMushroom(x, y, size) {
            // Generate random colors for each mushroom
            const capColor = this.generateMushroomCapColor();
            const stemColor = this.generateMushroomStemColor();
            
            // Cap (red with white spots)
            this.ctx.fillStyle = capColor;
            this.ctx.strokeStyle = '#000000';
            this.ctx.lineWidth = 1;
            this.ctx.beginPath();
            this.ctx.ellipse(x, y - size / 4, size / 3, size / 4, 0, 0, Math.PI * 2);
            this.ctx.fill();
            this.ctx.stroke();
            
            // White spots on cap
            this.ctx.fillStyle = '#ffffff';
            this.ctx.strokeStyle = '#000000';
            const spotCount = Math.floor(Math.random() * 4) + 2; // 2-5 spots
            for (let i = 0; i < spotCount; i++) {
                const spotX = x + (Math.random() - 0.5) * size * 0.4;
                const spotY = y - size / 4 + (Math.random() - 0.5) * size * 0.3;
                const spotSize = Math.random() * size * 0.08 + size * 0.03;
                
                this.ctx.beginPath();
                this.ctx.ellipse(spotX, spotY, spotSize, spotSize * 0.8, 0, 0, Math.PI * 2);
                this.ctx.fill();
                this.ctx.stroke();
            }
            
            // Stem (light colored)
            this.ctx.fillStyle = stemColor;
            this.ctx.strokeStyle = '#000000';
            this.ctx.beginPath();
            this.ctx.ellipse(x, y + size / 8, size / 12, size / 3, 0, 0, Math.PI * 2);
            this.ctx.fill();
            this.ctx.stroke();
        }
        
        generateMushroomCapColor() {
            const colors = [
                '#ff4444', // Red
                '#ff6b6b', // Light red
                '#ff8e8e', // Pink-red
                '#ff4444', // Dark red
                '#ff3333'  // Bright red
            ];
            return colors[Math.floor(Math.random() * colors.length)];
        }
        
        generateMushroomStemColor() {
            const colors = [
                '#f4e4bc', // Cream
                '#f0e68c', // Khaki
                '#f5deb3', // Wheat
                '#ffe4b5', // Moccasin
                '#f0e68c'  // Light khaki
            ];
            return colors[Math.floor(Math.random() * colors.length)];
        }
        
        resize() {
            if (this.canvas) {
                const container = document.getElementById('visualizationContainer');
                if (container) {
                    const rect = container.getBoundingClientRect();
                    this.canvas.width = rect.width;
                    this.canvas.height = rect.height;
                    console.log(`🔍 Infinite Zoom canvas resized to: ${rect.width}x${rect.height}`);
                }
            }
        }
        
        getSettings() {
            return {
                isActive: this.isActive,
                colorRandomness: this.colorRandomness,
                minSize: this.minSize,
                maxSize: this.maxSize,
                density: this.density,
                shape: this.shape,
                zoomSpeed: this.zoomSpeed
            };
        }
        
        setSettings(settings) {
            if (settings.colorRandomness !== undefined) this.colorRandomness = settings.colorRandomness;
            if (settings.minSize !== undefined) this.minSize = settings.minSize;
            if (settings.maxSize !== undefined) this.maxSize = settings.maxSize;
            if (settings.density !== undefined) this.density = settings.density;
            if (settings.shape !== undefined) this.shape = settings.shape;
            if (settings.zoomSpeed !== undefined) this.zoomSpeed = settings.zoomSpeed;
        }
    }

    // AI Autopilot System for Live Performance Visualization Management
    class AIAutopilot {
        constructor(visualizer) {
            this.visualizer = visualizer;
            this.isActive = false;
            
            // Autopilot settings
            this.scope = 'all'; // 'bars', 'radial', 'energy', 'all'
            this.autoColorSchemes = false; // Off by default
            this.changeTiming = 'instant'; // 'instant', 'smooth', 'slow', 'beat-synced'
            this.sensitivity = 'medium'; // 'low', 'medium', 'high'
            
            // Initialize components
            this.audioAnalyzer = new AudioAnalyzer(visualizer.audioMotion);
            this.decisionEngine = new DecisionEngine(this);
            this.parameterController = new ParameterController(this);
            this.genreDetector = new GenreDetector(this);
            this.patternLearning = new PatternLearningSystem(this); // New ML system
            this.adaptiveTuning = new AdaptiveTuningSystem(this); // New adaptive tuning system
            this.predictiveBehavior = new PredictiveBehaviorSystem(this); // New predictive behavior system
            this.multiLayeredIntelligence = new MultiLayeredIntelligenceSystem(this); // New multi-layered intelligence system
            
            // Autopilot state
            this.lastModeChange = 0;
            this.currentMode = visualizer.currentMode; // Use current visualization mode instead of defaulting to 0
            this.modeHistory = [];
            this.energyHistory = [];
            
            // Genre detection state
            this.currentGenre = 'unknown';
            this.genreConfidence = 0;
            this.genreHistory = [];
            this.manualGenre = null; // User-selected genre override
            
            // Parameter control state
            this.parameterHistory = [];
            this.userPreferences = this.loadUserPreferences();
            this.parameterControlEnabled = true; // Enable by default for testing
            this.videoEffectsEnabled = true; // Enable by default
            
            // Learning state
            this.learningEnabled = true; // Enable pattern learning by default
            this.lastLearningUpdate = 0;
            this.learningCooldown = 5000; // 5 seconds between learning updates
            
            // Adaptive tuning state
            this.adaptiveTuningEnabled = true; // Enable adaptive tuning by default
            
            // Predictive behavior state
            this.predictiveBehaviorEnabled = true; // Enable predictive behavior by default
            
            // Multi-layered intelligence state
            this.multiLayeredIntelligenceEnabled = true; // Enable multi-layered intelligence by default
            
            // Define visualization mode groups
            this.modeGroups = {
                bars: [0, 2, 3], // Spectrum, Classic LED, Stereo
                radial: [4], // Radial Spectrum
                energy: [5], // Energy
                all: [0, 1, 2, 3, 4, 5, 6] // All modes
            };
            
            console.log('🤖 AI Autopilot initialized with enhanced parameter control and pattern learning');
        }
        
        activate() {
            if (this.isActive) return;
            
            this.isActive = true;
            this.audioAnalyzer.start();
            this.decisionEngine.start();
            
            // Reset history
            this.modeHistory = [this.visualizer.currentMode];
            
            // Don't force a mode change on activation - respect current mode and scope
            console.log('🤖 AI Autopilot activated with scope:', this.scope);
            this.updateUI();
        }
        
        recordModeChange(newMode) {
            this.modeHistory.push(newMode);
            // Keep only recent history (last 10 changes)
            if (this.modeHistory.length > 10) {
                this.modeHistory = this.modeHistory.slice(-10);
            }
        }
        
        deactivate() {
            if (!this.isActive) return;
            
            this.isActive = false;
            this.audioAnalyzer.stop();
            this.decisionEngine.stop();
            
            console.log('🤖 AI Autopilot deactivated');
            this.updateUI();
        }
        
        updateUI() {
            const btn = document.getElementById('aiAutopilotBtn');
            if (btn) {
                if (this.isActive) {
                    btn.textContent = 'Deactivate';
                    btn.classList.add('active');
                } else {
                    btn.textContent = 'Activate';
                    btn.classList.remove('active');
                }
            }
        }
        
        setIntensity(level) {
            this.intensity = level;
            console.log(`🎛️ Autopilot intensity set to: ${level}`);
        }
        
        // Enhanced decision making with parameter control and pattern learning
        makeAdvancedDecisions() {
            const audioFeatures = this.audioAnalyzer.getCurrentFeatures();
            
            // Debug logging
            console.log('🤖 Enhanced Decision Making:', {
                energy: audioFeatures.energy?.toFixed(3),
                beat: audioFeatures.beat,
                tempo: audioFeatures.tempo,
                dominantFreq: audioFeatures.dominantFreq,
                parameterControlEnabled: this.parameterControlEnabled,
                learningEnabled: this.learningEnabled,
                scope: this.scope,
                multiLayeredIntelligenceEnabled: this.multiLayeredIntelligenceEnabled
            });
            
            // Use multi-layered intelligence if enabled
            if (this.multiLayeredIntelligenceEnabled && this.multiLayeredIntelligence) {
                const currentParams = this.getCurrentParameters();
                console.log('🧠 Multi-layered intelligence: Making decision for scope:', this.scope, 'current mode:', this.visualizer.currentMode);
                console.log('🧠 Current audioMotion params:', {
                    linearBoost: this.visualizer.audioMotion?.linearBoost,
                    gradient: this.visualizer.audioMotion?.gradient,
                    fillAlpha: this.visualizer.audioMotion?.fillAlpha,
                    smoothing: this.visualizer.audioMotion?.smoothing
                });
                
                const decision = this.multiLayeredIntelligence.makeIntelligentDecision(
                    audioFeatures, 
                    this.visualizer.currentMode, 
                    currentParams
                );
                
                if (decision) {
                    console.log('🧠 Multi-layered intelligence decision:', decision);
                    return; // Multi-layered intelligence handles everything
                } else {
                    console.log('🧠 Multi-layered intelligence: No decision made');
                }
            }
            
            // Use manual genre if set, otherwise detect automatically
            let detectedGenre;
            if (this.manualGenre) {
                detectedGenre = {
                    genre: this.manualGenre,
                    confidence: 1.0,
                    allScores: {}
                };
            } else {
                detectedGenre = this.genreDetector.detectGenre(audioFeatures);
            }
            
            // Update genre state
            this.updateGenreState(detectedGenre);
            
            // Update UI display
            this.updateGenreDisplay();
            
            // Get parameter recommendations based on genre and audio
            if (this.parameterControlEnabled) {
                let parameterRecommendations;
                
                // Try user preference recommendations first (highest priority)
                const userPreferenceRecommendations = this.parameterController.getUserPreferenceRecommendations(
                    detectedGenre.genre, 
                    audioFeatures
                );
                
                if (userPreferenceRecommendations) {
                    console.log('👤 Using user preference recommendations');
                    parameterRecommendations = {
                        visualization: userPreferenceRecommendations,
                        video: {},
                        source: 'user_preferences',
                        confidence: 0.9 // High confidence in user preferences
                    };
                }
                // Try pattern learning recommendations second
                else if (this.learningEnabled) {
                    const patternRecommendations = this.patternLearning.getPatternRecommendations(
                        detectedGenre.genre, 
                        audioFeatures
                    );
                    
                    if (patternRecommendations) {
                        console.log('🧠 Using pattern learning recommendations');
                        parameterRecommendations = {
                            visualization: patternRecommendations.parameters,
                            video: {},
                            source: 'pattern_learning',
                            confidence: patternRecommendations.confidence
                        };
                    }
                }
                
                // Fallback to rule-based recommendations if no learning data
                if (!parameterRecommendations) {
                    parameterRecommendations = this.getParameterRecommendations(
                    detectedGenre, 
                    audioFeatures, 
                    this.scope
                );
                }
                
                // Apply parameter changes
                this.parameterController.applyParameterChanges(parameterRecommendations);
                
                // Learn from this decision if learning is enabled
                if (this.learningEnabled && this.shouldLearnFromDecision()) {
                    this.learnFromCurrentDecision(detectedGenre, audioFeatures, parameterRecommendations);
                }
            }
            
            // Track performance for adaptive tuning
            if (this.adaptiveTuning && this.adaptiveTuningEnabled) {
                const userFeedback = this.getLastUserFeedback();
                this.adaptiveTuning.trackPerformance(audioFeatures, userFeedback);
            }
            
            // Predictive Behavior System - anticipate optimal actions
            if (this.predictiveBehavior && this.predictiveBehaviorEnabled) {
                const currentParams = this.getCurrentParameters();
                const predictions = this.predictiveBehavior.predictOptimalActions(
                    audioFeatures, 
                    this.visualizer.currentMode, 
                    currentParams
                );
                
                if (predictions && predictions.confidence >= 0.8) {
                    console.log('🎯 Predictive behavior triggered:', {
                        modeChange: predictions.modeChange?.reason,
                        parameterAdjustments: Object.keys(predictions.parameterAdjustment || {}),
                        timing: predictions.timing?.reason,
                        confidence: Math.round(predictions.confidence * 100) + '%'
                    });
                    
                    // Execute predictions if timing is right
                    if (predictions.timing?.immediate) {
                        this.predictiveBehavior.executePrediction(predictions);
                    } else if (predictions.timing?.delay) {
                        // Schedule delayed execution
                        setTimeout(() => {
                            this.predictiveBehavior.executePrediction(predictions);
                        }, predictions.timing.delay);
                    }
                }
            }
            
            // Continue with existing mode switching logic
            this.decisionEngine.evaluateVisualizationChange();
        }
        
        // Get current parameters for predictive behavior
        getCurrentParameters() {
            if (!this.visualizer.audioMotion) return {};
            
            return {
                linearBoost: this.visualizer.audioMotion.linearBoost || 0.5,
                gradient: this.visualizer.audioMotion.gradient || 0.5,
                smoothing: this.visualizer.audioMotion.smoothing || 0.5,
                fillAlpha: this.visualizer.audioMotion.fillAlpha || 0.5,
                peakHoldTime: this.visualizer.audioMotion.peakHoldTime || 0.5,
                maxDecibels: this.visualizer.audioMotion.maxDecibels || 0.5,
                minFreq: this.visualizer.audioMotion.minFreq || 0.5
            };
        }

        // Check if we should learn from the current decision
        shouldLearnFromDecision() {
            const now = Date.now();
            return now - this.lastLearningUpdate > this.learningCooldown;
        }
        
        // Learn from the current decision for future improvements
        learnFromCurrentDecision(genre, audioFeatures, recommendations) {
            try {
                // Calculate effectiveness based on audio response
                const effectiveness = this.calculateDecisionEffectiveness(audioFeatures);
                
                // Learn from successful parameter combinations
                this.patternLearning.learnFromSuccess(
                    genre.genre,
                    audioFeatures,
                    recommendations.visualization || {},
                    effectiveness
                );
                
                // Learn from user behavior (if user makes manual adjustments)
                this.learnFromUserInteractions(genre, audioFeatures);
                
                this.lastLearningUpdate = Date.now();
                
                console.log(`🧠 Learning from decision: effectiveness=${effectiveness.toFixed(3)}`);
                
            } catch (error) {
                console.error('Error in learning from decision:', error);
            }
        }
        
        // Calculate how effective the current decision was
        calculateDecisionEffectiveness(audioFeatures) {
            // Simple effectiveness calculation based on audio response
            const energy = audioFeatures.energy || 0;
            const beat = audioFeatures.beat || false;
            const tempo = audioFeatures.tempo || 0;
            
            // Higher energy and beat detection = more effective
            let effectiveness = energy * 0.6;
            
            if (beat) {
                effectiveness += 0.2;
            }
            
            // Tempo stability bonus
            if (tempo > 0) {
                effectiveness += Math.min(tempo / 200, 0.2);
            }
            
            return Math.min(effectiveness, 1.0);
        }
        
        // Learn from user interactions and manual adjustments
        learnFromUserInteractions(genre, audioFeatures) {
            // This will be expanded when we add user feedback learning
            // For now, just track basic interaction patterns
            const context = {
                genre: genre.genre,
                energy: audioFeatures.energy,
                tempo: audioFeatures.tempo
            };
            
            // Learn that the AI made a decision in this context
            this.patternLearning.learnFromUserBehavior(
                'ai_decision',
                JSON.stringify(context),
                'positive' // Assume positive unless user indicates otherwise
            );
        }
        
        // Method to be called when user manually adjusts parameters
        onUserParameterChange(parameterName, oldValue, newValue) {
            if (this.parameterController) {
                const context = {
                    genre: this.currentGenre,
                    energy: this.audioAnalyzer.getEnergy(),
                    tempo: this.audioAnalyzer.getTempo()
                };
                
                this.parameterController.trackUserAdjustment(parameterName, oldValue, newValue, context);
            }
        }
        
        // Get the last user feedback for performance tracking
        getLastUserFeedback() {
            if (this.parameterController && this.parameterController.feedbackHistory.length > 0) {
                const lastFeedback = this.parameterController.feedbackHistory[this.parameterController.feedbackHistory.length - 1];
                // Only return feedback from the last 30 seconds
                if (Date.now() - lastFeedback.timestamp < 30000) {
                    return lastFeedback.feedback;
                }
            }
            return null;
        }
        
        getParameterRecommendations(genre, audioFeatures, scope) {
            // Enhanced parameter recommendations with more dramatic visual changes
            const energy = audioFeatures.energy || 0.5;
            const tempo = audioFeatures.tempo || 120;
            const beat = audioFeatures.beat || false;
            const dominantFreq = audioFeatures.dominantFreq || 0.5;
            const harmonic = audioFeatures.harmonic || {};
            const structure = audioFeatures.structure || {};
            
            // More dramatic parameter ranges for better visual impact
            const recommendations = {
                visualization: {},
                video: {}
            };
            
            // Energy-based parameters (more dramatic range)
            if (energy > 0.7) {
                recommendations.visualization.linearBoost = 2.5 + (energy - 0.7) * 2; // 2.5-4.0
                recommendations.visualization.gradient = 0.8 + (energy - 0.7) * 0.2; // 0.8-1.0
                recommendations.visualization.fillAlpha = 0.9 + (energy - 0.7) * 0.1; // 0.9-1.0
            } else if (energy > 0.4) {
                recommendations.visualization.linearBoost = 1.5 + (energy - 0.4) * 3.33; // 1.5-2.5
                recommendations.visualization.gradient = 0.4 + (energy - 0.4) * 1.33; // 0.4-0.8
                recommendations.visualization.fillAlpha = 0.6 + (energy - 0.4) * 1.0; // 0.6-0.9
            } else {
                recommendations.visualization.linearBoost = 0.5 + energy * 2.5; // 0.5-1.5
                recommendations.visualization.gradient = energy * 1.0; // 0.0-0.4
                recommendations.visualization.fillAlpha = 0.3 + energy * 0.75; // 0.3-0.6
            }
            
            // Tempo-based parameters
            if (tempo > 140) {
                recommendations.visualization.peakHoldTime = 300; // Fast tempo = quick peaks
                recommendations.visualization.smoothing = 0.3; // Less smoothing for fast music
            } else if (tempo > 100) {
                recommendations.visualization.peakHoldTime = 500; // Medium tempo
                recommendations.visualization.smoothing = 0.5;
            } else {
                recommendations.visualization.peakHoldTime = 800; // Slow tempo = longer peaks
                recommendations.visualization.smoothing = 0.8; // More smoothing for slow music
            }
            
            // Beat-reactive parameters
            if (beat) {
                recommendations.visualization.peakFadeTime = 200; // Quick fade on beats
                recommendations.visualization.linearBoost *= 1.3; // Boost on beats
            } else {
                recommendations.visualization.peakFadeTime = 1000; // Slower fade without beats
            }
            
            // Frequency-based parameters
            if (dominantFreq < 0.3) { // Bass heavy
                recommendations.visualization.maxDecibels = -20; // More sensitive to low frequencies
                recommendations.visualization.minFreq = 20; // Lower minimum frequency
            } else if (dominantFreq > 0.7) { // Treble heavy
                recommendations.visualization.maxDecibels = -30; // Less sensitive to high frequencies
                recommendations.visualization.minFreq = 100; // Higher minimum frequency
            } else { // Mid range
                recommendations.visualization.maxDecibels = -25;
                recommendations.visualization.minFreq = 50;
            }
            
            // Harmonic-based parameters
            if (harmonic.chord) {
                // Different chord types get different visual treatments
                if (harmonic.chord.includes('m')) { // Minor chords
                    recommendations.visualization.gradient = 0.2; // Darker colors
                    recommendations.visualization.fillAlpha = 0.7;
                } else { // Major chords
                    recommendations.visualization.gradient = 0.8; // Brighter colors
                    recommendations.visualization.fillAlpha = 0.9;
                }
            }
            
            // Structure-based parameters
            if (structure.section) {
                switch (structure.section) {
                    case 'intro':
                        recommendations.visualization.linearBoost *= 0.7; // Quieter intro
                        recommendations.visualization.fillAlpha *= 0.8;
                        break;
                    case 'chorus':
                        recommendations.visualization.linearBoost *= 1.4; // Louder chorus
                        recommendations.visualization.fillAlpha = Math.min(1.0, recommendations.visualization.fillAlpha * 1.2);
                        break;
                    case 'bridge':
                        recommendations.visualization.gradient = 0.5; // Different colors for bridge
                        recommendations.visualization.linearBoost *= 1.1;
                        break;
                    case 'outro':
                        recommendations.visualization.linearBoost *= 0.6; // Quieter outro
                        recommendations.visualization.fillAlpha *= 0.7;
                        break;
                }
            }
            
            // Genre-specific enhancements
            const genreMultipliers = {
                'electronic': { boost: 1.5, gradient: 1.0, alpha: 1.0 },
                'rock': { boost: 1.3, gradient: 0.8, alpha: 0.9 },
                'classical': { boost: 0.8, gradient: 0.6, alpha: 0.8 },
                'jazz': { boost: 1.1, gradient: 0.7, alpha: 0.85 },
                'ambient': { boost: 0.6, gradient: 0.3, alpha: 0.6 },
                'country': { boost: 1.2, gradient: 0.9, alpha: 0.9 }
            };
            
            const multiplier = genreMultipliers[genre.genre] || { boost: 1.0, gradient: 1.0, alpha: 1.0 };
            recommendations.visualization.linearBoost *= multiplier.boost;
            recommendations.visualization.gradient *= multiplier.gradient;
            recommendations.visualization.fillAlpha *= multiplier.alpha;
            
            // Clamp values to valid ranges
            recommendations.visualization.linearBoost = Math.max(0.1, Math.min(5.0, recommendations.visualization.linearBoost));
            recommendations.visualization.gradient = Math.max(0.0, Math.min(1.0, recommendations.visualization.gradient));
            recommendations.visualization.fillAlpha = Math.max(0.1, Math.min(1.0, recommendations.visualization.fillAlpha));
            recommendations.visualization.peakHoldTime = Math.max(100, Math.min(2000, recommendations.visualization.peakHoldTime));
            recommendations.visualization.peakFadeTime = Math.max(100, Math.min(2000, recommendations.visualization.peakFadeTime));
            recommendations.visualization.smoothing = Math.max(0.1, Math.min(1.0, recommendations.visualization.smoothing));
            
            return recommendations;
        }
        
        updateGenreState(detectedGenre) {
            this.genreHistory.push({
                genre: detectedGenre.genre,
                confidence: detectedGenre.confidence,
                timestamp: Date.now()
            });
            
            // Keep only recent history (last 20 detections)
            if (this.genreHistory.length > 20) {
                this.genreHistory = this.genreHistory.slice(-20);
            }
            
            // Update current genre if confidence is high enough
            if (detectedGenre.confidence > 0.7) {
                this.currentGenre = detectedGenre.genre;
                this.genreConfidence = detectedGenre.confidence;
            }
        }
        
        loadUserPreferences() {
            try {
                const saved = localStorage.getItem('autopilot_user_preferences');
                return saved ? JSON.parse(saved) : {};
            } catch (error) {
                console.warn('Could not load user preferences:', error);
                return {};
            }
        }
        
        saveUserPreferences() {
            try {
                localStorage.setItem('autopilot_user_preferences', JSON.stringify(this.userPreferences));
            } catch (error) {
                console.warn('Could not save user preferences:', error);
            }
        }
        
        updateGenreDisplay() {
            const genreDisplay = document.getElementById('currentGenreDisplay');
            const confidenceDisplay = document.getElementById('genreConfidenceDisplay');
            
            if (genreDisplay) {
                const genreName = this.currentGenre.charAt(0).toUpperCase() + this.currentGenre.slice(1).replace('-', ' ');
                genreDisplay.textContent = genreName;
            }
            
            if (confidenceDisplay) {
                const confidencePercent = Math.round(this.genreConfidence * 100);
                confidenceDisplay.textContent = `${confidencePercent}%`;
            }
        }
        
        // Test method to force parameter changes
        testParameterControl() {
            console.log('🧪 Testing parameter control...');
            
            // Force a genre detection
            const testGenre = 'electronic';
            this.manualGenre = testGenre;
            this.currentGenre = testGenre;
            this.genreConfidence = 1.0;
            
            // Get test audio features
            const testAudioFeatures = {
                energy: 0.8,
                beat: true,
                tempo: 140,
                dominantFreq: 0.7,
                energyTrend: 0.1,
                beatStrength: 1.5,
                frequencyBands: { bass: 0.3, mid: 0.5, treble: 0.8 },
                spectralFlux: 0.1
            };
            
            // Get parameter recommendations
            const recommendations = this.getParameterRecommendations(
                { genre: testGenre, confidence: 1.0 },
                testAudioFeatures,
                this.scope
            );
            
            console.log('🧪 Test recommendations:', recommendations);
            
            // Apply parameter changes
            this.parameterController.applyParameterChanges(recommendations);
            
            // Update display
            this.updateGenreDisplay();
        }
    }

    // Parameter Controller for Enhanced Autopilot
    class ParameterController {
        constructor(autopilot) {
            this.autopilot = autopilot;
            this.visualizer = autopilot.visualizer;
            this.currentParameters = {};
            this.parameterHistory = [];
            
            // User feedback learning
            this.userAdjustments = [];
            this.feedbackHistory = [];
            this.lastUserAdjustment = null;
            this.adjustmentThreshold = 0.1; // Minimum change to consider significant
            
            console.log('🎛️ Parameter Controller initialized with user feedback learning');
        }
        
        applyParameterChanges(recommendations) {
            if (!this.visualizer.audioMotion) return;
            
            try {
                // Apply visualization parameters
                const vizParams = this.convertToAudioMotionParams(recommendations.visualization);
                this.visualizer.audioMotion.setOptions(vizParams);
                
                // Apply video parameters
                if (recommendations.video && this.autopilot.videoEffectsEnabled) {
                    this.applyVideoParameters(recommendations.video);
                }
                
                // Record parameter change
                this.recordParameterChange(recommendations);
                
                console.log('🎛️ Parameters applied:', vizParams);
            } catch (error) {
                console.error('Error applying parameters:', error);
            }
        }
        
        convertToAudioMotionParams(params) {
            const audioMotionParams = {};
            const scope = this.autopilot.scope;
            
            // Convert each parameter to AudioMotion format
            for (const [paramName, value] of Object.entries(params)) {
                let paramDef = null;
                
                // If scope is 'all', check all scopes for parameter definitions
                if (scope === 'all') {
                    for (const scopeName of ['bars', 'radial', 'energy', 'global']) {
                        const scopeParams = VISUALIZATION_PARAMETERS[scopeName] || {};
                        if (scopeParams[paramName]) {
                            paramDef = scopeParams[paramName];
                            break;
                        }
                    }
                } else {
                    // For specific scopes, check that scope first, then global
                    const scopeParams = VISUALIZATION_PARAMETERS[scope] || {};
                    paramDef = scopeParams[paramName] || VISUALIZATION_PARAMETERS.global[paramName];
                }
                
                if (paramDef && paramDef.audioMotion) {
                    const audioMotionParam = paramDef.audioMotion;
                    audioMotionParams[audioMotionParam] = this.convertParameterValue(value, paramDef);
                }
            }
            
            return audioMotionParams;
        }
        
        convertParameterValue(value, paramDef) {
            switch (paramDef.type) {
                case 'float':
                    return Math.max(paramDef.min, Math.min(paramDef.max, value));
                case 'int':
                    const intValue = Math.round(Math.max(paramDef.min, Math.min(paramDef.max, value)));
                    // Special handling for fftSize - must be power of 2
                    if (paramDef.audioMotion === 'fftSize') {
                        return this.getNearestPowerOfTwo(intValue);
                    }
                    return intValue;
                case 'boolean':
                    return Boolean(value);
                case 'enum':
                    return paramDef.values.includes(value) ? value : paramDef.default;
                case 'color':
                    return value;
                default:
                    return value;
            }
        }
        
        getNearestPowerOfTwo(value) {
            const powersOfTwo = [64, 128, 256, 512, 1024, 2048, 4096, 8192];
            return powersOfTwo.reduce((prev, curr) => 
                Math.abs(curr - value) < Math.abs(prev - value) ? curr : prev
            );
        }
        
        applyVideoParameters(videoParams) {
            // Apply video effects to the video element
            const videoElement = this.visualizer.videoElement;
            if (!videoElement) {
                console.log('🎬 Video element not found, skipping video effects');
                return;
            }
            
            console.log('🎬 Applying video effects:', videoParams);
            let filterString = '';
            
            // Apply color effects
            if (videoParams.colorEffects) {
                const effects = videoParams.colorEffects;
                if (effects.grayscale > 0) {
                    filterString += `grayscale(${effects.grayscale * 100}%) `;
                }
                if (effects.sepia > 0) {
                    filterString += `sepia(${effects.sepia * 100}%) `;
                }
                if (effects.invert > 0) {
                    filterString += `invert(${effects.invert * 100}%) `;
                }
                if (effects.hue !== 0) {
                    filterString += `hue-rotate(${effects.hue}deg) `;
                }
                if (effects.saturation !== 1) {
                    filterString += `saturate(${effects.saturation}) `;
                }
                if (effects.brightness !== 1) {
                    filterString += `brightness(${effects.brightness}) `;
                }
                if (effects.contrast !== 1) {
                    filterString += `contrast(${effects.contrast}) `;
                }
            }
            
            // Apply artistic effects
            if (videoParams.artisticEffects) {
                const effects = videoParams.artisticEffects;
                if (effects.posterize > 0) {
                    // Note: CSS doesn't have posterize, this would need custom implementation
                    filterString += `contrast(${1 + effects.posterize}) `;
                }
                if (effects.blur > 0) {
                    filterString += `blur(${effects.blur}px) `;
                }
                if (effects.sharpen > 0) {
                    filterString += `contrast(${1 + effects.sharpen}) `;
                }
            }
            
            videoElement.style.filter = filterString.trim();
            console.log('🎬 Applied filter string:', filterString.trim());
        }
        
        recordParameterChange(recommendations) {
            this.parameterHistory.push({
                timestamp: Date.now(),
                parameters: recommendations,
                scope: this.autopilot.scope,
                genre: this.autopilot.currentGenre
            });
            
            // Keep only recent history (last 50 changes)
            if (this.parameterHistory.length > 50) {
                this.parameterHistory = this.parameterHistory.slice(-50);
            }
        }
        
        // Track user manual parameter adjustments
        trackUserAdjustment(parameterName, oldValue, newValue, context) {
            const change = Math.abs(newValue - oldValue);
            
            // Only track significant changes
            if (change < this.adjustmentThreshold) return;
            
            const adjustment = {
                parameter: parameterName,
                oldValue: oldValue,
                newValue: newValue,
                change: change,
                direction: newValue > oldValue ? 'increase' : 'decrease',
                timestamp: Date.now(),
                context: context || {}
            };
            
            this.userAdjustments.push(adjustment);
            this.lastUserAdjustment = adjustment;
            
            // Keep only recent adjustments (last 100)
            if (this.userAdjustments.length > 100) {
                this.userAdjustments = this.userAdjustments.slice(-100);
            }
            
            // Learn from this adjustment
            this.learnFromUserAdjustment(adjustment);
            
            console.log(`👤 User adjusted ${parameterName}: ${oldValue.toFixed(3)} → ${newValue.toFixed(3)}`);
        }
        
        // Learn from user adjustments
        learnFromUserAdjustment(adjustment) {
            if (!this.autopilot.patternLearning) return;
            
            const context = {
                genre: this.autopilot.currentGenre,
                energy: this.autopilot.audioAnalyzer.getEnergy(),
                tempo: this.autopilot.audioAnalyzer.getTempo(),
                parameter: adjustment.parameter,
                direction: adjustment.direction
            };
            
            // Learn that user prefers this adjustment in this context
            this.autopilot.patternLearning.learnFromUserBehavior(
                'parameter_adjustment',
                JSON.stringify(context),
                'positive' // User made the change, so they prefer it
            );
            
            // Store the adjustment pattern for future recommendations
            this.storeAdjustmentPattern(adjustment, context);
        }
        
        // Store adjustment patterns for future use
        storeAdjustmentPattern(adjustment, context) {
            const patternKey = `${context.genre}_${adjustment.parameter}_${context.direction}`;
            
            if (!this.autopilot.userPreferences.adjustmentPatterns) {
                this.autopilot.userPreferences.adjustmentPatterns = {};
            }
            
            if (!this.autopilot.userPreferences.adjustmentPatterns[patternKey]) {
                this.autopilot.userPreferences.adjustmentPatterns[patternKey] = {
                    count: 0,
                    avgChange: 0,
                    contexts: []
                };
            }
            
            const pattern = this.autopilot.userPreferences.adjustmentPatterns[patternKey];
            pattern.count++;
            pattern.avgChange = (pattern.avgChange * (pattern.count - 1) + adjustment.change) / pattern.count;
            pattern.contexts.push({
                context: context,
                adjustment: adjustment,
                timestamp: Date.now()
            });
            
            // Keep only recent contexts (last 20)
            if (pattern.contexts.length > 20) {
                pattern.contexts = pattern.contexts.slice(-20);
            }
            
            // Save updated preferences
            this.autopilot.saveUserPreferences();
        }
        
        // Get user preference-based recommendations
        getUserPreferenceRecommendations(genre, audioFeatures) {
            if (!this.autopilot.userPreferences.adjustmentPatterns) {
                return null;
            }
            
            const recommendations = {};
            const patterns = this.autopilot.userPreferences.adjustmentPatterns;
            
            // Look for patterns that match current context
            Object.keys(patterns).forEach(patternKey => {
                const [patternGenre, parameter, direction] = patternKey.split('_');
                
                if (patternGenre === genre && patterns[patternKey].count >= 3) {
                    const pattern = patterns[patternKey];
                    const currentValue = this.getCurrentParameterValue(parameter);
                    
                    if (currentValue !== null) {
                        // Apply user's preferred adjustment
                        const adjustment = pattern.avgChange * (direction === 'increase' ? 1 : -1);
                        recommendations[parameter] = Math.max(0, Math.min(1, currentValue + adjustment));
                    }
                }
            });
            
            return Object.keys(recommendations).length > 0 ? recommendations : null;
        }
        
        // Get current value of a parameter
        getCurrentParameterValue(parameterName) {
            if (!this.visualizer.audioMotion) return null;
            
            const audioMotion = this.visualizer.audioMotion;
            return audioMotion[parameterName] || null;
        }
        
        // Record user feedback (thumbs up/down)
        recordUserFeedback(feedback, context) {
            const feedbackEntry = {
                feedback: feedback, // 'positive' or 'negative'
                context: context,
                timestamp: Date.now()
            };
            
            this.feedbackHistory.push(feedbackEntry);
            
            // Keep only recent feedback (last 50)
            if (this.feedbackHistory.length > 50) {
                this.feedbackHistory = this.feedbackHistory.slice(-50);
            }
            
            // Learn from feedback
            this.learnFromFeedback(feedbackEntry);
            
            console.log(`👤 User feedback: ${feedback}`, context);
        }
        
        // Learn from user feedback
        learnFromFeedback(feedbackEntry) {
            if (!this.autopilot.patternLearning) return;
            
            const context = {
                genre: this.autopilot.currentGenre,
                energy: this.autopilot.audioAnalyzer.getEnergy(),
                tempo: this.autopilot.audioAnalyzer.getTempo(),
                ...feedbackEntry.context
            };
            
            this.autopilot.patternLearning.learnFromUserBehavior(
                'user_feedback',
                JSON.stringify(context),
                feedbackEntry.feedback
            );
        }
        
        // Get feedback statistics
        getFeedbackStats() {
            const total = this.feedbackHistory.length;
            const positive = this.feedbackHistory.filter(f => f.feedback === 'positive').length;
            const negative = this.feedbackHistory.filter(f => f.feedback === 'negative').length;
            
            return {
                total: total,
                positive: positive,
                negative: negative,
                satisfaction: total > 0 ? positive / total : 0
            };
        }
        
        getCurrentParameters() {
            return this.currentParameters;
        }
        
        getParameterHistory() {
            return this.parameterHistory;
        }
    }

    // Genre Detector for Enhanced Autopilot
    class GenreDetector {
        constructor(autopilot) {
            this.autopilot = autopilot;
            this.audioAnalyzer = autopilot.audioAnalyzer;
            this.detectionHistory = [];
            this.genreConfidence = {};
            
            console.log('🎵 Genre Detector initialized');
        }
        
        detectGenre(audioFeatures) {
            const energy = audioFeatures.energy || 0.5;
            const tempo = audioFeatures.tempo || 120;
            const dominantFreq = audioFeatures.dominantFreq || 0.5;
            const energyTrend = audioFeatures.energyTrend || 0;
            
            // Simple rule-based genre detection
            const genreScores = this.calculateGenreScores(energy, tempo, dominantFreq, energyTrend);
            const bestGenre = this.selectBestGenre(genreScores);
            
            // Record detection
            this.detectionHistory.push({
                timestamp: Date.now(),
                audioFeatures: { energy, tempo, dominantFreq, energyTrend },
                genreScores,
                selectedGenre: bestGenre
            });
            
            // Keep only recent history (last 100 detections)
            if (this.detectionHistory.length > 100) {
                this.detectionHistory = this.detectionHistory.slice(-100);
            }
            
            return bestGenre;
        }
        
        calculateGenreScores(energy, tempo, dominantFreq, energyTrend) {
            const scores = {};
            
            // Heavy Metal: High energy, fast tempo, bass-heavy, aggressive dynamics
            scores['heavy-metal'] = this.calculateScore(energy, tempo, dominantFreq, energyTrend, {
                energyWeight: 0.4, energyTarget: 0.8,
                tempoWeight: 0.3, tempoTarget: 160,
                freqWeight: 0.2, freqTarget: 0.2, // Bass-heavy
                trendWeight: 0.1, trendTarget: 0.1 // Aggressive
            });
            
            // Rock: High energy, medium-fast tempo, balanced frequency
            scores['rock'] = this.calculateScore(energy, tempo, dominantFreq, energyTrend, {
                energyWeight: 0.6, energyTarget: 0.5, // Medium-high energy
                tempoWeight: 0.4, tempoTarget: 120, // Medium-fast tempo
                freqWeight: 0.0, freqTarget: 0.5, // Frequency less important
                trendWeight: 0.0, trendTarget: 0.0 // Trend less important
            });
            
            // Electronic: Very high energy, very fast tempo, treble-heavy, pulsing
            scores['electronic'] = this.calculateScore(energy, tempo, dominantFreq, energyTrend, {
                energyWeight: 0.4, energyTarget: 0.9,
                tempoWeight: 0.3, tempoTarget: 180,
                freqWeight: 0.2, freqTarget: 0.8, // Treble-heavy
                trendWeight: 0.1, trendTarget: 0.15 // Pulsing
            });
            
            // Reggae: Medium energy, slow-medium tempo, bass-heavy, relaxed
            scores['reggae'] = this.calculateScore(energy, tempo, dominantFreq, energyTrend, {
                energyWeight: 0.4, energyTarget: 0.5,
                tempoWeight: 0.3, tempoTarget: 100,
                freqWeight: 0.2, freqTarget: 0.2, // Bass-heavy
                trendWeight: 0.1, trendTarget: -0.05 // Relaxed
            });
            
            // Country: Low-medium energy, slow-medium tempo, mid-heavy, gentle
            scores['country'] = this.calculateScore(energy, tempo, dominantFreq, energyTrend, {
                energyWeight: 0.6, energyTarget: 0.2, // Much lower energy
                tempoWeight: 0.4, tempoTarget: 80, // Much slower tempo
                freqWeight: 0.0, freqTarget: 0.7, // Frequency less important
                trendWeight: 0.0, trendTarget: -0.05 // Trend less important
            });
            
            // Funk: Medium-high energy, medium tempo, bass-heavy, groovy
            scores['funk'] = this.calculateScore(energy, tempo, dominantFreq, energyTrend, {
                energyWeight: 0.4, energyTarget: 0.6,
                tempoWeight: 0.3, tempoTarget: 120,
                freqWeight: 0.2, freqTarget: 0.3, // Bass-heavy
                trendWeight: 0.1, trendTarget: 0.0 // Groovy
            });
            
            // Ambient: Very low energy, very slow tempo, balanced, ethereal
            scores['ambient'] = this.calculateScore(energy, tempo, dominantFreq, energyTrend, {
                energyWeight: 0.5, energyTarget: 0.15, // Very low energy
                tempoWeight: 0.3, tempoTarget: 50, // Very slow tempo
                freqWeight: 0.15, freqTarget: 0.5, // Balanced
                trendWeight: 0.05, trendTarget: -0.1 // Ethereal
            });
            
            // Punk: Very high energy, very fast tempo, treble-heavy, chaotic
            scores['punk'] = this.calculateScore(energy, tempo, dominantFreq, energyTrend, {
                energyWeight: 0.4, energyTarget: 0.95,
                tempoWeight: 0.3, tempoTarget: 200,
                freqWeight: 0.2, freqTarget: 0.9, // Treble-heavy
                trendWeight: 0.1, trendTarget: 0.2 // Chaotic
            });
            
            // Jazz: Medium energy, variable tempo, mid-heavy, smooth
            scores['jazz'] = this.calculateScore(energy, tempo, dominantFreq, energyTrend, {
                energyWeight: 0.4, energyTarget: 0.5,
                tempoWeight: 0.2, tempoTarget: 120, // Variable tempo
                freqWeight: 0.3, freqTarget: 0.6, // Mid-heavy
                trendWeight: 0.1, trendTarget: 0.0 // Smooth
            });
            
            // Classical: Low-medium energy, slow-medium tempo, balanced, gentle
            scores['classical'] = this.calculateScore(energy, tempo, dominantFreq, energyTrend, {
                energyWeight: 0.4, energyTarget: 0.4,
                tempoWeight: 0.3, tempoTarget: 100,
                freqWeight: 0.2, freqTarget: 0.5, // Balanced
                trendWeight: 0.1, trendTarget: -0.05 // Gentle
            });
            
            return scores;
        }
        
        calculateScore(energy, tempo, dominantFreq, energyTrend, targets) {
            // Calculate individual component scores (0-1 range) with very strict penalties
            const energyDiff = Math.abs(energy - targets.energyTarget);
            const energyScore = Math.max(0, 1 - energyDiff * targets.energyWeight * 4); // Very strict penalty
            
            // Special handling for tempo=0 (no tempo detected) - give lower score
            let tempoScore;
            if (tempo === 0) {
                tempoScore = 0.2; // Much lower score when no tempo detected
            } else {
                const tempoDiff = Math.abs(tempo - targets.tempoTarget) / 200;
                tempoScore = Math.max(0, 1 - tempoDiff * targets.tempoWeight * 3); // Very strict penalty
            }
            
            const freqDiff = Math.abs(dominantFreq - targets.freqTarget);
            const freqScore = Math.max(0, 1 - freqDiff * targets.freqWeight * 4); // Very strict penalty
            
            const trendDiff = Math.abs(energyTrend - targets.trendTarget);
            const trendScore = Math.max(0, 1 - trendDiff * targets.trendWeight * 4); // Very strict penalty
            
            // Weighted average with very strict scoring
            const totalWeight = targets.energyWeight + targets.tempoWeight + targets.freqWeight + targets.trendWeight;
            const weightedScore = (energyScore * targets.energyWeight + 
                                 tempoScore * targets.tempoWeight + 
                                 freqScore * targets.freqWeight + 
                                 trendScore * targets.trendWeight) / totalWeight;
            
            // Apply additional penalty for very poor matches
            const finalScore = weightedScore < 0.4 ? weightedScore * 0.3 : weightedScore;
            
            return Math.max(0, Math.min(1, finalScore));
        }
        
        selectBestGenre(genreScores) {
            let bestGenre = 'electronic'; // Default fallback
            let bestScore = 0;
            
            // Debug logging
            console.log('🎵 Genre Scores:', genreScores);
            
            for (const [genre, score] of Object.entries(genreScores)) {
                if (score > bestScore) {
                    bestScore = score;
                    bestGenre = genre;
                }
            }
            
            console.log(`🎵 Selected Genre: ${bestGenre} (confidence: ${bestScore.toFixed(3)})`);
            
            return {
                genre: bestGenre,
                confidence: bestScore,
                allScores: genreScores
            };
        }
        
        getDetectionHistory() {
            return this.detectionHistory;
        }
        
        getGenreConfidence() {
            return this.genreConfidence;
        }
    }

    // Harmonic Analysis Engine for Enhanced Audio Analysis
    class HarmonicAnalyzer {
        constructor(audioAnalyzer) {
            this.audioAnalyzer = audioAnalyzer;
            this.isRunning = false;
            
            // Harmonic analysis parameters
            this.chordDetectionThreshold = 0.3;
            this.harmonicWindow = 60; // frames for harmonic analysis
            this.keyDetectionWindow = 300; // 5 seconds for key detection
            
            // Current harmonic data
            this.currentChord = null;
            this.chordConfidence = 0;
            this.currentKey = null;
            this.keyConfidence = 0;
            this.harmonicProgression = [];
            
            // History for analysis
            this.chordHistory = [];
            this.keyHistory = [];
            this.harmonicContent = [];
            
            // Musical note frequencies (A4 = 440Hz)
            this.noteFrequencies = this.generateNoteFrequencies();
            this.chordPatterns = this.initializeChordPatterns();
            
            console.log('🎼 Harmonic Analyzer initialized');
        }
        
        start() {
            if (this.isRunning) return;
            this.isRunning = true;
            this.analyzeHarmonics();
            console.log('🎼 Harmonic analysis started');
        }
        
        stop() {
            this.isRunning = false;
            console.log('🎼 Harmonic analysis stopped');
        }
        
        analyzeHarmonics() {
            if (!this.isRunning) return;
            
            try {
                if (this.audioAnalyzer && this.audioAnalyzer.audioMotion && this.audioAnalyzer.audioMotion.analyser) {
                    this.detectChord();
                    this.detectKey();
                    this.analyzeHarmonicProgression();
                }
            } catch (error) {
                console.error('Harmonic analysis error:', error);
            }
            
            if (this.isRunning) {
                requestAnimationFrame(() => this.analyzeHarmonics());
            }
        }
        
        detectChord() {
            const analyser = this.audioAnalyzer.audioMotion.analyser;
            const dataArray = new Uint8Array(analyser.frequencyBinCount);
            analyser.getByteFrequencyData(dataArray);
            
            // Convert frequency data to note strengths
            const noteStrengths = this.analyzeNoteStrengths(dataArray);
            
            // Find the strongest chord match
            const chordMatch = this.findBestChordMatch(noteStrengths);
            
            if (chordMatch.confidence > this.chordDetectionThreshold) {
                this.currentChord = chordMatch.chord;
                this.chordConfidence = chordMatch.confidence;
                
                // Add to history
                this.chordHistory.push({
                    timestamp: Date.now(),
                    chord: this.currentChord,
                    confidence: this.chordConfidence
                });
                
                // Keep only recent history
                if (this.chordHistory.length > 100) {
                    this.chordHistory = this.chordHistory.slice(-100);
                }
            }
        }
        
        detectKey() {
            if (this.chordHistory.length < 10) return;
            
            // Analyze recent chord progression for key detection
            const recentChords = this.chordHistory.slice(-20).map(c => c.chord);
            const keyMatch = this.analyzeKeyFromProgression(recentChords);
            
            if (keyMatch.confidence > 0.4) {
                this.currentKey = keyMatch.key;
                this.keyConfidence = keyMatch.confidence;
                
                // Add to history
                this.keyHistory.push({
                    timestamp: Date.now(),
                    key: this.currentKey,
                    confidence: this.keyConfidence
                });
                
                // Keep only recent history
                if (this.keyHistory.length > 50) {
                    this.keyHistory = this.keyHistory.slice(-50);
                }
            }
        }
        
        analyzeHarmonicProgression() {
            if (this.chordHistory.length < 5) return;
            
            // Analyze chord progression patterns
            const recentChords = this.chordHistory.slice(-10).map(c => c.chord);
            const progression = this.identifyProgressionPattern(recentChords);
            
            if (progression) {
                this.harmonicProgression.push({
                    timestamp: Date.now(),
                    progression: progression
                });
                
                // Keep only recent progressions
                if (this.harmonicProgression.length > 20) {
                    this.harmonicProgression = this.harmonicProgression.slice(-20);
                }
            }
        }
        
        analyzeNoteStrengths(dataArray) {
            const noteStrengths = new Array(12).fill(0); // 12 semitones
            
            for (let i = 0; i < dataArray.length; i++) {
                const frequency = (i * this.audioAnalyzer.audioMotion.analyser.context.sampleRate) / 
                                 (2 * dataArray.length);
                
                if (frequency < 80 || frequency > 2000) continue; // Focus on musical range
                
                // Find closest note
                const noteIndex = this.findClosestNote(frequency);
                const strength = dataArray[i] / 255;
                
                noteStrengths[noteIndex] += strength;
            }
            
            return noteStrengths;
        }
        
        findClosestNote(frequency) {
            const A4 = 440;
            const semitone = Math.round(12 * Math.log2(frequency / A4));
            return ((semitone % 12) + 12) % 12;
        }
        
        findBestChordMatch(noteStrengths) {
            let bestMatch = { chord: null, confidence: 0 };
            
            for (const [chordName, pattern] of Object.entries(this.chordPatterns)) {
                const confidence = this.calculateChordConfidence(noteStrengths, pattern);
                
                if (confidence > bestMatch.confidence) {
                    bestMatch = { chord: chordName, confidence };
                }
            }
            
            return bestMatch;
        }
        
        calculateChordConfidence(noteStrengths, chordPattern) {
            let totalStrength = 0;
            let chordNotes = 0;
            
            for (let i = 0; i < 12; i++) {
                if (chordPattern[i]) {
                    totalStrength += noteStrengths[i];
                    chordNotes++;
                }
            }
            
            return chordNotes > 0 ? totalStrength / chordNotes : 0;
        }
        
        analyzeKeyFromProgression(chords) {
            // Simple key detection based on chord frequency
            const chordCounts = {};
            chords.forEach(chord => {
                chordCounts[chord] = (chordCounts[chord] || 0) + 1;
            });
            
            // Find most common chord (simplified key detection)
            const mostCommonChord = Object.keys(chordCounts).reduce((a, b) => 
                chordCounts[a] > chordCounts[b] ? a : b
            );
            
            return {
                key: mostCommonChord,
                confidence: chordCounts[mostCommonChord] / chords.length
            };
        }
        
        identifyProgressionPattern(chords) {
            // Simple progression pattern recognition
            if (chords.length < 3) return null;
            
            const patterns = {
                'I-V-vi-IV': ['C', 'G', 'Am', 'F'],
                'vi-IV-I-V': ['Am', 'F', 'C', 'G'],
                'I-vi-IV-V': ['C', 'Am', 'F', 'G']
            };
            
            for (const [patternName, pattern] of Object.entries(patterns)) {
                if (this.matchesPattern(chords, pattern)) {
                    return patternName;
                }
            }
            
            return null;
        }
        
        matchesPattern(chords, pattern) {
            if (chords.length < pattern.length) return false;
            
            const recentChords = chords.slice(-pattern.length);
            return recentChords.every((chord, index) => 
                chord === pattern[index] || chord.includes(pattern[index])
            );
        }
        
        generateNoteFrequencies() {
            const notes = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B'];
            const frequencies = {};
            
            for (let octave = 0; octave < 8; octave++) {
                for (let i = 0; i < 12; i++) {
                    const frequency = 440 * Math.pow(2, (i - 9) / 12 + (octave - 4));
                    frequencies[`${notes[i]}${octave}`] = frequency;
                }
            }
            
            return frequencies;
        }
        
        initializeChordPatterns() {
            return {
                'C': [1, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0], // C-E-G
                'Cm': [1, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0], // C-Eb-G
                'F': [1, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0], // F-A-C
                'G': [0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 1], // G-B-D
                'Am': [1, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0], // A-C-E
                'Dm': [0, 0, 1, 0, 0, 1, 0, 0, 0, 1, 0, 0], // D-F-A
                'Em': [0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 1], // E-G-B
                'Bdim': [0, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0] // B-D-F
            };
        }
        
        // Public getters
        getCurrentChord() { return this.currentChord; }
        getChordConfidence() { return this.chordConfidence; }
        getCurrentKey() { return this.currentKey; }
        getKeyConfidence() { return this.keyConfidence; }
        getHarmonicProgression() { return this.harmonicProgression; }
    }

    // Musical Structure Detection Engine
    class StructureDetector {
        constructor(audioAnalyzer) {
            this.audioAnalyzer = audioAnalyzer;
            this.isRunning = false;
            
            // Structure detection parameters
            this.energyThreshold = 0.1;
            this.tempoThreshold = 10; // BPM change threshold
            this.structureWindow = 300; // 5 seconds for structure analysis
            
            // Current structure data
            this.currentSection = 'unknown';
            this.sectionConfidence = 0;
            this.sectionDuration = 0;
            this.sectionStartTime = 0;
            
            // Structure history
            this.sectionHistory = [];
            this.energyPatterns = [];
            this.tempoPatterns = [];
            
            // Section types and their characteristics
            this.sectionTypes = {
                'intro': { energy: 'low', tempo: 'stable', duration: 'short' },
                'verse': { energy: 'medium', tempo: 'stable', duration: 'medium' },
                'chorus': { energy: 'high', tempo: 'stable', duration: 'medium' },
                'bridge': { energy: 'variable', tempo: 'variable', duration: 'short' },
                'outro': { energy: 'decreasing', tempo: 'decreasing', duration: 'short' }
            };
            
            console.log('🏗️ Structure Detector initialized');
        }
        
        start() {
            if (this.isRunning) return;
            this.isRunning = true;
            this.detectStructure();
            console.log('🏗️ Structure detection started');
        }
        
        stop() {
            this.isRunning = false;
            console.log('🏗️ Structure detection stopped');
        }
        
        detectStructure() {
            if (!this.isRunning) return;
            
            try {
                if (this.audioAnalyzer) {
                    this.analyzeSectionCharacteristics();
                    this.updateSectionHistory();
                }
            } catch (error) {
                console.error('Structure detection error:', error);
            }
            
            if (this.isRunning) {
                requestAnimationFrame(() => this.detectStructure());
            }
        }
        
        analyzeSectionCharacteristics() {
            const energy = this.audioAnalyzer.getEnergy();
            const tempo = this.audioAnalyzer.getTempo();
            const energyTrend = this.audioAnalyzer.getEnergyTrend();
            
            // Store patterns for analysis
            this.energyPatterns.push({
                timestamp: Date.now(),
                energy: energy,
                trend: energyTrend
            });
            
            this.tempoPatterns.push({
                timestamp: Date.now(),
                tempo: tempo
            });
            
            // Keep only recent patterns
            if (this.energyPatterns.length > 300) {
                this.energyPatterns = this.energyPatterns.slice(-300);
            }
            if (this.tempoPatterns.length > 300) {
                this.tempoPatterns = this.tempoPatterns.slice(-300);
            }
            
            // Analyze current section
            this.classifyCurrentSection(energy, tempo, energyTrend);
        }
        
        classifyCurrentSection(energy, tempo, energyTrend) {
            const sectionScores = {};
            
            for (const [sectionType, characteristics] of Object.entries(this.sectionTypes)) {
                let score = 0;
                
                // Energy analysis
                if (characteristics.energy === 'low' && energy < 0.3) score += 0.3;
                else if (characteristics.energy === 'medium' && energy >= 0.3 && energy < 0.7) score += 0.3;
                else if (characteristics.energy === 'high' && energy >= 0.7) score += 0.3;
                else if (characteristics.energy === 'variable') score += 0.2;
                else if (characteristics.energy === 'decreasing' && energyTrend < -0.1) score += 0.3;
                
                // Tempo analysis
                if (characteristics.tempo === 'stable' && this.isTempoStable()) score += 0.3;
                else if (characteristics.tempo === 'variable' && !this.isTempoStable()) score += 0.3;
                else if (characteristics.tempo === 'decreasing' && this.isTempoDecreasing()) score += 0.3;
                
                // Duration analysis
                const currentDuration = Date.now() - this.sectionStartTime;
                if (characteristics.duration === 'short' && currentDuration < 10000) score += 0.2;
                else if (characteristics.duration === 'medium' && currentDuration >= 10000 && currentDuration < 30000) score += 0.2;
                else if (characteristics.duration === 'long' && currentDuration >= 30000) score += 0.2;
                
                sectionScores[sectionType] = score;
            }
            
            // Find best matching section
            const bestSection = Object.keys(sectionScores).reduce((a, b) => 
                sectionScores[a] > sectionScores[b] ? a : b
            );
            
            const confidence = sectionScores[bestSection];
            
            // Update current section if confidence is high enough
            if (confidence > 0.5 && bestSection !== this.currentSection) {
                this.currentSection = bestSection;
                this.sectionConfidence = confidence;
                this.sectionStartTime = Date.now();
                this.sectionDuration = 0;
                
                console.log(`🏗️ Section detected: ${bestSection} (confidence: ${confidence.toFixed(2)})`);
            }
            
            this.sectionDuration = Date.now() - this.sectionStartTime;
        }
        
        isTempoStable() {
            if (this.tempoPatterns.length < 10) return true;
            
            const recentTempos = this.tempoPatterns.slice(-10).map(p => p.tempo);
            const avgTempo = recentTempos.reduce((a, b) => a + b, 0) / recentTempos.length;
            const variance = recentTempos.reduce((sum, tempo) => sum + Math.pow(tempo - avgTempo, 2), 0) / recentTempos.length;
            
            return Math.sqrt(variance) < this.tempoThreshold;
        }
        
        isTempoDecreasing() {
            if (this.tempoPatterns.length < 20) return false;
            
            const recentTempos = this.tempoPatterns.slice(-20).map(p => p.tempo);
            const firstHalf = recentTempos.slice(0, 10);
            const secondHalf = recentTempos.slice(10);
            
            const firstAvg = firstHalf.reduce((a, b) => a + b, 0) / firstHalf.length;
            const secondAvg = secondHalf.reduce((a, b) => a + b, 0) / secondHalf.length;
            
            return secondAvg < firstAvg - 5; // 5 BPM decrease
        }
        
        updateSectionHistory() {
            this.sectionHistory.push({
                timestamp: Date.now(),
                section: this.currentSection,
                confidence: this.sectionConfidence,
                duration: this.sectionDuration
            });
            
            // Keep only recent history
            if (this.sectionHistory.length > 100) {
                this.sectionHistory = this.sectionHistory.slice(-100);
            }
        }
        
        // Public getters
        getCurrentSection() { return this.currentSection; }
        getSectionConfidence() { return this.sectionConfidence; }
        getSectionDuration() { return this.sectionDuration; }
        getSectionHistory() { return this.sectionHistory; }
    }

    // Enhanced Audio Analysis Engine for AI Autopilot
    class AudioAnalyzer {
        constructor(audioMotion) {
            this.audioMotion = audioMotion;
            this.isRunning = false;
            this.analysisFrame = null;
            
            // Analysis parameters
            this.beatThreshold = 1.05; // More sensitive beat detection
            this.energySmoothing = 0.9;  // Smoother energy for better beat detection
            this.tempoWindow = 120; // frames for tempo analysis
            
            // Current analysis data
            this.currentEnergy = 0;
            this.smoothedEnergy = 0;
            this.beatDetected = false;
            this.currentTempo = 0;
            
            // History for analysis
            this.energyHistory = new Array(60).fill(0); // 1 second at 60fps
            this.beatHistory = [];
            this.tempoHistory = [];
            
            // Enhanced analysis components
            this.harmonicAnalyzer = new HarmonicAnalyzer(this);
            this.structureDetector = new StructureDetector(this);
            
            console.log('🎵 Enhanced Audio Analyzer initialized');
        }
        
        start() {
            if (this.isRunning) return;
            this.isRunning = true;
            
            // Debug the audioMotion connection
            console.log('🔍 AudioMotion debug:', {
                audioMotion: !!this.audioMotion,
                analyser: !!(this.audioMotion && this.audioMotion.analyser),
                frequencyBinCount: this.audioMotion?.analyser?.frequencyBinCount
            });
            
            // Start enhanced analysis components
            this.harmonicAnalyzer.start();
            this.structureDetector.start();
            
            this.analyze();
            console.log('🎵 Enhanced audio analysis started');
        }
        
        stop() {
            this.isRunning = false;
            if (this.analysisFrame) {
                cancelAnimationFrame(this.analysisFrame);
                this.analysisFrame = null;
            }
            
            // Stop enhanced analysis components
            this.harmonicAnalyzer.stop();
            this.structureDetector.stop();
            
            console.log('🎵 Enhanced audio analysis stopped');
        }
        
        analyze() {
            if (!this.isRunning) return;
            
            try {
                // Get current audio data
                if (this.audioMotion && this.audioMotion.analyser) {
                    this.extractAudioFeatures();
                    this.detectBeats();
                    this.calculateTempo();
                    this.updateEnergyHistory();
                    
                    // Debug output every 60 frames (1 second)
                    if (this.analysisFrame && this.analysisFrame % 60 === 0) {
                        const chord = this.harmonicAnalyzer.getCurrentChord();
                        const key = this.harmonicAnalyzer.getCurrentKey();
                        const section = this.structureDetector.getCurrentSection();
                        
                        console.log(`🎵 Enhanced Analysis: Energy=${this.currentEnergy.toFixed(3)}, Beat=${this.beatDetected}, Tempo=${this.currentTempo}, Freq=${this.dominantFreq}`);
                        console.log(`🎼 Harmonic: Chord=${chord || 'none'}, Key=${key || 'none'}`);
                        console.log(`🏗️ Structure: Section=${section}, Duration=${this.structureDetector.getSectionDuration()}ms`);
                    }
                } else {
                    // Debug: Check why audio data isn't available
                    if (this.analysisFrame && this.analysisFrame % 300 === 0) { // Every 5 seconds
                        console.warn('⚠️ AudioMotion or analyser not available:', {
                            audioMotion: !!this.audioMotion,
                            analyser: !!(this.audioMotion && this.audioMotion.analyser)
                        });
                    }
                }
            } catch (error) {
                console.error('Audio analysis error:', error);
            }
            
            this.analysisFrame = requestAnimationFrame(() => this.analyze());
        }
        
        extractAudioFeatures() {
            // Extract energy and frequency data
            const analyser = this.audioMotion.analyser;
            const dataArray = new Uint8Array(analyser.frequencyBinCount);
            analyser.getByteFrequencyData(dataArray);
            
            // Calculate overall energy (RMS)
            let totalEnergy = 0;
            for (let i = 0; i < dataArray.length; i++) {
                totalEnergy += dataArray[i] * dataArray[i];
            }
            this.currentEnergy = Math.sqrt(totalEnergy / dataArray.length) / 255;
            
            // Smooth energy for stability
            this.smoothedEnergy = this.smoothedEnergy * this.energySmoothing + 
                                 this.currentEnergy * (1 - this.energySmoothing);
            
            // Frequency band analysis
            this.analyzeFrequencyBands(dataArray);
            
            // Spectral flux for better beat detection
            this.calculateSpectralFlux(dataArray);
        }
        
        analyzeFrequencyBands(dataArray) {
            const binCount = dataArray.length;
            const bassEnd = Math.floor(binCount * 0.1);     // 0-10% (bass)
            const midEnd = Math.floor(binCount * 0.5);      // 10-50% (mids) 
            const trebleEnd = binCount;                     // 50-100% (treble)
            
            // Calculate energy in each band
            let bassEnergy = 0, midEnergy = 0, trebleEnergy = 0;
            
            for (let i = 0; i < bassEnd; i++) {
                bassEnergy += dataArray[i] * dataArray[i];
            }
            for (let i = bassEnd; i < midEnd; i++) {
                midEnergy += dataArray[i] * dataArray[i];
            }
            for (let i = midEnd; i < trebleEnd; i++) {
                trebleEnergy += dataArray[i] * dataArray[i];
            }
            
            // Normalize by band size
            this.bassEnergy = Math.sqrt(bassEnergy / bassEnd) / 255;
            this.midEnergy = Math.sqrt(midEnergy / (midEnd - bassEnd)) / 255;
            this.trebleEnergy = Math.sqrt(trebleEnergy / (trebleEnd - midEnd)) / 255;
            
            // Determine dominant frequency
            this.dominantFreq = 'mid';
            if (this.bassEnergy > this.midEnergy && this.bassEnergy > this.trebleEnergy) {
                this.dominantFreq = 'bass';
            } else if (this.trebleEnergy > this.midEnergy && this.trebleEnergy > this.bassEnergy) {
                this.dominantFreq = 'treble';
            }
        }
        
        calculateSpectralFlux(dataArray) {
            // Store previous frame for flux calculation
            if (!this.previousSpectrum) {
                this.previousSpectrum = new Uint8Array(dataArray.length);
                this.spectralFlux = 0;
                return;
            }
            
            // Calculate spectral flux (change between frames)
            let flux = 0;
            for (let i = 0; i < dataArray.length; i++) {
                const diff = dataArray[i] - this.previousSpectrum[i];
                flux += diff > 0 ? diff : 0; // Only positive changes (onset)
            }
            
            this.spectralFlux = flux / dataArray.length / 255;
            
            // Update previous spectrum
            this.previousSpectrum.set(dataArray);
        }
        
        detectBeats() {
            // Enhanced beat detection using both energy and spectral flux
            const energyIncrease = this.currentEnergy / (this.smoothedEnergy + 0.001);
            const fluxThreshold = 0.05; // More sensitive flux detection
            
            // Beat detected if energy spike OR significant spectral change
            this.beatDetected = (energyIncrease > this.beatThreshold) || 
                               (this.spectralFlux > fluxThreshold);
            
            if (this.beatDetected) {
                const now = Date.now();
                const lastBeat = this.beatHistory[this.beatHistory.length - 1] || 0;
                
                // Prevent beats too close together (minimum 100ms apart)
                if (now - lastBeat > 100) {
                    this.beatHistory.push(now);
                    // Keep only recent beats (last 10 seconds)
                    this.beatHistory = this.beatHistory.filter(time => now - time < 10000);
                    
                    // Log beat detection for debugging (every 4 beats)
                    if (this.beatHistory.length % 4 === 0) {
                        console.log(`🥁 Beat detected - Energy: ${energyIncrease.toFixed(2)}, Flux: ${this.spectralFlux.toFixed(3)}, BPM: ${this.currentTempo}`);
                    }
                }
            }
        }
        
        calculateTempo() {
            if (this.beatHistory.length < 4) return;
            
            // Calculate intervals between recent beats
            const intervals = [];
            for (let i = 1; i < Math.min(this.beatHistory.length, 8); i++) {
                const interval = this.beatHistory[i] - this.beatHistory[i-1];
                // Filter out unrealistic intervals (too fast/slow)
                if (interval > 200 && interval < 2000) { // 30-300 BPM range
                    intervals.push(interval);
                }
            }
            
            if (intervals.length > 0) {
                // Find most common interval (tempo)
                const avgInterval = intervals.reduce((a, b) => a + b, 0) / intervals.length;
                this.currentTempo = Math.round(60000 / avgInterval); // Convert to BPM
                
                // Clamp to realistic range
                this.currentTempo = Math.max(60, Math.min(200, this.currentTempo));
            }
        }
        
        updateEnergyHistory() {
            this.energyHistory.shift();
            this.energyHistory.push(this.currentEnergy);
        }
        
        // Public getters for decision engine
        getEnergy() { return this.smoothedEnergy; }
        getBeat() { return this.beatDetected; }
        getTempo() { return this.currentTempo; }
        getEnergyTrend() {
            const recent = this.energyHistory.slice(-30); // Last 0.5 seconds
            const older = this.energyHistory.slice(-60, -30); // Previous 0.5 seconds
            const recentAvg = recent.reduce((a, b) => a + b, 0) / recent.length;
            const olderAvg = older.reduce((a, b) => a + b, 0) / older.length;
            return recentAvg - olderAvg; // Positive = increasing energy
        }
        
        // Enhanced method for genre detection and parameter control
        getCurrentFeatures() {
            // Convert dominantFreq string to numeric value for genre detection
            let dominantFreqNumeric = 0.5; // Default to mid
            if (this.dominantFreq === 'bass') dominantFreqNumeric = 0.2;
            else if (this.dominantFreq === 'treble') dominantFreqNumeric = 0.8;
            else if (this.dominantFreq === 'mid') dominantFreqNumeric = 0.5;
            
            // Estimate tempo from energy if no tempo detected yet
            let estimatedTempo = this.currentTempo;
            if (estimatedTempo === 0 && this.smoothedEnergy > 0.1) {
                // Estimate tempo based on energy level
                if (this.smoothedEnergy > 0.4) estimatedTempo = 140; // High energy = fast tempo
                else if (this.smoothedEnergy > 0.2) estimatedTempo = 120; // Medium energy = medium tempo
                else estimatedTempo = 100; // Low energy = slow tempo
            }
            
            return {
                // Basic audio features
                energy: this.smoothedEnergy,
                beat: this.beatDetected,
                tempo: estimatedTempo,
                dominantFreq: dominantFreqNumeric,
                energyTrend: this.getEnergyTrend(),
                beatStrength: this.beatDetected ? this.currentEnergy / (this.smoothedEnergy + 0.001) : 0,
                frequencyBands: {
                    bass: this.bassEnergy || 0,
                    mid: this.midEnergy || 0,
                    treble: this.trebleEnergy || 0
                },
                spectralFlux: this.spectralFlux || 0,
                
                // Enhanced harmonic features
                harmonic: {
                    chord: this.harmonicAnalyzer.getCurrentChord(),
                    chordConfidence: this.harmonicAnalyzer.getChordConfidence(),
                    key: this.harmonicAnalyzer.getCurrentKey(),
                    keyConfidence: this.harmonicAnalyzer.getKeyConfidence(),
                    progression: this.harmonicAnalyzer.getHarmonicProgression()
                },
                
                // Enhanced structure features
                structure: {
                    section: this.structureDetector.getCurrentSection(),
                    sectionConfidence: this.structureDetector.getSectionConfidence(),
                    sectionDuration: this.structureDetector.getSectionDuration(),
                    sectionHistory: this.structureDetector.getSectionHistory()
                }
            };
        }
    }

    // Decision Engine for AI Autopilot
    class DecisionEngine {
        constructor(autopilot) {
            this.autopilot = autopilot;
            this.visualizer = autopilot.visualizer;
            this.audioAnalyzer = autopilot.audioAnalyzer;
            
            this.isRunning = false;
            this.decisionFrame = null;
            this.lastDecision = 0;
            this.decisionCooldown = 500; // Minimum 0.5 seconds between major changes
            
            // Available visualization modes
            this.visualizationModes = [
                { id: 0, name: 'Spectrum', energy: 'any', tempo: 'any' },
                { id: 1, name: 'Mirror Wave', energy: 'medium', tempo: 'medium' },
                { id: 2, name: 'Classic LED', energy: 'low', tempo: 'slow' },
                { id: 3, name: 'Stereo', energy: 'any', tempo: 'any' },
                { id: 4, name: 'Radial Spectrum', energy: 'high', tempo: 'fast' },
                { id: 5, name: 'Energy', energy: 'high', tempo: 'any' },
                { id: 6, name: 'Mirror', energy: 'medium', tempo: 'any' }
            ];
            
            console.log('🧠 Decision Engine initialized');
        }
        
        start() {
            if (this.isRunning) return;
            this.isRunning = true;
            this.makeDecisions();
            console.log('🧠 Decision Engine started');
        }
        
        stop() {
            this.isRunning = false;
            if (this.decisionFrame) {
                cancelAnimationFrame(this.decisionFrame);
                this.decisionFrame = null;
            }
            console.log('🧠 Decision Engine stopped');
        }
        
        makeDecisions() {
            if (!this.isRunning) return;
            
            try {
                const now = Date.now();
                
                // Only make decisions periodically to avoid chaos
                if (now - this.lastDecision > this.decisionCooldown) {
                    // Use enhanced decision making with parameter control
                    this.autopilot.makeAdvancedDecisions();
                    this.lastDecision = now; // Update last decision time
                }
                
            } catch (error) {
                console.error('Decision engine error:', error);
            }
            
            this.decisionFrame = requestAnimationFrame(() => this.makeDecisions());
        }
        
        evaluateVisualizationChange() {
            const energy = this.audioAnalyzer.getEnergy();
            const beat = this.audioAnalyzer.getBeat();
            const dominantFreq = this.audioAnalyzer.dominantFreq;
            const energyTrend = this.audioAnalyzer.getEnergyTrend();
            const tempo = this.audioAnalyzer.getTempo();
            
            // Debug logging
            console.log('🎯 Visualization Change Evaluation:', {
                energy: energy?.toFixed(3),
                beat: beat,
                dominantFreq: dominantFreq,
                energyTrend: energyTrend?.toFixed(3),
                tempo: tempo,
                currentMode: this.visualizer.currentMode,
                scope: this.autopilot.scope
            });
            
            // For specific scopes (radial, energy), only switch if not already in the correct mode
            if (this.autopilot.scope === 'radial' || this.autopilot.scope === 'energy') {
                const expectedMode = this.autopilot.scope === 'radial' ? 4 : 5;
                console.log(`🎯 Scope check: Current mode ${this.visualizer.currentMode}, Expected mode ${expectedMode} for scope ${this.autopilot.scope}`);
                if (this.visualizer.currentMode !== expectedMode) {
                    console.log(`🎯 Scope enforcement: Switching to ${this.autopilot.scope} mode (${expectedMode})`);
                    this.applyModeChange(expectedMode);
                    this.autopilot.recordModeChange(expectedMode);
                    this.lastDecision = Date.now();
                } else {
                    console.log(`🎯 Scope enforcement: Already in correct mode ${expectedMode} for scope ${this.autopilot.scope}`);
                }
                return; // Don't run normal decision logic for specific scopes
            }
            
            // Intelligent mode selection based on multiple factors (only for 'bars' and 'all' scopes)
            let targetMode = this.selectOptimalMode(energy, dominantFreq, tempo, energyTrend);
            
            // Switch if mode is different and conditions are met (less restrictive)
            const shouldSwitch = targetMode !== this.visualizer.currentMode && 
                               this.shouldSwitchMode(targetMode, energy) &&
                               (beat || energy > 0.1 || Math.random() < 0.1); // More responsive switching
            
            console.log('🎯 Switch Decision:', {
                shouldSwitch: shouldSwitch,
                beat: beat,
                targetMode: targetMode,
                currentMode: this.visualizer.currentMode,
                shouldSwitchMode: this.shouldSwitchMode(targetMode, energy)
            });
            
            if (shouldSwitch) {
                this.applyModeChange(targetMode);
                this.autopilot.recordModeChange(targetMode);
                this.lastDecision = Date.now();
                
                // Log detailed switch reasoning
                console.log(`🎨 Autopilot: ${this.getModeName(this.visualizer.currentMode)} → ${this.getModeName(targetMode)}`);
                console.log(`   Energy: ${energy.toFixed(2)}, Freq: ${dominantFreq}, BPM: ${tempo}, Trend: ${energyTrend.toFixed(3)}`);
                
                // Evaluate additional automation
                this.evaluateColorSchemeChange(energy, dominantFreq);
                this.evaluateKaleidoscopeActivation(energy, beat);
            }
        }
        
        selectOptimalMode(energy, dominantFreq, tempo, energyTrend) {
            // Get available modes based on scope setting
            const availableModes = this.autopilot.modeGroups[this.autopilot.scope];
            
            console.log(`🎯 Scope: ${this.autopilot.scope}, Available modes:`, availableModes);
            
            // Get enhanced audio features including harmonic and structure analysis
            const audioFeatures = this.audioAnalyzer.getCurrentFeatures();
            const harmonic = audioFeatures.harmonic || {};
            const structure = audioFeatures.structure || {};
            
            // If scope is specific (radial, energy), return that mode directly
            if (this.autopilot.scope === 'radial' && availableModes.includes(4)) {
                return 4; // Radial Spectrum
            }
            if (this.autopilot.scope === 'energy' && availableModes.includes(5)) {
                return 5; // Energy
            }
            if (this.autopilot.scope === 'bars' && availableModes.length > 0) {
                // For bars scope, prefer bar-based visualizations
                const barModes = availableModes.filter(mode => [0, 2, 3].includes(mode));
                return barModes.length > 0 ? barModes[Math.floor(Math.random() * barModes.length)] : availableModes[0];
            }
            
            // Enhanced mode selection with harmonic and structure awareness
            let candidateModes = [];
            
            // Structure-based mode selection (highest priority)
            if (structure.section) {
                switch (structure.section) {
                    case 'intro':
                        // Intro - prefer subtle, building modes
                        candidateModes = availableModes.filter(mode => [0, 4, 5].includes(mode)); // Spectrum, Radial, Wave
                        break;
                    case 'verse':
                        // Verse - balanced, steady modes
                        candidateModes = availableModes.filter(mode => [0, 1, 4, 5].includes(mode)); // Spectrum, Bars, Radial, Wave
                        break;
                    case 'chorus':
                        // Chorus - most dynamic, energetic modes
                        candidateModes = availableModes.filter(mode => [1, 2, 3, 6].includes(mode)); // Bars, Stereo, Mirror, Kaleidoscope
                        break;
                    case 'bridge':
                        // Bridge - unique, experimental modes
                        candidateModes = availableModes.filter(mode => [2, 3, 6].includes(mode)); // Stereo, Mirror, Kaleidoscope
                        break;
                    case 'outro':
                        // Outro - fading, subtle modes
                        candidateModes = availableModes.filter(mode => [0, 4, 5].includes(mode)); // Spectrum, Radial, Wave
                        break;
                }
            }
            
            // Harmonic-based mode selection (if no structure info or as secondary factor)
            if (candidateModes.length === 0 && harmonic.chord) {
                if (harmonic.chord.includes('m')) {
                    // Minor chords - prefer darker, more introspective modes
                    candidateModes = availableModes.filter(mode => [0, 4, 5].includes(mode)); // Spectrum, Radial, Wave
                } else if (harmonic.chord.includes('M') || harmonic.chord.includes('maj')) {
                    // Major chords - prefer brighter, more energetic modes
                    candidateModes = availableModes.filter(mode => [1, 2, 3, 6].includes(mode)); // Bars, Stereo, Mirror, Kaleidoscope
                }
            }
            
            // Energy-based selection (fallback if no structure/harmonic info)
            if (candidateModes.length === 0) {
            // Very high energy
            if (energy > 0.4 && energyTrend > 0.02) {
                candidateModes = availableModes.filter(mode => [4, 5].includes(mode)); // Radial, Energy
            }
            // High energy
            else if (energy > 0.3) {
                candidateModes = availableModes.filter(mode => [1, 5, 4].includes(mode)); // Mirror Wave, Energy, Radial
            }
            // Medium energy
            else if (energy > 0.2) {
                candidateModes = availableModes.filter(mode => [3, 6, 0].includes(mode)); // Stereo, Mirror, Spectrum
            }
            // Rising energy
            else if (energyTrend > 0.01) {
                candidateModes = availableModes.filter(mode => [1, 0].includes(mode)); // Mirror Wave, Spectrum
            }
            // Low energy
            else if (energy > 0.1) {
                candidateModes = availableModes.filter(mode => [0, 2].includes(mode)); // Spectrum, Classic LED
            }
            // Very low energy
            else {
                candidateModes = availableModes.filter(mode => [2].includes(mode)); // Classic LED
                }
            }
            
            // If no candidates match scope, use any available mode
            if (candidateModes.length === 0) {
                candidateModes = availableModes;
            }
            
            // Select random mode from candidates for variety
            return candidateModes[Math.floor(Math.random() * candidateModes.length)];
        }
        
        shouldSwitchMode(targetMode, energy) {
            // Prevent rapid switching only in very low energy situations
            if (energy < 0.02) return false;
            
            // Allow more frequent switching - only prevent immediate repeats
            const recentModes = this.autopilot.modeHistory.slice(-1); // Only prevent immediate repeat
            if (recentModes.includes(targetMode)) return false;
            
            return true;
        }
        
        getModeName(modeId) {
            const mode = this.visualizationModes.find(m => m.id === modeId);
            return mode ? mode.name : `Mode ${modeId}`;
        }
        
        applyModeChange(targetMode) {
            console.log(`🎯 applyModeChange called: ${this.visualizer.currentMode} → ${targetMode}`);
            const timing = this.autopilot.changeTiming;
            
            switch (timing) {
                case 'instant':
                    this.visualizer.setVisualizationMode(targetMode);
                    break;
                case 'smooth':
                    // Add smooth transition (could be implemented with CSS transitions)
                    this.visualizer.setVisualizationMode(targetMode);
                    break;
                case 'slow':
                    // Add delay for slower changes
                    setTimeout(() => {
                        this.visualizer.setVisualizationMode(targetMode);
                    }, 500);
                    break;
                case 'beat-synced':
                    // Wait for next beat to change
                    if (this.audioAnalyzer.getBeat()) {
                        this.visualizer.setVisualizationMode(targetMode);
                    } else {
                        // Store pending change and apply on next beat
                        this.pendingModeChange = targetMode;
                    }
                    break;
                default:
                    this.visualizer.setVisualizationMode(targetMode);
            }
        }
        
        evaluateColorSchemeChange(energy, dominantFreq) {
            // Only change colors if auto color schemes is enabled
            if (!this.autopilot.autoColorSchemes) return;
            
            // More responsive color scheme automation
            if (dominantFreq === 'bass' && energy > 0.15) {
                // Bass-heavy = darker schemes
                this.visualizer.setColorScheme('metal');
                console.log('🎨 Color: Bass-heavy → Metal');
            } else if (dominantFreq === 'treble' && energy > 0.15) {
                // Treble-heavy = brighter schemes  
                this.visualizer.setColorScheme('psychedelic');
                console.log('🎨 Color: Treble-heavy → Psychedelic');
            } else if (energy > 0.2) {
                // Medium energy = vibrant schemes
                this.visualizer.setColorScheme('luigi');
                console.log('🎨 Color: Medium energy → Luigi');
            } else {
                // Low energy = calm schemes
                this.visualizer.setColorScheme('earthtones');
                console.log('🎨 Color: Low energy → Earthtones');
            }
        }
        
        evaluateKaleidoscopeActivation(energy, beat) {
            // Auto-activate kaleidoscope for high energy sections
            if (energy > 0.8 && beat && !this.visualizer.kaleidoscopeEnabled) {
                this.visualizer.toggleKaleidoscope();
                console.log('🔮 Autopilot activated kaleidoscope (high energy)');
            } else if (energy < 0.4 && this.visualizer.kaleidoscopeEnabled) {
                this.visualizer.toggleKaleidoscope();
                console.log('🔮 Autopilot deactivated kaleidoscope (low energy)');
            }
        }
    }

    // ****
    // ****

    // PlaylistManager Class - Handles dynamic playlist creation and management
    class PlaylistManager {
        constructor(visualizer) {
            this.visualizer = visualizer;
            this.currentPlaylist = null;
            this.isScanning = false;
            this.scanCancelled = false;
            this.supportedFormats = ['mp3', 'wav', 'flac', 'm4a', 'aac', 'ogg'];
            this.maxFiles = 250;
            this.defaultArtwork = this.generateDefaultArtwork();
            this.appIcon = this.generateAppIcon();
            this.folderHandle = null;
            this.isBackgroundScanning = false;
            
            // Load cached playlist
            this.loadCachedPlaylist();
            
            // Auto-display cached playlist if it exists
            if (this.currentPlaylist && this.currentPlaylist.tracks && this.currentPlaylist.tracks.length > 0) {
                // Delay to ensure UI is ready
                setTimeout(() => {
                    console.log('Auto-displaying cached playlist...');
                    this.displayPlaylist();
                    this.visualizer.updatePlaylistFromManager(this.currentPlaylist);
                    
                    // Start background rescan to enable playback
                    this.startBackgroundRescan();
                }, 1000);
            }
            
            // Test default artwork generation
            console.log('Default artwork generated:', this.defaultArtwork.substring(0, 50) + '...');
            
            // Test app icon generation
            console.log('App icon generated:', this.appIcon.substring(0, 50) + '...');
            
            // Check music-metadata library availability
            this.checkMetadataLibrary();
            
            // Add test method for debugging
            window.testMetadataExtraction = (file) => this.extractMetadata(file);
            
            // Initialize tabbed interface (Phase 2 - hidden)
            this.initializeTabbedInterface();
            
            // Phase 4: Activate tabbed interface
            document.body.classList.add('tab-interface-active');
            console.log('✓ Tabbed interface activated');
            
            // Phase 3 test: Add temporary test function for Audio + Video tabs
            window.testAudioTab = () => {
                const tabHeader = document.getElementById('tabHeader');
                const audioPanel = document.getElementById('audioPanel');
                const audioTab = document.getElementById('audioTab');
                
                if (tabHeader) tabHeader.style.display = 'flex';
                if (audioPanel) audioPanel.classList.add('show');
                if (audioTab) audioTab.classList.add('active');
                
                console.log('Audio tab test activated');
            };
            
            window.testVideoTab = () => {
                const tabHeader = document.getElementById('tabHeader');
                const videoPanel = document.getElementById('videoPanel');
                const videoTab = document.getElementById('videoTab');
                
                if (tabHeader) tabHeader.style.display = 'flex';
                if (videoPanel) videoPanel.classList.add('show');
                if (videoTab) videoTab.classList.add('active');
                
                console.log('Video tab test activated');
            };
            
            window.testAllTabs = () => {
                const tabHeader = document.getElementById('tabHeader');
                if (tabHeader) tabHeader.style.display = 'flex';
                
                ['audio', 'video', 'visualizations', 'autopilot', 'output'].forEach(section => {
                    const panel = document.getElementById(`${section}Panel`);
                    const tab = document.getElementById(`${section}Tab`);
                    if (panel) panel.classList.add('show');
                    if (tab) tab.classList.add('active');
                });
                
                console.log('All tabs activated for testing - check functionality');
            };
            
            window.testAutopilotTab = () => {
                const tabHeader = document.getElementById('tabHeader');
                const autopilotPanel = document.getElementById('autopilotPanel');
                const autopilotTab = document.getElementById('autopilotTab');
                
                if (tabHeader) tabHeader.style.display = 'flex';
                if (autopilotPanel) autopilotPanel.classList.add('show');
                if (autopilotTab) autopilotTab.classList.add('active');
                
                console.log('Autopilot tab test activated');
            };
            
            window.testVisualizationsTab = () => {
                const tabHeader = document.getElementById('tabHeader');
                const vizPanel = document.getElementById('visualizationsPanel');
                const vizTab = document.getElementById('visualizationsTab');
                
                if (tabHeader) tabHeader.style.display = 'flex';
                if (vizPanel) vizPanel.classList.add('show');
                if (vizTab) vizTab.classList.add('active');
                
                console.log('Visualizations tab test activated');
            };
            
            window.testOutputTab = () => {
                const tabHeader = document.getElementById('tabHeader');
                const outputPanel = document.getElementById('outputPanel');
                const outputTab = document.getElementById('outputTab');
                
                if (tabHeader) tabHeader.style.display = 'flex';
                if (outputPanel) outputPanel.classList.add('show');
                if (outputTab) outputTab.classList.add('active');
                
                console.log('Output tab test activated');
            };
            
            // Add debug for playlist button clicks
            setTimeout(() => {
                const playlistToggle = document.getElementById('playlistToggle');
                if (playlistToggle) {
                    playlistToggle.addEventListener('click', (e) => {
                        console.log('Playlist button clicked in new panel');
                        const dropdown = document.getElementById('playlistDropdown');
                        if (dropdown) {
                            console.log('Dropdown found, content length:', dropdown.innerHTML.length);
                            console.log('Dropdown display:', dropdown.style.display);
                            console.log('Dropdown classes:', dropdown.classList.toString());
                        } else {
                            console.error('Playlist dropdown not found when button clicked');
                        }
                    });
                }
            }, 1000);
        }
        
        generateAppIcon() {
            // Create 60x60 app icon - grey placeholder
            const canvas = document.createElement('canvas');
            canvas.width = 60;
            canvas.height = 60;
            const ctx = canvas.getContext('2d');
            
            // Grey background
            ctx.fillStyle = '#808080';
            ctx.fillRect(0, 0, 60, 60);
            
            // Darker grey border
            ctx.strokeStyle = '#606060';
            ctx.lineWidth = 2;
            ctx.strokeRect(1, 1, 58, 58);
            
            // Simple "V" for Vizzy
            ctx.fillStyle = '#404040';
            ctx.font = 'bold 24px sans-serif';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText('V', 30, 30);
            
            // Convert to JPG data URL
            return canvas.toDataURL('image/jpeg', 0.8);
        }

        generateDefaultArtwork() {
            // Create 240x240 default artwork - grey background with "no music" icon
            const canvas = document.createElement('canvas');
            canvas.width = 240;
            canvas.height = 240;
            const ctx = canvas.getContext('2d');
            
            // Grey background
            ctx.fillStyle = '#808080';
            ctx.fillRect(0, 0, 240, 240);
            
            // Darker grey border
            ctx.strokeStyle = '#606060';
            ctx.lineWidth = 4;
            ctx.strokeRect(2, 2, 236, 236);
            
            // Draw "no music" symbol (musical note with slash)
            ctx.save();
            ctx.translate(120, 120); // Center
            
            // Musical note (simplified)
            ctx.fillStyle = '#404040';
            ctx.beginPath();
            // Note stem
            ctx.rect(15, -40, 8, 60);
            // Note head
            ctx.ellipse(0, 20, 20, 15, 0, 0, Math.PI * 2);
            ctx.fill();
            
            // Red slash
            ctx.strokeStyle = '#ff4444';
            ctx.lineWidth = 12;
            ctx.lineCap = 'round';
            ctx.beginPath();
            ctx.moveTo(-35, -35);
            ctx.lineTo(35, 35);
            ctx.stroke();
            
            ctx.restore();
            
            // Convert to JPG data URL
            return canvas.toDataURL('image/jpeg', 0.8);
        }
        
        populatePlaylistDropdown() {
            const dropdown = document.getElementById('playlistDropdown');
            if (!dropdown) return;
            
            dropdown.innerHTML = `
                <!-- Panel Header with Close Button -->
                <div class="panel-header">
                    <span>Playlist Manager</span>
                    <button class="panel-close-btn" id="playlistPanelClose">×</button>
                </div>
                
                <!-- Playlist Actions -->
                <div class="playlist-actions-dropdown">
                    <button class="playlist-scan-btn" id="playlistScanBtn" title="Add Music Folder">📁 Add Folder</button>
                    <button class="playlist-import-btn" id="playlistImportBtn" title="Import Playlist">📥</button>
                    <button class="playlist-export-btn" id="playlistExportBtn" title="Export Playlist">📤</button>
                </div>
                
                <!-- Scanning Progress (hidden by default) -->
                <div class="playlist-progress" id="playlistProgress" style="display: none;">
                    <div class="progress-bar-container">
                        <div class="progress-bar" id="progressBar"></div>
                    </div>
                    <div class="progress-info">
                        <span class="progress-text" id="progressText">Scanning music folder...</span>
                        <span class="progress-count" id="progressCount">0/0 files</span>
                        <span class="progress-eta" id="progressEta">Est: calculating...</span>
                    </div>
                    <button class="progress-cancel-btn" id="progressCancelBtn">Cancel</button>
                </div>
                
                <!-- Playlist Stats -->
                <div class="playlist-stats" id="playlistStats">
                    <span class="playlist-track-count" id="playlistTrackCount">No tracks loaded</span>
                    <span class="playlist-duration" id="playlistDuration">0:00:00</span>
                </div>
                
                <!-- Tracks Container -->
                <div class="playlist-tracks-container" id="playlistTracksContainer">
                    <div class="playlist-tracks" id="playlistTracks">
                        <!-- Artist groups will be populated here -->
                        <div class="empty-playlist">
                            <div class="empty-playlist-icon">🎵</div>
                            <div class="empty-playlist-text">No music loaded</div>
                            <div class="empty-playlist-subtext">Click "Add Folder" to scan your music library</div>
                        </div>
                    </div>
                </div>
            `;
            
            console.log('Playlist dropdown content populated');
            
            // Re-initialize event handlers after populating content
            if (this.visualizer) {
                this.visualizer.initializePlaylistUI();
            }
            
            // Specifically initialize the close button that was just created
            setTimeout(() => {
                this.initializeCloseButton();
            }, 100);
        }
        
        initializeCloseButton() {
            const closeBtn = document.getElementById('playlistPanelClose');
            console.log('Initializing close button, found:', !!closeBtn);
            
            if (closeBtn) {
                // Remove any existing listeners
                closeBtn.replaceWith(closeBtn.cloneNode(true));
                const newCloseBtn = document.getElementById('playlistPanelClose');
                
                newCloseBtn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    console.log('Close button clicked');
                    this.visualizer.closePlaylistPanel();
                });
                
                console.log('✅ Close button event handler attached');
            } else {
                console.warn('❌ Close button not found for initialization');
            }
        }
        
        showRescanNotification() {
            // Update the empty playlist area to show rescan message
            setTimeout(() => {
                const tracksContainer = document.getElementById('playlistTracks');
                if (tracksContainer && this.currentPlaylist && this.currentPlaylist.tracks.some(track => !track.url)) {
                    // Remove any existing notification
                    const existingNotification = tracksContainer.querySelector('.rescan-notification');
                    if (existingNotification) {
                        existingNotification.remove();
                    }
                    
                    // Add a notification at the top
                    const notification = document.createElement('div');
                    notification.className = 'rescan-notification';
                    
                    const isImported = this.currentPlaylist.folderPath === 'Imported';
                    const message = isImported ? 
                        'Click "Add Folder" to select the music folder for these tracks' :
                        'Click "Add Folder" to rescan the music folder and enable playback';
                    
                    notification.innerHTML = `
                        <div class="notification-icon">ℹ️</div>
                        <div class="notification-text">
                            <strong>${isImported ? 'Imported playlist loaded' : 'Playlist loaded from cache'}</strong><br>
                            <small>${message}</small>
                        </div>
                    `;
                    tracksContainer.insertBefore(notification, tracksContainer.firstChild);
                }
            }, 100);
        }
        
        async initializeIndexedDB() {
            try {
                return new Promise((resolve, reject) => {
                    const request = indexedDB.open('VizzyPlaylistDB', 1);
                    
                    request.onerror = () => reject(request.error);
                    request.onsuccess = () => resolve(request.result);
                    
                    request.onupgradeneeded = (event) => {
                        const db = event.target.result;
                        
                        // Create object store for folder handles
                        if (!db.objectStoreNames.contains('folderHandles')) {
                            const store = db.createObjectStore('folderHandles', { keyPath: 'id' });
                            console.log('Created folderHandles object store');
                        }
                    };
                });
            } catch (error) {
                console.error('IndexedDB initialization failed:', error);
                return null;
            }
        }
        
        async storeFolderHandle(handle, playlistName) {
            try {
                const db = await this.initializeIndexedDB();
                if (!db) return;
                
                const transaction = db.transaction(['folderHandles'], 'readwrite');
                const store = transaction.objectStore('folderHandles');
                
                const folderData = {
                    id: 'currentFolder',
                    handle: handle,
                    name: playlistName,
                    lastAccessed: Date.now()
                };
                
                await store.put(folderData);
                console.log('✅ Folder handle stored in IndexedDB');
                
            } catch (error) {
                console.error('Error storing folder handle:', error);
            }
        }
        
        async loadFolderHandle() {
            try {
                const db = await this.initializeIndexedDB();
                if (!db) return null;
                
                const transaction = db.transaction(['folderHandles'], 'readonly');
                const store = transaction.objectStore('folderHandles');
                
                return new Promise((resolve, reject) => {
                    const request = store.get('currentFolder');
                    request.onsuccess = () => {
                        const result = request.result;
                        if (result && result.handle) {
                            console.log('✅ Folder handle loaded from IndexedDB:', result.name);
                            resolve(result.handle);
                        } else {
                            resolve(null);
                        }
                    };
                    request.onerror = () => reject(request.error);
                });
                
            } catch (error) {
                console.error('Error loading folder handle:', error);
                return null;
            }
        }
        
        async startBackgroundRescan() {
            try {
                console.log('🔄 Starting background rescan...');
                
                // Try to load stored folder handle
                const storedHandle = await this.loadFolderHandle();
                if (!storedHandle) {
                    console.log('No stored folder handle found - user will need to rescan manually');
                    this.showRescanNotification();
                    return;
                }
                
                // Check if current playlist is from the same folder
                if (this.currentPlaylist.folderPath === 'Imported') {
                    console.log('Imported playlist detected - cannot auto-rescan, user must select folder');
                    this.showRescanNotification();
                    return;
                }
                
                this.folderHandle = storedHandle;
                this.isBackgroundScanning = true;
                
                // Show subtle loading indicator
                this.showBackgroundScanIndicator();
                
                // Verify folder access
                try {
                    await storedHandle.requestPermission({ mode: 'read' });
                } catch (permissionError) {
                    console.warn('Folder permission denied, user will need to rescan manually');
                    this.showRescanNotification();
                    this.hideBackgroundScanIndicator();
                    return;
                }
                
                // Scan folder in background
                const files = await this.scanDirectoryForAudioFiles(storedHandle);
                console.log(`Background scan found ${files.length} files`);
                
                // Process files progressively
                await this.processFilesProgressively(files);
                
                console.log('✅ Background rescan completed');
                this.hideBackgroundScanIndicator();
                
            } catch (error) {
                console.error('Background rescan failed:', error);
                this.showRescanNotification();
                this.hideBackgroundScanIndicator();
            } finally {
                this.isBackgroundScanning = false;
            }
        }
        
        async processFilesProgressively(files) {
            const batchSize = 3; // Smaller batches for background processing
            let processedCount = 0;
            
            for (let i = 0; i < files.length; i += batchSize) {
                const batch = files.slice(i, i + batchSize);
                
                // Process batch
                const batchTracks = await Promise.all(
                    batch.map(file => this.extractMetadata(file))
                );
                
                // Update existing tracks with new URLs
                batchTracks.forEach(newTrack => {
                    if (newTrack) {
                        const existingTrack = this.findTrackByFilename(newTrack.filename);
                        if (existingTrack) {
                            existingTrack.url = newTrack.url;
                            existingTrack.file = newTrack.file;
                            existingTrack._needsRescan = false;
                            console.log(`✅ Enabled playback for: ${existingTrack.title}`);
                        }
                    }
                });
                
                        // Update track display progressively (enable play buttons as tracks become ready)
                        this.updateTrackPlayabilityUI();
                        
                        // Update visualizer playlist progressively
                        this.visualizer.updatePlaylistFromManager(this.currentPlaylist);
                        
                        processedCount += batch.length;
                        this.updateBackgroundScanProgress(processedCount, files.length);
                        
                        // Yield to UI thread
                        await new Promise(resolve => setTimeout(resolve, 50));
            }
        }
        
        findTrackByFilename(filename) {
            if (!this.currentPlaylist) return null;
            return this.currentPlaylist.tracks.find(track => track.filename === filename);
        }
        
        updateTrackPlayabilityUI() {
            // Update track items to reflect their current playability status
            document.querySelectorAll('.track-item').forEach(item => {
                const trackId = item.dataset.trackId;
                const track = this.findTrackById(trackId);
                
                if (track) {
                    const playBtn = item.querySelector('.track-play-btn');
                    const isPlayable = track.url && !track._needsRescan;
                    
                    if (isPlayable) {
                        // Enable track
                        item.classList.remove('needs-rescan');
                        if (playBtn) {
                            playBtn.disabled = false;
                            playBtn.title = 'Play Track';
                        }
                    } else {
                        // Keep disabled
                        item.classList.add('needs-rescan');
                        if (playBtn) {
                            playBtn.disabled = true;
                            playBtn.title = 'Rescan folder to play';
                        }
                    }
                }
            });
        }
        
        showBackgroundScanIndicator() {
            // Add subtle indicator that background scanning is happening
            const stats = document.getElementById('playlistStats');
            if (stats) {
                const indicator = document.createElement('div');
                indicator.id = 'backgroundScanIndicator';
                indicator.className = 'background-scan-indicator';
                indicator.innerHTML = `
                    <span class="scan-icon">🔄</span>
                    <span class="scan-text">Enabling playback...</span>
                `;
                stats.appendChild(indicator);
            }
        }
        
        hideBackgroundScanIndicator() {
            const indicator = document.getElementById('backgroundScanIndicator');
            if (indicator) {
                indicator.remove();
            }
        }
        
        updateBackgroundScanProgress(current, total) {
            const indicator = document.getElementById('backgroundScanIndicator');
            if (indicator) {
                const scanText = indicator.querySelector('.scan-text');
                if (scanText) {
                    scanText.textContent = `Enabling playback... ${current}/${total}`;
                }
            }
        }
        
        initializeTabbedInterface() {
            // Phase 2: Initialize the hidden tabbed interface
            try {
                // Set app icon source
                const appIcon = document.getElementById('appIcon');
                if (appIcon && this.appIcon) {
                    appIcon.src = this.appIcon;
                    console.log('✓ App icon initialized');
                }
                
                // Initialize tab click handlers (inactive until Phase 5)
                document.querySelectorAll('.tab-item').forEach(tab => {
                    tab.addEventListener('click', (e) => {
                        e.stopPropagation();
                        if (document.body.classList.contains('tab-interface-active')) {
                            const section = e.target.dataset.section;
                            this.toggleSectionPanel(section);
                        }
                    });
                });
                
                // Add click-outside handler to close panels
                document.addEventListener('click', (e) => {
                    if (!document.body.classList.contains('tab-interface-active')) return;
                    
                    const tabHeader = document.getElementById('tabHeader');
                    const openPanel = document.querySelector('.section-panel.show');
                    
                    // If clicking outside tab header and open panel, close all panels
                    if (tabHeader && !tabHeader.contains(e.target) && 
                        (!openPanel || !openPanel.contains(e.target))) {
                        
                        document.querySelectorAll('.section-panel').forEach(p => p.classList.remove('show'));
                        document.querySelectorAll('.tab-item').forEach(t => t.classList.remove('active'));
                        console.log('All panels closed (click outside)');
                    }
                });
                
                console.log('✓ Tabbed interface initialized (hidden)');
                
            } catch (error) {
                console.error('Error initializing tabbed interface:', error);
            }
        }
        
        toggleSectionPanel(sectionName) {
            const panel = document.getElementById(`${sectionName}Panel`);
            const tab = document.getElementById(`${sectionName}Tab`);
            
            if (panel && tab) {
                const isOpen = panel.classList.contains('show');
                
                if (isOpen) {
                    // Close this panel
                    panel.classList.remove('show');
                    tab.classList.remove('active');
                    console.log(`${sectionName} panel closed`);
                } else {
                    // Close all other panels first (only 1 tab open at a time)
                    document.querySelectorAll('.section-panel').forEach(p => p.classList.remove('show'));
                    document.querySelectorAll('.tab-item').forEach(t => t.classList.remove('active'));
                    
                    // Position panel left-aligned to the tab
                    const tabRect = tab.getBoundingClientRect();
                    const headerRect = document.getElementById('tabHeader').getBoundingClientRect();
                    const leftOffset = tabRect.left - headerRect.left;
                    
                    panel.style.left = `${leftOffset}px`;
                    panel.style.transform = 'none';
                    
                    // Open this panel
                    panel.classList.add('show');
                    tab.classList.add('active');
                    console.log(`${sectionName} panel opened at tab position (others closed)`);
                }
            }
        }
        
        checkMetadataLibrary() {
            // Use our embedded lightweight metadata parser
            if (typeof window.lightweightMetadata !== 'undefined') {
                this.musicMetadata = window.lightweightMetadata;
                console.log('✓ Lightweight metadata parser ready (supports MP3 ID3 tags)');
                return;
            }
            
            // Fallback if even our embedded parser isn't ready
            console.warn('⚠ Metadata parser not ready - using filename-only fallback');
            this.musicMetadata = null;
        }
        
        loadCachedPlaylist() {
            try {
                const cached = localStorage.getItem('vizzy_current_playlist');
                if (cached) {
                    this.currentPlaylist = JSON.parse(cached);
                    console.log('Loaded cached playlist:', this.currentPlaylist.tracks?.length || 0, 'tracks');
                    
                    // Note: Cached playlists don't have file objects or blob URLs
                    // They will display metadata but won't be playable until folder is rescanned
                    if (this.currentPlaylist.tracks) {
                        this.currentPlaylist.tracks.forEach(track => {
                            if (!track.url) {
                                track._needsRescan = true; // Mark as needing rescan for playback
                            }
                        });
                    }
                }
            } catch (error) {
                console.error('Error loading cached playlist:', error);
                this.currentPlaylist = null;
            }
        }
        
        savePlaylist() {
            // Use the saveToCacheOnly method to avoid duplication
            this.saveToCacheOnly();
        }
        
        saveToCacheOnly() {
            // Save metadata to cache without affecting the in-memory playlist with URLs
            try {
                if (this.currentPlaylist) {
                    // Create a serializable copy (remove file objects and blob URLs for caching)
                    const serializablePlaylist = {
                        ...this.currentPlaylist,
                        tracks: this.currentPlaylist.tracks.map(track => ({
                            id: track.id,
                            title: track.title,
                            artist: track.artist,
                            album: track.album,
                            duration: track.duration,
                            artwork: track.artwork,
                            filename: track.filename,
                            size: track.size,
                            type: track.type,
                            lastModified: track.lastModified
                            // Exclude: file, url (not serializable/temporary)
                        }))
                    };
                    
                    // Save current playlist
                    localStorage.setItem('vizzy_current_playlist', JSON.stringify(serializablePlaylist));
                    
                    // Save to playlist cache with folder hash
                    const folderHash = this.generateFolderHash(this.currentPlaylist.folderPath);
                    const cacheKey = `vizzy_playlist_cache_${folderHash}`;
                    localStorage.setItem(cacheKey, JSON.stringify(serializablePlaylist));
                    
                    // Update cache index
                    this.updateCacheIndex(folderHash, this.currentPlaylist.folderPath);
                    
                    console.log('Playlist saved to cache (metadata only, URLs preserved in memory)');
                }
            } catch (error) {
                console.error('Error saving playlist to cache:', error);
            }
        }
        
        generateFolderHash(folderPath) {
            // Generate hash from folder path for caching
            if (!folderPath) return 'default';
            return btoa(folderPath).replace(/[^a-zA-Z0-9]/g, '').substring(0, 16);
        }
        
        updateCacheIndex(folderHash, folderPath) {
            try {
                let cacheIndex = {};
                const existing = localStorage.getItem('vizzy_playlist_cache_index');
                if (existing) {
                    cacheIndex = JSON.parse(existing);
                }
                
                cacheIndex[folderHash] = {
                    folderPath: folderPath,
                    lastAccessed: Date.now(),
                    trackCount: this.currentPlaylist.tracks?.length || 0
                };
                
                localStorage.setItem('vizzy_playlist_cache_index', JSON.stringify(cacheIndex));
            } catch (error) {
                console.error('Error updating cache index:', error);
            }
        }
        
        loadCachedPlaylistByFolder(folderPath) {
            try {
                const folderHash = this.generateFolderHash(folderPath);
                const cacheKey = `vizzy_playlist_cache_${folderHash}`;
                const cached = localStorage.getItem(cacheKey);
                
                if (cached) {
                    const playlist = JSON.parse(cached);
                    console.log(`Found cached playlist for folder: ${playlist.tracks?.length || 0} tracks`);
                    return playlist;
                }
            } catch (error) {
                console.error('Error loading cached playlist by folder:', error);
            }
            return null;
        }
        
        formatDuration(seconds) {
            if (!seconds || seconds === 0) return "0:00";
            
            const mins = Math.floor(seconds / 60);
            const secs = Math.floor(seconds % 60);
            return `${mins}:${secs.toString().padStart(2, '0')}`;
        }
        
        isAudioFile(file) {
            const extension = file.name.split('.').pop()?.toLowerCase();
            return this.supportedFormats.includes(extension);
        }
        
        async scanFolder() {
            try {
                console.log('Starting folder scan...');
                
                // Check if File System Access API is available
                if (!('showDirectoryPicker' in window)) {
                    alert('Folder selection not supported in this browser. Please use Chrome, Edge, or another Chromium-based browser.');
                    return;
                }
                
                // Show directory picker
                const directoryHandle = await window.showDirectoryPicker();
                console.log('Folder selected:', directoryHandle.name);
                
                // Store folder handle for future use
                this.folderHandle = directoryHandle;
                await this.storeFolderHandle(directoryHandle, directoryHandle.name);
                
                // Show warning about playlist replacement
                const confirmed = confirm(
                    "⚠️ Current playlist will be replaced!\n\n" +
                    "Your current playlist will be lost. Consider exporting it first for later use.\n\n" +
                    "Continue with folder scan?"
                );
                
                if (!confirmed) {
                    console.log('Folder scan cancelled by user');
                    return;
                }
                
                // Start scanning process
                this.isScanning = true;
                this.scanCancelled = false;
                this.showProgress();
                
                // Scan folder for audio files
                const files = await this.scanDirectoryForAudioFiles(directoryHandle);
                
                if (this.scanCancelled) {
                    console.log('Scan cancelled during file discovery');
                    this.hideProgress();
                    return;
                }
                
                console.log(`Found ${files.length} audio files`);
                
                // Check file limit
                if (files.length > this.maxFiles) {
                    const confirmed = confirm(
                        `Found ${files.length} audio files, but limit is ${this.maxFiles}.\n\n` +
                        `Only the first ${this.maxFiles} files will be processed. Continue?`
                    );
                    
                    if (!confirmed) {
                        this.hideProgress();
                        return;
                    }
                    
                    files.splice(this.maxFiles); // Keep only first maxFiles
                }
                
                // Process files with progress tracking
                const tracks = await this.processFilesWithProgress(files);
                
                if (this.scanCancelled) {
                    console.log('Scan cancelled during processing');
                    this.hideProgress();
                    return;
                }
                
                // Build playlist
                this.currentPlaylist = {
                    name: directoryHandle.name,
                    folderPath: directoryHandle.name,
                    lastScanned: Date.now(),
                    tracks: tracks.filter(track => track !== null) // Remove failed tracks
                };
                
                // Save to cache (metadata only, preserves in-memory version with URLs)
                this.saveToCacheOnly();
                
                console.log(`✅ Playlist created with ${this.currentPlaylist.tracks.length} tracks`);
                console.log('First few tracks:', this.currentPlaylist.tracks.slice(0, 3).map(t => `${t.title} by ${t.artist}`));
                
                // Test first track URL validity immediately
                if (this.currentPlaylist.tracks.length > 0) {
                    const firstTrack = this.currentPlaylist.tracks[0];
                    console.log('Testing first track URL validity:', firstTrack.url);
                    
                    // Test if blob URL is accessible
                    fetch(firstTrack.url)
                        .then(response => {
                            console.log('✅ Blob URL is valid and accessible');
                        })
                        .catch(error => {
                            console.error('❌ Blob URL is invalid:', error);
                        });
                }
                
                // Update visualizer playlist first
                this.visualizer.updatePlaylistFromManager(this.currentPlaylist);
                
                // Then update the display
                this.displayPlaylist();
                this.hideProgress();
                
            } catch (error) {
                if (error.name === 'AbortError') {
                    console.log('Folder selection cancelled by user');
                } else {
                    console.error('Error during folder scan:', error);
                    alert('Error scanning folder: ' + error.message);
                }
                this.hideProgress();
            } finally {
                this.isScanning = false;
            }
        }
        
        async scanDirectoryForAudioFiles(directoryHandle) {
            const files = [];
            
            try {
                for await (const entry of directoryHandle.values()) {
                    if (entry.kind === 'file') {
                        const file = await entry.getFile();
                        if (this.isAudioFile(file)) {
                            files.push(file);
                        }
                    }
                    
                    // Check for cancellation
                    if (this.scanCancelled) break;
                }
            } catch (error) {
                console.error('Error scanning directory:', error);
                throw new Error('Failed to scan directory. Please check folder permissions.');
            }
            
            return files;
        }
        
        async processFilesWithProgress(files) {
            const tracks = [];
            const totalFiles = files.length;
            const startTime = Date.now();
            
            this.updateProgress(0, totalFiles, 'Processing files...');
            
            // Process files in chunks to maintain UI responsiveness
            const chunkSize = 5;
            for (let i = 0; i < files.length; i += chunkSize) {
                if (this.scanCancelled) break;
                
                const chunk = files.slice(i, i + chunkSize);
                
                // Process chunk in parallel
                const chunkPromises = chunk.map(async (file, index) => {
                    try {
                        this.updateProgress(i + index, totalFiles, `Processing: ${file.name}`);
                        return await this.extractMetadata(file);
                    } catch (error) {
                        console.warn(`Skipping file ${file.name}:`, error);
                        return null;
                    }
                });
                
                const chunkResults = await Promise.all(chunkPromises);
                tracks.push(...chunkResults);
                
                // Update progress
                const processed = Math.min(i + chunkSize, totalFiles);
                const elapsed = Date.now() - startTime;
                const eta = totalFiles > processed ? (elapsed / processed) * (totalFiles - processed) : 0;
                
                this.updateProgress(processed, totalFiles, `Processed ${processed}/${totalFiles} files`, eta);
                
                // Yield to UI thread
                await new Promise(resolve => setTimeout(resolve, 10));
            }
            
            return tracks;
        }
        
        showProgress() {
            const progress = document.getElementById('playlistProgress');
            if (progress) {
                progress.style.display = 'block';
            }
        }
        
        hideProgress() {
            const progress = document.getElementById('playlistProgress');
            if (progress) {
                progress.style.display = 'none';
            }
        }
        
        updateProgress(current, total, text, etaMs = 0) {
            const progressBar = document.getElementById('progressBar');
            const progressText = document.getElementById('progressText');
            const progressCount = document.getElementById('progressCount');
            const progressEta = document.getElementById('progressEta');
            
            if (progressBar) {
                const percentage = total > 0 ? (current / total) * 100 : 0;
                progressBar.style.width = `${percentage}%`;
            }
            
            if (progressText) {
                progressText.textContent = text;
            }
            
            if (progressCount) {
                progressCount.textContent = `${current}/${total} files`;
            }
            
            if (progressEta && etaMs > 0) {
                const etaSeconds = Math.round(etaMs / 1000);
                const mins = Math.floor(etaSeconds / 60);
                const secs = etaSeconds % 60;
                progressEta.textContent = `Est: ${mins}:${secs.toString().padStart(2, '0')}`;
            } else if (progressEta) {
                progressEta.textContent = etaMs === 0 && current === total ? 'Complete!' : 'Est: calculating...';
            }
        }
        
        cancelScan() {
            this.scanCancelled = true;
            this.isScanning = false;
            console.log('Playlist scan cancelled by user');
            
            // Hide progress
            const progress = document.getElementById('playlistProgress');
            if (progress) {
                progress.style.display = 'none';
            }
        }
        
        async extractMetadata(file) {
            try {
                console.log(`Extracting metadata from: ${file.name}`);
                
                const track = {
                    id: this.generateTrackId(file),
                    filename: file.name,
                    size: file.size,
                    type: file.type,
                    lastModified: file.lastModified
                };
                
                // Try metadata extraction if parser available
                if (this.musicMetadata) {
                    try {
                        const metadata = await this.musicMetadata.parseFile(file);
                        
                        if (metadata && (metadata.title || metadata.artist || metadata.album)) {
                            track.title = metadata.title || this.extractTitleFromFilename(file.name);
                            track.artist = metadata.artist || "Unknown";
                            track.album = metadata.album || "Unknown";
                            track.duration = 0; // Will be calculated via Web Audio API
                            track.artwork = this.defaultArtwork; // Use default for now
                            
                            console.log(`✓ Metadata extracted: "${track.title}" by ${track.artist} (${track.album})`);
                        } else {
                            this.applyFallbackMetadata(track, file);
                        }
                        
                    } catch (metadataError) {
                        console.warn(`Metadata parsing failed for ${file.name}:`, metadataError);
                        this.applyFallbackMetadata(track, file);
                    }
                } else {
                    // Fallback metadata extraction
                    this.applyFallbackMetadata(track, file);
                }
                
                // Get duration using Web Audio API if not available from metadata
                if (!track.duration || track.duration === 0) {
                    track.duration = await this.getDurationFromAudio(file);
                }
                
                // Create object URL for playback
                track.url = URL.createObjectURL(file);
                track.file = file; // Keep reference to original file
                console.log(`Created blob URL for ${track.title}: ${track.url}`);
                
                return track;
                
            } catch (error) {
                console.error(`Failed to process ${file.name}:`, error);
                return null; // Skip this file
            }
        }
        
        generateTrackId(file) {
            // Generate unique ID based on filename and modification time
            return btoa(`${file.name}_${file.lastModified}_${file.size}`).replace(/[^a-zA-Z0-9]/g, '').substring(0, 16);
        }
        
        extractTitleFromFilename(filename) {
            // Remove extension and clean up filename for title
            return filename
                .replace(/\.(mp3|wav|flac|m4a|aac|ogg)$/i, '')
                .replace(/[-_]/g, ' ')
                .replace(/\s+/g, ' ')
                .trim() || 'Unknown';
        }
        
        applyFallbackMetadata(track, file) {
            track.title = this.extractTitleFromFilename(file.name);
            track.artist = "Unknown";
            track.album = "Unknown";
            track.duration = 0; // Will be calculated separately
            track.artwork = this.defaultArtwork;
            
            console.log(`Using fallback metadata for: ${track.title}`);
        }
        
        
        async resizeArtwork(blob) {
            return new Promise((resolve) => {
                const img = new Image();
                img.onload = () => {
                    const canvas = document.createElement('canvas');
                    canvas.width = 240;
                    canvas.height = 240;
                    const ctx = canvas.getContext('2d');
                    
                    // Draw image scaled to 240x240
                    ctx.drawImage(img, 0, 0, 240, 240);
                    
                    // Convert to JPG data URL
                    const dataUrl = canvas.toDataURL('image/jpeg', 0.8);
                    resolve(dataUrl);
                };
                img.onerror = () => resolve(null);
                img.src = URL.createObjectURL(blob);
            });
        }
        
        async getDurationFromAudio(file) {
            try {
                const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                const arrayBuffer = await file.arrayBuffer();
                const audioBuffer = await audioContext.decodeAudioData(arrayBuffer);
                audioContext.close();
                
                return audioBuffer.duration;
            } catch (error) {
                console.warn(`Duration extraction failed for ${file.name}:`, error);
                return 0;
            }
        }
        
        displayPlaylist() {
            console.log('=== displayPlaylist called ===');
            console.log('currentPlaylist exists:', !!this.currentPlaylist);
            console.log('tracks exist:', !!this.currentPlaylist?.tracks);
            console.log('tracks length:', this.currentPlaylist?.tracks?.length || 0);
            
            // Ensure dropdown content is populated first
            this.ensureDropdownContent();
            
            if (!this.currentPlaylist || !this.currentPlaylist.tracks) {
                console.log('Displaying empty playlist');
                this.displayEmptyPlaylist();
                return;
            }
            
            console.log('Updating playlist stats...');
            // Update stats
            this.updatePlaylistStats();
            
            console.log('Preparing tracks for display...');
            // Use current order if user has customized it, otherwise sort alphabetically
            let tracksToDisplay;
            if (this.currentPlaylist.hasCustomOrder) {
                console.log('Using custom track order');
                tracksToDisplay = this.currentPlaylist.tracks;
            } else {
                console.log('Using alphabetical sort');
                tracksToDisplay = this.sortTracksForDisplay(this.currentPlaylist.tracks);
            }
            console.log('Tracks to display:', tracksToDisplay.length);
            
            console.log('Rendering track list...');
            // Display tracks
            this.renderTrackList(tracksToDisplay);
            
            console.log('Updating track dropdown...');
            // Update dropdown for backward compatibility
            this.updateTrackDropdown();
            
            console.log('✅ displayPlaylist completed');
        }
        
        ensureDropdownContent() {
            const dropdown = document.getElementById('playlistDropdown');
            const tracksContainer = document.getElementById('playlistTracks');
            const hasNewContent = dropdown && dropdown.querySelector('.playlist-actions-dropdown');
            
            console.log('Checking dropdown content:');
            console.log('- Dropdown exists:', !!dropdown);
            console.log('- TracksContainer exists:', !!tracksContainer);
            console.log('- Has new content:', !!hasNewContent);
            
            // Check for the specific panel header to confirm it's our new content
            const hasPanelHeader = dropdown && dropdown.innerHTML.includes('playlistPanelClose');
            
            if (!hasPanelHeader && dropdown) {
                console.log('Dropdown missing panel header, populating with new content...');
                this.populatePlaylistDropdown();
                
                // Re-initialize UI handlers after populating
                this.visualizer.initializePlaylistUI();
            } else if (hasPanelHeader) {
                console.log('New dropdown content with panel header already exists');
            } else {
                console.error('Dropdown element not found!');
            }
        }
        
        displayEmptyPlaylist() {
            const tracksContainer = document.getElementById('playlistTracks');
            if (tracksContainer) {
                tracksContainer.innerHTML = `
                    <div class="empty-playlist">
                        <div class="empty-playlist-icon">🎵</div>
                        <div class="empty-playlist-text">No music loaded</div>
                        <div class="empty-playlist-subtext">Click "Add Folder" to scan your music library</div>
                    </div>
                `;
            }
            
            // Update stats
            const trackCount = document.getElementById('playlistTrackCount');
            const duration = document.getElementById('playlistDuration');
            if (trackCount) trackCount.textContent = 'No tracks loaded';
            if (duration) duration.textContent = '0:00:00';
        }
        
        updatePlaylistStats() {
            const tracks = this.currentPlaylist.tracks || [];
            const totalDuration = tracks.reduce((sum, track) => sum + (track.duration || 0), 0);
            
            const trackCount = document.getElementById('playlistTrackCount');
            const duration = document.getElementById('playlistDuration');
            
            if (trackCount) {
                trackCount.textContent = `${tracks.length} track${tracks.length !== 1 ? 's' : ''}`;
            }
            
            if (duration) {
                const hours = Math.floor(totalDuration / 3600);
                const mins = Math.floor((totalDuration % 3600) / 60);
                const secs = Math.floor(totalDuration % 60);
                
                if (hours > 0) {
                    duration.textContent = `${hours}:${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
                } else {
                    duration.textContent = `${mins}:${secs.toString().padStart(2, '0')}`;
                }
            }
        }
        
        sortTracksForDisplay(tracks) {
            // Sort tracks alphabetically by artist, then by title
            // This maintains a clean, predictable order for display
            return tracks.slice().sort((a, b) => {
                // First sort by artist
                const artistA = (a.artist || 'Unknown').toLowerCase();
                const artistB = (b.artist || 'Unknown').toLowerCase();
                
                if (artistA !== artistB) {
                    return artistA.localeCompare(artistB);
                }
                
                // Then sort by title within same artist
                const titleA = (a.title || '').toLowerCase();
                const titleB = (b.title || '').toLowerCase();
                return titleA.localeCompare(titleB);
            });
        }
        
        renderTrackList(tracks) {
            console.log('=== renderTrackList called ===');
            const tracksContainer = document.getElementById('playlistTracks');
            console.log('tracksContainer found:', !!tracksContainer);
            
            if (!tracksContainer) {
                console.error('playlistTracks container not found!');
                return;
            }
            
            let html = '';
            console.log('Rendering', tracks.length, 'tracks');
            
            tracks.forEach((track, index) => {
                const isPlayable = track.url && !track._needsRescan;
                const needsRescanClass = track._needsRescan ? 'needs-rescan' : '';
                
                html += `
                    <div class="track-item ${needsRescanClass}" data-track-id="${track.id}" data-track-index="${index}" draggable="true">
                        <img class="track-artwork" src="${track.artwork}" alt="Album artwork" />
                        <div class="track-info">
                            <div class="track-title">${this.escapeHtml(track.title)}</div>
                            <div class="track-details">
                                <span class="track-artist">${this.escapeHtml(track.artist)}</span>
                                <span class="track-album">${this.escapeHtml(track.album)}</span>
                                <span class="track-duration">${this.formatDuration(track.duration)}</span>
                            </div>
                        </div>
                        <div class="track-actions">
                            <button class="track-play-btn" title="${isPlayable ? 'Play Track' : 'Rescan folder to play'}" ${!isPlayable ? 'disabled' : ''}>▶</button>
                            <button class="track-remove-btn" title="Remove Track">×</button>
                        </div>
                    </div>
                `;
            });
            
            console.log('Generated HTML length:', html.length);
            console.log('Setting innerHTML...');
            tracksContainer.innerHTML = html;
            console.log('HTML set, container now has', tracksContainer.children.length, 'children');
            
            // Initialize track event handlers
            this.initializeTrackHandlers();
            console.log('Track handlers initialized');
        }
        
        escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }
        
        initializeTrackHandlers() {
            // Track play buttons
            document.querySelectorAll('.track-play-btn').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    const trackItem = btn.closest('.track-item');
                    const trackId = trackItem?.dataset.trackId;
                    if (trackId) {
                        this.playTrack(trackId);
                    }
                });
            });
            
            // Track remove buttons
            document.querySelectorAll('.track-remove-btn').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    const trackItem = btn.closest('.track-item');
                    const trackId = trackItem?.dataset.trackId;
                    if (trackId) {
                        this.removeTrack(trackId);
                    }
                });
            });
            
            // Track item clicks (for selection)
            document.querySelectorAll('.track-item').forEach(item => {
                item.addEventListener('click', (e) => {
                    e.stopPropagation();
                    const trackId = item.dataset.trackId;
                    if (trackId) {
                        this.selectTrack(trackId);
                    }
                });
            });
            
            // Drag and drop handlers
            this.initializeDragAndDrop();
        }
        
        initializeDragAndDrop() {
            let draggedTrackId = null;
            let draggedElement = null;
            
            document.querySelectorAll('.track-item').forEach(item => {
                // Drag start
                item.addEventListener('dragstart', (e) => {
                    draggedTrackId = item.dataset.trackId;
                    draggedElement = item;
                    e.dataTransfer.setData('text/plain', draggedTrackId);
                    e.dataTransfer.effectAllowed = 'move';
                    item.classList.add('dragging');
                    console.log('Drag started for track:', draggedTrackId);
                });
                
                // Drag end
                item.addEventListener('dragend', (e) => {
                    item.classList.remove('dragging');
                    document.querySelectorAll('.track-item').forEach(i => {
                        i.classList.remove('drag-over', 'drop-not-allowed');
                    });
                    document.querySelectorAll('.artist-tracks').forEach(a => {
                        a.classList.remove('drag-over');
                    });
                    draggedTrackId = null;
                    draggedElement = null;
                });
                
                // Drag over
                item.addEventListener('dragover', (e) => {
                    e.preventDefault();
                    
                    if (draggedElement && item !== draggedElement) {
                        // Check if this is the currently playing track
                        const targetTrackId = item.dataset.trackId;
                        const targetTrack = this.findTrackById(targetTrackId);
                        const isTargetPlaying = this.visualizer.audio && 
                                               this.visualizer.audio.src && 
                                               targetTrack && 
                                               this.visualizer.audio.src === targetTrack.url;
                        
                        if (isTargetPlaying) {
                            e.dataTransfer.dropEffect = 'none';
                            item.classList.add('drop-not-allowed');
                        } else {
                            e.dataTransfer.dropEffect = 'move';
                            item.classList.add('drag-over');
                        }
                    }
                });
                
                // Drag leave
                item.addEventListener('dragleave', (e) => {
                    item.classList.remove('drag-over', 'drop-not-allowed');
                });
                
                // Drop
                item.addEventListener('drop', (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    
                    const droppedTrackId = e.dataTransfer.getData('text/plain');
                    const targetTrackId = item.dataset.trackId;
                    
                    console.log(`Drop: ${droppedTrackId} onto ${targetTrackId}`);
                    
                    if (droppedTrackId && targetTrackId && droppedTrackId !== targetTrackId) {
                        // Check if target is currently playing
                        const targetTrack = this.findTrackById(targetTrackId);
                        const isTargetPlaying = this.visualizer.audio && 
                                               this.visualizer.audio.src && 
                                               targetTrack && 
                                               this.visualizer.audio.src === targetTrack.url;
                        
                        if (isTargetPlaying) {
                            console.log('Preventing drop on currently playing track to avoid playback errors');
                            return;
                        }
                        
                        this.reorderTracks(droppedTrackId, targetTrackId);
                    }
                    
                    // Clean up visual feedback
                    document.querySelectorAll('.track-item').forEach(i => {
                        i.classList.remove('drag-over', 'dragging', 'drop-not-allowed');
                    });
                });
            });
            
            // Track list container for general drops
            const tracksContainer = document.getElementById('playlistTracks');
            if (tracksContainer) {
                tracksContainer.addEventListener('dragover', (e) => {
                    e.preventDefault();
                    e.dataTransfer.dropEffect = 'move';
                    
                    // Find the closest track item to show insertion point
                    const afterElement = this.getDragAfterElement(tracksContainer, e.clientY);
                    const draggingElement = document.querySelector('.dragging');
                    
                    if (draggingElement) {
                        if (afterElement == null) {
                            tracksContainer.appendChild(draggingElement);
                        } else {
                            tracksContainer.insertBefore(draggingElement, afterElement);
                        }
                    }
                });
                
                tracksContainer.addEventListener('drop', (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    console.log('Drop on tracks container');
                });
            }
        }
        
        getDragAfterElement(container, y) {
            const draggableElements = [...container.querySelectorAll('.track-item:not(.dragging)')];
            
            return draggableElements.reduce((closest, child) => {
                const box = child.getBoundingClientRect();
                const offset = y - box.top - box.height / 2;
                
                if (offset < 0 && offset > closest.offset) {
                    return { offset: offset, element: child };
                } else {
                    return closest;
                }
            }, { offset: Number.NEGATIVE_INFINITY }).element;
        }
        
        reorderTracks(draggedTrackId, targetTrackId) {
            if (!this.currentPlaylist) {
                console.error('No current playlist for reordering');
                return;
            }
            
            const tracks = this.currentPlaylist.tracks;
            const draggedIndex = tracks.findIndex(t => t.id === draggedTrackId);
            const targetIndex = tracks.findIndex(t => t.id === targetTrackId);
            
            console.log(`Reordering: dragged index ${draggedIndex}, target index ${targetIndex}`);
            
            if (draggedIndex === -1 || targetIndex === -1) {
                console.error('Could not find tracks for reordering:', { draggedTrackId, targetTrackId });
                return;
            }
            
            if (draggedIndex === targetIndex) {
                console.log('Same position, no reordering needed');
                return;
            }
            
            // Store track references
            const draggedTrack = tracks[draggedIndex];
            
            console.log(`Moving "${draggedTrack.title}" from position ${draggedIndex} to ${targetIndex}`);
            
            // Remove dragged track and insert at target position
            const [removedTrack] = tracks.splice(draggedIndex, 1);
            
            // Adjust target index if we removed an item before it
            const newTargetIndex = draggedIndex < targetIndex ? targetIndex - 1 : targetIndex;
            tracks.splice(newTargetIndex, 0, removedTrack);
            
            // Mark playlist as having custom order
            this.currentPlaylist.hasCustomOrder = true;
            
            // Update current track index in visualizer if the playing track was moved
            if (this.visualizer.audio && this.visualizer.audio.src) {
                const currentPlayingUrl = this.visualizer.audio.src;
                console.log('Checking if playing track was moved...');
                console.log('Current audio URL:', currentPlayingUrl);
                
                // Find the track that's currently playing
                const newIndex = this.currentPlaylist.tracks.findIndex(track => track.url === currentPlayingUrl);
                console.log('New index for playing track:', newIndex);
                console.log('Old current track index:', this.visualizer.currentTrackIndex);
                
                if (newIndex >= 0 && newIndex !== this.visualizer.currentTrackIndex) {
                    console.log(`🔄 Updating current track index from ${this.visualizer.currentTrackIndex} to ${newIndex} after reorder`);
                    this.visualizer.currentTrackIndex = newIndex;
                    
                    // Also update the track info display to reflect the new position
                    this.visualizer.updateTrackInfo();
                } else if (newIndex === -1) {
                    console.error('Currently playing track not found in reordered playlist!');
                } else {
                    console.log('Playing track index unchanged');
                }
            }
            
            console.log(`✅ Track reordered successfully - custom order enabled`);
            
            // Save and update display
            this.savePlaylist();
            this.displayPlaylist();
            
            // Update visualizer playlist but preserve current playing state
            this.visualizer._preservePlayingState = true;
            this.visualizer.updatePlaylistFromManager(this.currentPlaylist);
            this.visualizer._preservePlayingState = false;
        }
        
        resetToAlphabetical() {
            if (!this.currentPlaylist) {
                console.warn('No playlist to sort');
                return;
            }
            
            console.log('Resetting playlist to alphabetical order');
            
            // Sort tracks alphabetically
            this.currentPlaylist.tracks = this.sortTracksForDisplay(this.currentPlaylist.tracks);
            
            // Mark as no longer having custom order
            this.currentPlaylist.hasCustomOrder = false;
            
            // Save and update display
            this.savePlaylist();
            this.displayPlaylist();
            this.visualizer.updatePlaylistFromManager(this.currentPlaylist);
            
            console.log('✅ Playlist reset to alphabetical order');
        }
        
        moveTrackToArtist(trackId, targetArtist) {
            if (!this.currentPlaylist) return;
            
            const track = this.findTrackById(trackId);
            if (!track) return;
            
            const oldArtist = track.artist;
            track.artist = targetArtist;
            
            console.log(`Moved track "${track.title}" from "${oldArtist}" to "${targetArtist}"`);
            
            // Save and update display
            this.savePlaylist();
            this.displayPlaylist();
            this.visualizer.updatePlaylistFromManager(this.currentPlaylist);
        }
        
        updateTrackDropdown() {
            // Update the track selection dropdown (the "Select Track" button)
            const playlistToggle = document.getElementById('playlistToggle');
            if (!playlistToggle || !this.currentPlaylist) return;
            
            // Update button text to show current track or track count
            const trackCount = this.currentPlaylist.tracks.length;
            if (trackCount > 0) {
                playlistToggle.textContent = `${trackCount} tracks loaded`;
            } else {
                playlistToggle.textContent = 'Select Track';
            }
            
            console.log('Track selection button updated');
        }
        
        playTrack(trackId) {
            const track = this.findTrackById(trackId);
            if (track && this.visualizer) {
                console.log(`Playing track: ${track.title} by ${track.artist}`);
                this.visualizer.playTrackById(trackId);
            }
        }
        
        selectTrack(trackId) {
            // Update visual selection
            document.querySelectorAll('.track-item').forEach(item => {
                item.classList.remove('active');
            });
            
            const trackItem = document.querySelector(`[data-track-id="${trackId}"]`);
            if (trackItem) {
                trackItem.classList.add('active');
            }
            
            console.log(`Selected track: ${trackId}`);
        }
        
        removeTrack(trackId) {
            if (!this.currentPlaylist) return;
            
            const confirmed = confirm('Remove this track from the playlist?');
            if (!confirmed) return;
            
            this.currentPlaylist.tracks = this.currentPlaylist.tracks.filter(track => track.id !== trackId);
            this.savePlaylist();
            this.displayPlaylist();
            
            console.log(`Removed track: ${trackId}`);
        }
        
        findTrackById(trackId) {
            if (!this.currentPlaylist) return null;
            return this.currentPlaylist.tracks.find(track => track.id === trackId);
        }
        
        async exportPlaylist() {
            try {
                if (!this.currentPlaylist || !this.currentPlaylist.tracks || this.currentPlaylist.tracks.length === 0) {
                    alert('No playlist to export. Please scan a music folder first.');
                    return;
                }
                
                // Create export data
                const exportData = {
                    name: this.currentPlaylist.name,
                    exportDate: new Date().toISOString(),
                    trackCount: this.currentPlaylist.tracks.length,
                    tracks: this.currentPlaylist.tracks.map(track => ({
                        id: track.id,
                        title: track.title,
                        artist: track.artist,
                        album: track.album,
                        duration: track.duration,
                        filename: track.filename,
                        // Note: Don't export artwork or URL (too large/temporary)
                    })),
                    version: "1.0"
                };
                
                // Check if File System Access API is available
                if ('showSaveFilePicker' in window) {
                    try {
                        // Open save dialog with suggested filename
                        const suggestedName = `${this.currentPlaylist.name}_playlist_${new Date().toISOString().slice(0, 10)}.json`;
                        
                        const fileHandle = await window.showSaveFilePicker({
                            suggestedName: suggestedName,
                            types: [{
                                description: 'Vizzy Playlist Files',
                                accept: {
                                    'application/json': ['.json']
                                }
                            }]
                        });
                        
                        // Write file to chosen location
                        const writable = await fileHandle.createWritable();
                        await writable.write(JSON.stringify(exportData, null, 2));
                        await writable.close();
                        
                        console.log(`✅ Playlist exported to: ${fileHandle.name}`);
                        console.log(`${exportData.trackCount} tracks saved successfully`);
                        
                    } catch (saveError) {
                        if (saveError.name === 'AbortError') {
                            console.log('Export cancelled by user');
                        } else {
                            console.error('Error saving file:', saveError);
                            // Fallback to download
                            this.fallbackExport(exportData);
                        }
                    }
                } else {
                    // Fallback for browsers without File System Access API
                    console.log('File System Access API not available, using download fallback');
                    this.fallbackExport(exportData);
                }
                
            } catch (error) {
                console.error('Error exporting playlist:', error);
                alert('Error exporting playlist: ' + error.message);
            }
        }
        
        fallbackExport(exportData) {
            // Traditional download fallback
            const blob = new Blob([JSON.stringify(exportData, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `${exportData.name}_playlist_${new Date().toISOString().slice(0, 10)}.json`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
            
            console.log(`✅ Playlist downloaded: ${exportData.trackCount} tracks`);
        }
        
        async importPlaylist(file) {
            try {
                if (!file) {
                    console.warn('No file provided for import');
                    return;
                }
                
                console.log(`Importing playlist from: ${file.name}`);
                
                // Show warning about current playlist
                const confirmed = confirm(
                    "⚠️ Current playlist will be replaced!\n\n" +
                    "Your current playlist will be lost. Consider exporting it first for later use.\n\n" +
                    "Continue with playlist import?"
                );
                
                if (!confirmed) {
                    console.log('Playlist import cancelled by user');
                    return;
                }
                
                // Read and parse file
                const text = await file.text();
                const importData = JSON.parse(text);
                
                // Validate import data
                if (!importData.tracks || !Array.isArray(importData.tracks)) {
                    throw new Error('Invalid playlist file format');
                }
                
                // Create imported playlist
                this.currentPlaylist = {
                    name: importData.name,
                    folderPath: 'Imported',
                    lastScanned: Date.now(),
                    tracks: importData.tracks.map(track => ({
                        ...track,
                        artwork: this.defaultArtwork,
                        url: null, // No URL until files are rescanned
                        _needsRescan: true
                    }))
                };
                
                // Save and display
                this.saveToCacheOnly();
                this.displayPlaylist();
                this.visualizer.updatePlaylistFromManager(this.currentPlaylist);
                
                console.log(`✅ Playlist imported: ${importData.tracks.length} tracks`);
                
                // Start background rescan to try to match files
                this.startBackgroundRescan();
                
            } catch (error) {
                console.error('Error importing playlist:', error);
                alert('Error importing playlist: ' + error.message);
            }
        }
    }

    // ****
    // ****

    // RecordManager Class - Handles video/audio recording
    class RecordManager {
        constructor(visualizer) {
            this.visualizer = visualizer;
            this.isRecording = false;
            this.mediaRecorder = null;
            this.recordedChunks = [];
            this.recordingStartTime = null;
            this.timerInterval = null;
            this.compositeCanvas = null;
            this.compositeCtx = null;
            this.animationFrame = null;
            this.saveLocation = null;
            
            // Recording settings
            this.resolution = '1080p';
            this.aspectRatio = '16:9';
            this.frameRate = 30;
            this.videoQuality = 'auto';
            this.audioQuality = 'auto';
            this.customFilename = 'Vizzy_Recording';
            this.matchVisualizationAspect = true;
            
            // Resolution presets
            this.resolutionPresets = {
                'canvas': { width: 0, height: 0 }, // Will be set dynamically
                '720p': { width: 1280, height: 720 },
                '1080p': { width: 1920, height: 1080 },
                '4k': { width: 3840, height: 2160 }
            };
            
            // Quality presets
            this.videoQualityPresets = {
                'auto': 5000000, // 5 Mbps
                'high': 8000000, // 8 Mbps
                'medium': 3000000, // 3 Mbps
                'low': 1500000 // 1.5 Mbps
            };
            
            this.audioQualityPresets = {
                'auto': 192000, // 192 kbps
                'high': 320000, // 320 kbps
                'medium': 192000, // 192 kbps
                'low': 128000 // 128 kbps
            };
            
            this.loadSettings();
            console.log('RecordManager initialized with aspect ratio:', this.aspectRatio);
            this.initializeUI();
        }
        
        loadSettings() {
            try {
                const saved = localStorage.getItem('gitup_record_settings');
                if (saved) {
                    const settings = JSON.parse(saved);
                    this.resolution = settings.resolution || '1080p';
                    this.aspectRatio = settings.aspectRatio || '16:9';
                    this.frameRate = settings.frameRate || 30;
                    this.videoQuality = settings.videoQuality || 'auto';
                    this.audioQuality = settings.audioQuality || 'auto';
                    this.customFilename = settings.customFilename || 'Vizzy_Recording';
                    this.saveLocation = settings.saveLocation || null;
                    this.matchVisualizationAspect = settings.matchVisualizationAspect !== undefined ? settings.matchVisualizationAspect : true;
                }
            } catch (e) {
                console.error('Error loading recording settings:', e);
            }
        }
        
        saveSettings() {
            try {
                const settings = {
                    resolution: this.resolution,
                    aspectRatio: this.aspectRatio,
                    frameRate: this.frameRate,
                    videoQuality: this.videoQuality,
                    audioQuality: this.audioQuality,
                    customFilename: this.customFilename,
                    saveLocation: this.saveLocation,
                    matchVisualizationAspect: this.matchVisualizationAspect
                };
                localStorage.setItem('gitup_record_settings', JSON.stringify(settings));
            } catch (e) {
                console.error('Error saving recording settings:', e);
            }
        }
        
        initializeUI() {
            // Record button click handler
            const recordBtn = document.getElementById('recordBtn');
            if (recordBtn) {
                recordBtn.addEventListener('click', () => {
                    if (this.isRecording) {
                        this.stopRecording();
                    } else {
                        this.startRecording();
                    }
                });
            }
            
            // Settings button click handler
            const settingsBtn = document.getElementById('recordSettingsBtn');
            const settingsPanel = document.getElementById('recordSettingsPanel');
            const closeBtn = document.getElementById('recordSettingsClose');
            
            if (settingsBtn && settingsPanel) {
                settingsBtn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    const isVisible = settingsPanel.style.display !== 'none';
                    settingsPanel.style.display = isVisible ? 'none' : 'block';
                });
            }
            
            if (closeBtn && settingsPanel) {
                closeBtn.addEventListener('click', () => {
                    settingsPanel.style.display = 'none';
                });
            }
            
            // Close panel when clicking outside
            document.addEventListener('click', (e) => {
                if (settingsPanel && !settingsPanel.contains(e.target) && 
                    !settingsBtn.contains(e.target)) {
                    settingsPanel.style.display = 'none';
                }
            });
            
            this.initializeSettingsControls();
            this.updateUI();
        }
        
        initializeSettingsControls() {
            // Resolution select
            const resolutionSelect = document.getElementById('recordResolutionSelect');
            if (resolutionSelect) {
                resolutionSelect.value = this.resolution;
                resolutionSelect.addEventListener('change', (e) => {
                    this.resolution = e.target.value;
                    this.updateUI();
                    this.saveSettings();
                });
            }
            
            // Aspect ratio buttons
            document.querySelectorAll('.aspect-ratio-btn').forEach(btn => {
                // Set initial active state based on current aspect ratio
                if (btn.dataset.ratio === this.aspectRatio) {
                    btn.classList.add('active');
                } else {
                    btn.classList.remove('active');
                }
                
                btn.addEventListener('click', (e) => {
                    document.querySelectorAll('.aspect-ratio-btn').forEach(b => b.classList.remove('active'));
                    btn.classList.add('active');
                    this.aspectRatio = btn.dataset.ratio;
                    console.log('Aspect ratio changed to:', this.aspectRatio);
                    this.updateUI();
                    this.saveSettings();
                });
            });
            
            // Frame rate buttons
            document.querySelectorAll('.framerate-btn').forEach(btn => {
                // Set initial active state based on current frame rate
                if (parseInt(btn.dataset.fps) === this.frameRate) {
                    btn.classList.add('active');
                } else {
                    btn.classList.remove('active');
                }
                
                btn.addEventListener('click', (e) => {
                    document.querySelectorAll('.framerate-btn').forEach(b => b.classList.remove('active'));
                    btn.classList.add('active');
                    this.frameRate = parseInt(btn.dataset.fps);
                    console.log('Frame rate changed to:', this.frameRate);
                    this.updateUI();
                    this.saveSettings();
                });
            });
            
            // Quality selects
            const videoQualitySelect = document.getElementById('recordVideoQualitySelect');
            const audioQualitySelect = document.getElementById('recordAudioQualitySelect');
            
            if (videoQualitySelect) {
                videoQualitySelect.value = this.videoQuality;
                videoQualitySelect.addEventListener('change', (e) => {
                    this.videoQuality = e.target.value;
                    this.updateUI();
                    this.saveSettings();
                });
            }
            
            if (audioQualitySelect) {
                audioQualitySelect.value = this.audioQuality;
                audioQualitySelect.addEventListener('change', (e) => {
                    this.audioQuality = e.target.value;
                    this.updateUI();
                    this.saveSettings();
                });
            }
            
            // Filename input
            const filenameInput = document.getElementById('recordFilenameInput');
            if (filenameInput) {
                filenameInput.value = this.customFilename;
                filenameInput.addEventListener('input', (e) => {
                    this.customFilename = e.target.value || 'Vizzy_Recording';
                    this.saveSettings();
                });
            }
            
            // Choose location button
            const chooseLocationBtn = document.getElementById('recordChooseLocationBtn');
            if (chooseLocationBtn) {
                chooseLocationBtn.addEventListener('click', () => {
                    this.chooseFileLocation();
                });
            }

            // Match Visualization Aspect Ratio toggle
            const matchVisualizationAspectBtn = document.getElementById('recordMatchVisualizationAspectBtn');
            if (matchVisualizationAspectBtn) {
                // Set initial state
                matchVisualizationAspectBtn.textContent = this.matchVisualizationAspect ? 'Match Video Aspect: On' : 'Match Video Aspect: Off';
                matchVisualizationAspectBtn.classList.toggle('active', this.matchVisualizationAspect);
                
                matchVisualizationAspectBtn.addEventListener('click', () => {
                    this.matchVisualizationAspect = !this.matchVisualizationAspect;
                    matchVisualizationAspectBtn.textContent = this.matchVisualizationAspect ? 'Match Video Aspect: On' : 'Match Video Aspect: Off';
                    matchVisualizationAspectBtn.classList.toggle('active', this.matchVisualizationAspect);
                    
                    // Apply aspect ratio matching if video is active
                    if (this.visualizer && (this.visualizer.videoMode === 'camera' || this.visualizer.videoMode === 'file') && this.visualizer.videoElement) {
                        this.visualizer.updateVisualizationAspectRatio();
                    }
                    
                    console.log('Match visualization aspect ratio:', this.matchVisualizationAspect);
                    this.saveSettings();
                });
            }
        }
        
        updateUI() {
            // Update recording info display
            const dimensions = this.getRecordingDimensions();
            const outputDisplay = document.getElementById('recordingOutput');
            const estSizeDisplay = document.getElementById('recordingEstSize');
            
            if (outputDisplay) {
                outputDisplay.textContent = `${dimensions.width}×${dimensions.height} @ ${this.frameRate}fps`;
            }
            
            if (estSizeDisplay) {
                const estimatedMBPerMin = this.estimateFileSize();
                estSizeDisplay.textContent = `~${estimatedMBPerMin} MB/min`;
            }
            
            // Update file location display
            const locationDisplay = document.getElementById('recordFileLocation');
            if (locationDisplay) {
                locationDisplay.textContent = this.saveLocation ? 
                    `📁 ${this.saveLocation}` : '📥 Downloads folder';
            }
        }
        
        getRecordingDimensions() {
            let targetWidth, targetHeight;
            
            if (this.resolution === 'canvas') {
                // Use current canvas dimensions
                const canvas = this.visualizer.audioMotion?.canvas;
                if (canvas) {
                    targetWidth = canvas.width;
                    targetHeight = canvas.height;
                } else {
                    targetWidth = 1920;
                    targetHeight = 1080;
                }
            } else {
                const preset = this.resolutionPresets[this.resolution];
                targetWidth = preset.width;
                targetHeight = preset.height;
            }
            
            console.log(`Recording dimensions before aspect ratio: ${targetWidth}x${targetHeight}`);
            console.log(`Current aspect ratio setting: ${this.aspectRatio}`);
            
            // Apply aspect ratio
            const [ratioW, ratioH] = this.aspectRatio.split(':').map(Number);
            const targetAspect = ratioW / ratioH;
            const currentAspect = targetWidth / targetHeight;
            
            console.log(`Target aspect: ${targetAspect} (${ratioW}:${ratioH}), Current aspect: ${currentAspect}`);
            
            if (currentAspect > targetAspect) {
                // Too wide, adjust width
                targetWidth = Math.round(targetHeight * targetAspect);
                console.log(`Adjusted width to fit aspect ratio: ${targetWidth}x${targetHeight}`);
            } else if (currentAspect < targetAspect) {
                // Too tall, adjust height
                targetHeight = Math.round(targetWidth / targetAspect);
                console.log(`Adjusted height to fit aspect ratio: ${targetWidth}x${targetHeight}`);
            } else {
                console.log(`Aspect ratio already matches: ${targetWidth}x${targetHeight}`);
            }
            
            return { width: targetWidth, height: targetHeight };
        }
        
        estimateFileSize() {
            const dimensions = this.getRecordingDimensions();
            const videoBitrate = this.videoQualityPresets[this.videoQuality] || 5000000;
            const audioBitrate = this.audioQualityPresets[this.audioQuality] || 192000;
            
            // Calculate total bitrate and convert to MB per minute
            const totalBitrate = videoBitrate + audioBitrate;
            const mbPerSecond = totalBitrate / 8 / 1024 / 1024; // Convert bits to MB
            const mbPerMinute = Math.round(mbPerSecond * 60);
            
            return mbPerMinute;
        }
        
        async chooseFileLocation() {
            try {
                if ('showDirectoryPicker' in window) {
                    const directoryHandle = await window.showDirectoryPicker();
                    this.saveLocation = directoryHandle.name;
                    this.directoryHandle = directoryHandle;
                    this.updateUI();
                    this.saveSettings();
                } else {
                    alert('File picker not supported in this browser. Files will be saved to Downloads folder.');
                }
            } catch (err) {
                if (err.name !== 'AbortError') {
                    console.error('Error choosing location:', err);
                }
            }
        }
        
        async startRecording() {
            if (this.isRecording) return;
            
            try {
                console.log('Starting recording...');
                this.isRecording = true;
                this.recordingStartTime = Date.now();
                this.recordedChunks = [];
                
                // Update UI
                const recordBtn = document.getElementById('recordBtn');
                const recordText = recordBtn.querySelector('.record-text');
                const recordTimer = recordBtn.querySelector('.record-timer');
                
                recordBtn.classList.add('recording');
                recordText.style.display = 'none';
                recordTimer.style.display = 'inline';
                
                // Start timer
                this.updateTimer();
                this.timerInterval = setInterval(() => this.updateTimer(), 100);
                
                // Create composite canvas
                await this.setupCompositeCanvas();
                
                // Get video stream
                const videoStream = this.compositeCanvas.captureStream(this.frameRate);
                
                // Get audio stream
                const audioStream = await this.getAudioStream();
                
                // Combine streams
                const combinedStream = new MediaStream();
                videoStream.getVideoTracks().forEach(track => combinedStream.addTrack(track));
                if (audioStream) {
                    audioStream.getAudioTracks().forEach(track => combinedStream.addTrack(track));
                }
                
                // Setup MediaRecorder
                const mimeType = 'video/webm;codecs=vp9,opus';
                const videoBitrate = this.videoQualityPresets[this.videoQuality];
                
                this.mediaRecorder = new MediaRecorder(combinedStream, {
                    mimeType: mimeType,
                    videoBitsPerSecond: videoBitrate
                });
                
                this.mediaRecorder.ondataavailable = (event) => {
                    if (event.data.size > 0) {
                        this.recordedChunks.push(event.data);
                    }
                };
                
                this.mediaRecorder.onstop = () => {
                    this.saveRecording();
                };
                
                this.mediaRecorder.start(1000); // Record in 1 second chunks
                
                // Start compositing loop
                this.startCompositing();
                
                console.log('Recording started successfully');
                
            } catch (err) {
                console.error('Error starting recording:', err);
                alert('Failed to start recording: ' + err.message);
                this.stopRecording();
            }
        }
        
        async setupCompositeCanvas() {
            const dimensions = this.getRecordingDimensions();
            
            this.compositeCanvas = document.createElement('canvas');
            this.compositeCanvas.width = dimensions.width;
            this.compositeCanvas.height = dimensions.height;
            this.compositeCtx = this.compositeCanvas.getContext('2d');
            
            console.log(`Created composite canvas: ${dimensions.width}x${dimensions.height}`);
        }
        
        startCompositing() {
            const composite = () => {
                if (!this.isRecording) return;
                
                this.compositeFrame();
                this.animationFrame = requestAnimationFrame(composite);
            };
            composite();
        }
        
        compositeFrame() {
            if (!this.compositeCtx) return;
            
            const { width, height } = this.compositeCanvas;
            
            // Clear canvas with black background
            this.compositeCtx.fillStyle = '#000000';
            this.compositeCtx.fillRect(0, 0, width, height);
            
            // Debug logging for kaleidoscope state
            if (this.visualizer.kaleidoscopeEnabled) {
                console.log('Kaleidoscope enabled - ApplyToVideo:', this.visualizer.kaleidoscopeApplyToVideo, 
                           'ApplyToViz:', this.visualizer.kaleidoscopeApplyToViz);
                if (this.visualizer.kaleidoscopeVideoCanvas) {
                    console.log('Kaleidoscope video canvas display:', this.visualizer.kaleidoscopeVideoCanvas.style.display,
                               'opacity:', this.visualizer.kaleidoscopeVideoCanvas.style.opacity);
                }
            }
            
            // Get source canvas (main visualization canvas)
            let sourceCanvas = null;
            
            // Determine which canvas to capture based on current state
            if (this.visualizer.kaleidoscopeEnabled) {
                if (this.visualizer.kaleidoscopeApplyToViz && this.visualizer.kaleidoscopeVizCanvas) {
                    sourceCanvas = this.visualizer.kaleidoscopeVizCanvas;
                } else if (this.visualizer.kaleidoscopeApplyToVideo && this.visualizer.kaleidoscopeVideoCanvas) {
                    sourceCanvas = this.visualizer.kaleidoscopeVideoCanvas;
                } else if (this.visualizer.audioMotion?.canvas) {
                    sourceCanvas = this.visualizer.audioMotion.canvas;
                }
            } else if (this.visualizer.audioMotion?.canvas) {
                sourceCanvas = this.visualizer.audioMotion.canvas;
            }
            
            if (!sourceCanvas) {
                console.warn('No source canvas found for recording');
                return;
            }
            
            // Calculate shared letterboxing dimensions for both video and visualization
            let sharedDrawWidth, sharedDrawHeight, sharedDrawX, sharedDrawY;
            
            if (this.visualizer.videoElement && 
                (this.visualizer.videoMode === 'camera' || this.visualizer.videoMode === 'file') &&
                this.visualizer.videoElement.readyState >= 2) {
                
                // Use video dimensions to calculate shared letterboxing
                const videoAspect = this.visualizer.videoElement.videoWidth / this.visualizer.videoElement.videoHeight;
                const canvasAspect = width / height;
                
                if (videoAspect > canvasAspect) {
                    // Video is wider, fit to width
                    sharedDrawWidth = width;
                    sharedDrawHeight = width / videoAspect;
                    sharedDrawX = 0;
                    sharedDrawY = (height - sharedDrawHeight) / 2;
                } else {
                    // Video is taller, fit to height
                    sharedDrawHeight = height;
                    sharedDrawWidth = height * videoAspect;
                    sharedDrawX = (width - sharedDrawWidth) / 2;
                    sharedDrawY = 0;
                }
                
                console.log(`Shared letterbox dimensions: ${sharedDrawWidth}x${sharedDrawHeight} at ${sharedDrawX},${sharedDrawY}`);
                
                // Draw video background with shared dimensions
                if (this.visualizer.kaleidoscopeEnabled && 
                    this.visualizer.kaleidoscopeApplyToVideo && 
                    this.visualizer.kaleidoscopeVideoCanvas &&
                    this.visualizer.kaleidoscopeVideoCanvas.style.display !== 'none') {
                    
                    // Draw kaleidoscope video canvas
                    const kaleidoscopeOpacity = parseFloat(this.visualizer.kaleidoscopeVideoCanvas.style.opacity) || 1;
                    if (kaleidoscopeOpacity > 0) {
                        this.compositeCtx.globalAlpha = kaleidoscopeOpacity;
                        this.compositeCtx.drawImage(this.visualizer.kaleidoscopeVideoCanvas, sharedDrawX, sharedDrawY, sharedDrawWidth, sharedDrawHeight);
                        this.compositeCtx.globalAlpha = 1;
                    }
                } else {
                    // Draw regular video with effects using shared dimensions
                    const opacity = parseFloat(this.visualizer.videoElement.style.opacity) || 1;
                    if (opacity > 0) {
                        this.compositeCtx.globalAlpha = opacity;
                        this.drawVideoWithEffects(sharedDrawX, sharedDrawY, sharedDrawWidth, sharedDrawHeight);
                        this.compositeCtx.globalAlpha = 1;
                    }
                }
                
                // Draw visualization using the same shared dimensions
                console.log(`Drawing visualization with shared dimensions: ${sharedDrawWidth}x${sharedDrawHeight} at ${sharedDrawX},${sharedDrawY}`);
                this.compositeCtx.drawImage(sourceCanvas, sharedDrawX, sharedDrawY, sharedDrawWidth, sharedDrawHeight);
                
                // Draw Infinite Zoom if active and not captured via kaleidoscope
                if (this.visualizer.infiniteZoom && this.visualizer.infiniteZoom.isActive && this.visualizer.infiniteZoom.canvas) {
                    const shouldDrawSeparately = !this.visualizer.kaleidoscopeEnabled || !this.visualizer.kaleidoscopeApplyToViz || !this.visualizer.kaleidoscopeApplyToInfiniteZoom;
                    if (shouldDrawSeparately) {
                        this.compositeCtx.drawImage(this.visualizer.infiniteZoom.canvas, sharedDrawX, sharedDrawY, sharedDrawWidth, sharedDrawHeight);
                    }
                }
                
            } else {
                // No video - draw visualization with standard letterboxing
                this.drawScaledVisualization(sourceCanvas);
                
                // Draw Infinite Zoom if active and not captured via kaleidoscope
                if (this.visualizer.infiniteZoom && this.visualizer.infiniteZoom.isActive && this.visualizer.infiniteZoom.canvas) {
                    const shouldDrawSeparately = !this.visualizer.kaleidoscopeEnabled || !this.visualizer.kaleidoscopeApplyToViz || !this.visualizer.kaleidoscopeApplyToInfiniteZoom;
                    if (shouldDrawSeparately) {
                        this.drawScaledVisualization(this.visualizer.infiniteZoom.canvas);
                    }
                }
            }
        }
        
        drawScaledVideo() {
            const video = this.visualizer.videoElement;
            const { width, height } = this.compositeCanvas;
            
            if (!video || video.readyState < 2) return;
            
            // Create temporary canvas for video effects processing
            if (!this.tempVideoCanvas) {
                this.tempVideoCanvas = document.createElement('canvas');
                this.tempVideoCtx = this.tempVideoCanvas.getContext('2d');
            }
            
            // Set temp canvas size to match composite canvas
            this.tempVideoCanvas.width = width;
            this.tempVideoCanvas.height = height;
            
            // Calculate scaling to fit with letterboxing
            const videoAspect = video.videoWidth / video.videoHeight;
            const canvasAspect = width / height;
            
            let drawWidth, drawHeight, drawX, drawY;
            
            if (videoAspect > canvasAspect) {
                // Video is wider, fit to width
                drawWidth = width;
                drawHeight = width / videoAspect;
                drawX = 0;
                drawY = (height - drawHeight) / 2;
            } else {
                // Video is taller, fit to height
                drawHeight = height;
                drawWidth = height * videoAspect;
                drawX = (width - drawWidth) / 2;
                drawY = 0;
            }
            
            // Apply video effects to temp canvas context
            this.tempVideoCtx.save();
            
            // Build filter string like the StreamManager does
            const filters = [];
            
            // Apply posterize FIRST with stronger effect
            if (this.visualizer.videoPosterize < 16) {
                const steps = this.visualizer.videoPosterize;
                const posterizeAmount = (16 - steps) / 16;
                filters.push(`contrast(${300 + posterizeAmount * 200}%)`);
                filters.push(`brightness(${95}%)`);
                filters.push(`saturate(${200}%)`);
                if (steps < 8) {
                    filters.push(`contrast(${150}%)`);
                }
            }
            
            // Apply other video adjustments
            if (this.visualizer.videoBrightness !== 100 && this.visualizer.videoPosterize >= 16) {
                filters.push(`brightness(${this.visualizer.videoBrightness}%)`);
            }
            if (this.visualizer.videoContrast !== 100 && this.visualizer.videoPosterize >= 16) {
                filters.push(`contrast(${this.visualizer.videoContrast}%)`);
            }
            if (this.visualizer.videoSaturation !== 100 && this.visualizer.videoPosterize >= 16) {
                filters.push(`saturate(${this.visualizer.videoSaturation}%)`);
            }
            if (this.visualizer.videoHueRotate !== 0) {
                filters.push(`hue-rotate(${this.visualizer.videoHueRotate}deg)`);
            }
            if (this.visualizer.videoGrayscale > 0) {
                filters.push(`grayscale(${this.visualizer.videoGrayscale}%)`);
            }
            if (this.visualizer.videoSepia > 0) {
                filters.push(`sepia(${this.visualizer.videoSepia}%)`);
            }
            if (this.visualizer.videoBlur > 0) {
                filters.push(`blur(${this.visualizer.videoBlur}px)`);
            }
            if (this.visualizer.videoInvert) {
                filters.push('invert(100%)');
            }
            
            // Apply filters to temp canvas
            this.tempVideoCtx.filter = filters.length > 0 ? filters.join(' ') : 'none';
            this.tempVideoCtx.globalAlpha = 1;
            
            // Clear temp canvas
            this.tempVideoCtx.clearRect(0, 0, width, height);
            
            // Draw video to temp canvas with effects
            this.tempVideoCtx.drawImage(video, drawX, drawY, drawWidth, drawHeight);
            
            this.tempVideoCtx.restore();
            
            // Calculate pulse scale if enabled
            let scale = 1;
            if (this.visualizer.videoPulse) {
                const pulseDuration = this.visualizer.videoPulseRate * 1000; // Convert to ms
                const pulsePhase = (Date.now() % pulseDuration) / pulseDuration;
                scale = 1 + (Math.sin(pulsePhase * Math.PI * 2) * 0.02); // 2% scale variation
            }
            
            // Apply mirror transformations if enabled
            this.compositeCtx.save();
            
            if (this.visualizer.videoMirror) {
                this.compositeCtx.scale(-1, 1);
                this.compositeCtx.translate(-width, 0);
            }
            
            // Apply pulse scaling
            if (scale !== 1) {
                this.compositeCtx.translate(width / 2, height / 2);
                this.compositeCtx.scale(scale, scale);
                this.compositeCtx.translate(-width / 2, -height / 2);
            }
            
            // Draw processed video from temp canvas to composite canvas
            this.compositeCtx.drawImage(this.tempVideoCanvas, 0, 0);
            
            this.compositeCtx.restore();
            
            // Apply vignette effect if enabled
            if (this.visualizer.videoVignette > 0) {
                this.compositeCtx.save();
                const intensity = this.visualizer.videoVignette / 100;
                const size = (100 - this.visualizer.videoVignette) / 100;
                
                const gradient = this.compositeCtx.createRadialGradient(
                    width / 2, height / 2, Math.min(width, height) * size * 0.5,
                    width / 2, height / 2, Math.max(width, height) * 0.7
                );
                gradient.addColorStop(0, 'rgba(0, 0, 0, 0)');
                gradient.addColorStop(1, `rgba(0, 0, 0, ${intensity})`);
                
                this.compositeCtx.fillStyle = gradient;
                this.compositeCtx.fillRect(0, 0, width, height);
                this.compositeCtx.restore();
            }
        }
        
        drawVideoWithEffects(drawX, drawY, drawWidth, drawHeight) {
            const video = this.visualizer.videoElement;
            const { width, height } = this.compositeCanvas;
            
            if (!video || video.readyState < 2) return;
            
            // Create temporary canvas for video effects processing
            if (!this.tempVideoCanvas) {
                this.tempVideoCanvas = document.createElement('canvas');
                this.tempVideoCtx = this.tempVideoCanvas.getContext('2d');
            }
            
            // Set temp canvas size to match composite canvas
            this.tempVideoCanvas.width = width;
            this.tempVideoCanvas.height = height;
            
            // Apply video effects to temp canvas context
            this.tempVideoCtx.save();
            
            // Build filter string like the StreamManager does
            const filters = [];
            
            // Apply posterize FIRST with stronger effect
            if (this.visualizer.videoPosterize < 16) {
                const steps = this.visualizer.videoPosterize;
                const posterizeAmount = (16 - steps) / 16;
                filters.push(`contrast(${300 + posterizeAmount * 200}%)`);
                filters.push(`brightness(${95}%)`);
                filters.push(`saturate(${200}%)`);
                if (steps < 8) {
                    filters.push(`contrast(${150}%)`);
                }
            }
            
            // Apply other video adjustments
            if (this.visualizer.videoBrightness !== 100 && this.visualizer.videoPosterize >= 16) {
                filters.push(`brightness(${this.visualizer.videoBrightness}%)`);
            }
            if (this.visualizer.videoContrast !== 100 && this.visualizer.videoPosterize >= 16) {
                filters.push(`contrast(${this.visualizer.videoContrast}%)`);
            }
            if (this.visualizer.videoSaturation !== 100 && this.visualizer.videoPosterize >= 16) {
                filters.push(`saturate(${this.visualizer.videoSaturation}%)`);
            }
            if (this.visualizer.videoHueRotate !== 0) {
                filters.push(`hue-rotate(${this.visualizer.videoHueRotate}deg)`);
            }
            if (this.visualizer.videoGrayscale > 0) {
                filters.push(`grayscale(${this.visualizer.videoGrayscale}%)`);
            }
            if (this.visualizer.videoSepia > 0) {
                filters.push(`sepia(${this.visualizer.videoSepia}%)`);
            }
            if (this.visualizer.videoBlur > 0) {
                filters.push(`blur(${this.visualizer.videoBlur}px)`);
            }
            if (this.visualizer.videoInvert) {
                filters.push('invert(100%)');
            }
            
            // Apply filters to temp canvas
            this.tempVideoCtx.filter = filters.length > 0 ? filters.join(' ') : 'none';
            this.tempVideoCtx.globalAlpha = 1;
            
            // Clear temp canvas
            this.tempVideoCtx.clearRect(0, 0, width, height);
            
            // Draw video to temp canvas with effects at specified dimensions
            this.tempVideoCtx.drawImage(video, drawX, drawY, drawWidth, drawHeight);
            
            this.tempVideoCtx.restore();
            
            // Calculate pulse scale if enabled
            let scale = 1;
            if (this.visualizer.videoPulse) {
                const pulseDuration = this.visualizer.videoPulseRate * 1000;
                const pulsePhase = (Date.now() % pulseDuration) / pulseDuration;
                scale = 1 + (Math.sin(pulsePhase * Math.PI * 2) * 0.02);
            }
            
            // Apply mirror transformations if enabled
            this.compositeCtx.save();
            
            if (this.visualizer.videoMirror) {
                this.compositeCtx.scale(-1, 1);
                this.compositeCtx.translate(-width, 0);
            }
            
            // Apply pulse scaling
            if (scale !== 1) {
                this.compositeCtx.translate(width / 2, height / 2);
                this.compositeCtx.scale(scale, scale);
                this.compositeCtx.translate(-width / 2, -height / 2);
            }
            
            // Draw processed video from temp canvas to composite canvas
            this.compositeCtx.drawImage(this.tempVideoCanvas, 0, 0);
            
            this.compositeCtx.restore();
            
            // Apply vignette effect if enabled
            if (this.visualizer.videoVignette > 0) {
                this.compositeCtx.save();
                const intensity = this.visualizer.videoVignette / 100;
                const size = (100 - this.visualizer.videoVignette) / 100;
                
                const gradient = this.compositeCtx.createRadialGradient(
                    width / 2, height / 2, Math.min(width, height) * size * 0.5,
                    width / 2, height / 2, Math.max(width, height) * 0.7
                );
                gradient.addColorStop(0, 'rgba(0, 0, 0, 0)');
                gradient.addColorStop(1, `rgba(0, 0, 0, ${intensity})`);
                
                this.compositeCtx.fillStyle = gradient;
                this.compositeCtx.fillRect(0, 0, width, height);
                this.compositeCtx.restore();
            }
        }
        
        drawScaledCanvas(canvas) {
            const { width, height } = this.compositeCanvas;
            
            if (!canvas || canvas.width === 0 || canvas.height === 0) return;
            
            // For kaleidoscope canvases, use full dimensions (they're already sized to match the container)
            if (canvas === this.visualizer.kaleidoscopeVideoCanvas || canvas === this.visualizer.kaleidoscopeVizCanvas) {
                console.log('Drawing kaleidoscope canvas at full size');
                this.compositeCtx.drawImage(canvas, 0, 0, width, height);
                return;
            }
            
            // For other canvases, calculate scaling to fit with letterboxing
            const canvasAspect = canvas.width / canvas.height;
            const targetAspect = width / height;
            
            let drawWidth, drawHeight, drawX, drawY;
            
            if (canvasAspect > targetAspect) {
                // Canvas is wider, fit to width
                drawWidth = width;
                drawHeight = width / canvasAspect;
                drawX = 0;
                drawY = (height - drawHeight) / 2;
            } else {
                // Canvas is taller, fit to height
                drawHeight = height;
                drawWidth = height * canvasAspect;
                drawX = (width - drawWidth) / 2;
                drawY = 0;
            }
            
            this.compositeCtx.drawImage(canvas, drawX, drawY, drawWidth, drawHeight);
        }
        
        drawScaledVisualization(sourceCanvas) {
            const { width, height } = this.compositeCanvas;
            
            // Use standard letterboxing for visualization
            const sourceAspect = sourceCanvas.width / sourceCanvas.height;
            const canvasAspect = width / height;
            
            let drawWidth, drawHeight, drawX, drawY;
            
            if (sourceAspect > canvasAspect) {
                // Source is wider, fit to width
                drawWidth = width;
                drawHeight = width / sourceAspect;
                drawX = 0;
                drawY = (height - drawHeight) / 2;
            } else {
                // Source is taller, fit to height
                drawHeight = height;
                drawWidth = height * sourceAspect;
                drawX = (width - drawWidth) / 2;
                drawY = 0;
            }
            
            console.log(`Drawing visualization: ${drawWidth}x${drawHeight} at ${drawX},${drawY}`);
            this.compositeCtx.drawImage(sourceCanvas, drawX, drawY, drawWidth, drawHeight);
        }
        
        async getAudioStream() {
            try {
                // Check if using live audio input
                if (this.visualizer.audioStream) {
                    console.log('Using live audio input for recording');
                    return this.visualizer.audioStream.clone();
                }
                
                // Get audio from AudioMotion's audio context
                const audioMotion = this.visualizer.audioMotion;
                if (!audioMotion || !audioMotion.audioCtx) {
                    console.warn('No AudioMotion context available');
                    return null;
                }
                
                const audioCtx = audioMotion.audioCtx;
                const destination = audioCtx.createMediaStreamDestination();
                
                // Create a gain node to tap the audio
                const gainNode = audioCtx.createGain();
                gainNode.gain.value = 1.0;
                
                // Connect all available audio sources to capture everything
                let hasAudioSource = false;
                
                // Connect playlist/live audio if available
                if (audioMotion.source) {
                    try {
                        audioMotion.source.connect(gainNode);
                        hasAudioSource = true;
                        console.log('Connected AudioMotion source to recording');
                    } catch (e) {
                        console.error('Error connecting AudioMotion source:', e);
                    }
                }
                
                // Also connect video audio if available (can be simultaneous with playlist)
                if (this.visualizer.videoAudioGain) {
                    try {
                        this.visualizer.videoAudioGain.connect(gainNode);
                        hasAudioSource = true;
                        console.log('Connected video audio to recording');
                    } catch (e) {
                        console.error('Error connecting video audio:', e);
                    }
                }
                
                if (hasAudioSource) {
                    gainNode.connect(destination);
                    console.log('Audio stream created successfully with all available sources');
                    return destination.stream;
                }
                
                // Fallback: try to capture from the current audio element
                if (this.visualizer.audio && this.visualizer.audio.src) {
                    console.log('Capturing audio from media element');
                    const source = this.visualizer.audio._audioSourceNode;
                    if (source) {
                        source.connect(gainNode);
                        gainNode.connect(destination);
                        return destination.stream;
                    }
                }
                
                console.warn('No audio source found for recording');
                return null;
                
            } catch (err) {
                console.error('Error getting audio stream:', err);
                return null;
            }
        }
        
        updateTimer() {
            if (!this.isRecording || !this.recordingStartTime) return;
            
            const elapsed = Date.now() - this.recordingStartTime;
            const seconds = Math.floor(elapsed / 1000);
            const minutes = Math.floor(seconds / 60);
            const hours = Math.floor(minutes / 60);
            
            let timeString;
            if (hours > 0) {
                timeString = `${hours}:${(minutes % 60).toString().padStart(2, '0')}:${(seconds % 60).toString().padStart(2, '0')}`;
            } else {
                timeString = `${minutes.toString().padStart(2, '0')}:${(seconds % 60).toString().padStart(2, '0')}`;
            }
            
            const recordTimer = document.querySelector('.record-timer');
            if (recordTimer) {
                recordTimer.textContent = timeString;
            }
        }
        
        stopRecording() {
            if (!this.isRecording) return;
            
            console.log('Stopping recording...');
            this.isRecording = false;
            
            // Stop timer
            if (this.timerInterval) {
                clearInterval(this.timerInterval);
                this.timerInterval = null;
            }
            
            // Stop animation frame
            if (this.animationFrame) {
                cancelAnimationFrame(this.animationFrame);
                this.animationFrame = null;
            }
            
            // Stop media recorder
            if (this.mediaRecorder && this.mediaRecorder.state !== 'inactive') {
                this.mediaRecorder.stop();
            }
            
            // Clean up temporary canvases
            this.tempVideoCanvas = null;
            this.tempVideoCtx = null;
            this.compositeCanvas = null;
            this.compositeCtx = null;
            
            // Update UI
            const recordBtn = document.getElementById('recordBtn');
            const recordText = recordBtn.querySelector('.record-text');
            const recordTimer = recordBtn.querySelector('.record-timer');
            
            recordBtn.classList.remove('recording');
            recordText.style.display = 'inline';
            recordTimer.style.display = 'none';
            recordTimer.textContent = '00:00';
            
            console.log('Recording stopped');
        }
        
        async saveRecording() {
            if (this.recordedChunks.length === 0) {
                console.warn('No recorded data to save');
                return;
            }
            
            try {
                const blob = new Blob(this.recordedChunks, { type: 'video/webm' });
                const timestamp = new Date().toISOString().replace(/[:.]/g, '-').slice(0, -5);
                const filename = `${this.customFilename}_${timestamp}.webm`;
                
                if (this.directoryHandle && 'showDirectoryPicker' in window) {
                    // Save to chosen directory
                    try {
                        const fileHandle = await this.directoryHandle.getFileHandle(filename, { create: true });
                        const writable = await fileHandle.createWritable();
                        await writable.write(blob);
                        await writable.close();
                        
                        console.log(`Recording saved to ${this.saveLocation}/${filename}`);
                        alert(`Recording saved successfully to ${this.saveLocation}/${filename}`);
                    } catch (err) {
                        console.error('Error saving to chosen directory:', err);
                        this.fallbackDownload(blob, filename);
                    }
                } else {
                    // Fallback to downloads folder
                    this.fallbackDownload(blob, filename);
                }
                
            } catch (err) {
                console.error('Error saving recording:', err);
                alert('Error saving recording: ' + err.message);
            }
            
            // Clear recorded chunks
            this.recordedChunks = [];
        }
        
        fallbackDownload(blob, filename) {
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = filename;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
            
            console.log(`Recording downloaded as ${filename}`);
            alert(`Recording saved to Downloads folder as ${filename}`);
        }
    }

    // ****
    // ****

    // Fixed better canvas capture
    class StreamManager {
        constructor(visualizer) {
            this.visualizer = visualizer;
            this.pc = null;
            this.stream = null;
            this.channel = new BroadcastChannel('gitup-live-display');
            this.displayWindow = null;
            this.isStreaming = false;
            this.captureCanvas = null;
            this.captureCtx = null;
            this.animationFrame = null;
            this.pendingIceCandidates = []; // Queue for ICE candidates received before remote description
            this.hasOffered = false; // Track if we've already sent an offer

            // Display settings
            this.displaySettings = this.loadDisplaySettings();

            this.init();
        }

        init() { // Listen for messages from display window
            this.channel.onmessage = async (event) => {
                const {type, data} = event.data;

                switch (type) {
                    case 'display-ready':
                        console.log('Display window ready');
                        // Only start streaming if we're supposed to be streaming and don't have a connection
                        if (this.isStreaming && (!this.pc || this.pc.connectionState === 'closed' || this.pc.connectionState === 'failed')) {
                            console.log('Starting streaming after display ready');
                            try {
                                await this.startStreaming();
                            } catch (error) {
                                console.error('Failed to start streaming:', error);
                                this.handleStreamingError(error);
                            }
                        } else if (this.pc) {
                            console.log('Peer connection already exists, state:', this.pc.connectionState);
                        }
                        break;
                    case 'answer':
                        await this.handleAnswer(data);
                        break;
                    case 'ice-candidate-answer':
                        await this.handleIceCandidate(data);
                        break;
                    case 'pong':
                        console.log('Display window alive');
                        break;
                }
            };
        }

        loadDisplaySettings() {
            const saved = localStorage.getItem('gitup_display_settings');
            return saved ? JSON.parse(saved) : {
                presentationMode: 'fit', // Changed to 'fit' for proper sizing
                aspectRatio: 'auto',
                captureResolution: 2560,  // Changed to 2K default
                captureFrameRate: 60,
                captureBitrate: 30,  // Changed to 30 Mbps default
                displaySharpness: 0,
                letterboxColor: '#000000',
                mirrorBackground: false,
                mirrorBackgroundBlur: 20
            };
        }

        saveDisplaySettings() {
            localStorage.setItem('gitup_display_settings', JSON.stringify(this.displaySettings));
        }

        updateDisplaySettings(settings) {
            Object.assign(this.displaySettings, settings);
            this.saveDisplaySettings();

            // Send settings to display window
            this.channel.postMessage({type: 'display-settings', data: this.displaySettings});

            // If streaming, reconfigure capture
            if (this.isStreaming) {
                this.reconfigureCapture();
            }
        }

        reconfigureCapture() { // Update capture canvas size based on resolution
            const width = this.displaySettings.captureResolution;
            const height = Math.round(width * 9 / 16); // Always use 16:9 for display window compatibility

            if (this.captureCanvas) {
                this.captureCanvas.width = width;
                this.captureCanvas.height = height;
            }

            // Update WebRTC parameters if connection exists
            if (this.pc) {
                const senders = this.pc.getSenders();
                const videoSender = senders.find(s => s.track && s.track.kind === 'video');

                if (videoSender) {
                    const params = videoSender.getParameters();
                    if (! params.encodings) {
                        params.encodings = [{}];
                    }

                    params.encodings[0].maxBitrate = this.displaySettings.captureBitrate * 1000000;
                    params.encodings[0].maxFramerate = this.displaySettings.captureFrameRate;

                    videoSender.setParameters(params).then(() => console.log('Updated WebRTC parameters')).catch(e => console.error('Failed to update parameters:', e));
                }
            }
        }

        calculateHeightForAspectRatio(width, ratio) {
            const ratioMap = {
                '16:9': 9 / 16,
                '4:3': 3 / 4,
                '1:1': 1,
                '9:16': 16 / 9,
                '21:9': 9 / 21,
                'auto': 9 / 16 // Default to 16:9 for auto
            };
            return Math.round(width * (ratioMap[ratio] || 9 / 16));
        }

        sendVideoFilters() {
            if (!this.isStreaming) 
                return;
            


            // Collect all video filter values including opacity
            const filters = {
                brightness: this.visualizer.videoBrightness || 100,
                contrast: this.visualizer.videoContrast || 100,
                saturation: this.visualizer.videoSaturation || 100,
                hueRotate: this.visualizer.videoHueRotate || 0,
                grayscale: this.visualizer.videoGrayscale || 0,
                sepia: this.visualizer.videoSepia || 0,
                blur: this.visualizer.videoBlur || 0,
                invert: this.visualizer.videoInvert || false,
                opacity: this.visualizer.videoOpacity || 1, // Send actual opacity value
                mirror: this.visualizer.videoMirror || 'off',
                vignette: this.visualizer.videoVignette || 0,
                posterize: this.visualizer.videoPosterize || 16
            };

            // Send via BroadcastChannel
            this.channel.postMessage({type: 'video-filters', data: filters});
        }

        async toggleLiveDisplay() {
            if (this.isStreaming) {
                this.stopStreaming();
            } else {
                if (this.openDisplayWindow()) {
                    // Start streaming immediately when window opens
                    // The display window will send 'display-ready' and we'll handle it
                    this.isStreaming = true;
                    // Set this BEFORE opening so we're ready

                    // Update button state immediately
                    const btn = document.getElementById('liveDisplayBtn');
                    if (btn) {
                        btn.classList.add('active');
                        btn.textContent = 'Stop Display';
                    }
                }
            }
        }

        openDisplayWindow() { // Open display window
            // First, set performance mode for optimal quality
            const performancePreset = {
                presentationMode: 'fit',  // Use 'fit' for proper video sizing
                aspectRatio: '16:9',      // Default to 16:9 aspect ratio
                captureResolution: 2560,  // 2K resolution default
                captureFrameRate: 60,
                captureBitrate: 30,
                displaySharpness: 0,
                letterboxColor: '#000000',
                mirrorBackground: false,
                mirrorBackgroundBlur: 20
            };
            
            // Apply performance settings
            this.updateDisplaySettings(performancePreset);
            
            const width = 1280;
            const height = 720;
            const left = window.screen.width - width - 50;
            const top = 50;

            this.displayWindow = window.open('display.html', 'GitItUp Live Display', `width=${width},height=${height},left=${left},top=${top},menubar=no,toolbar=no,location=no,status=no`);

            if (!this.displayWindow) {
                alert('Please allow pop-ups to open the display window');
                return false;
            }

            // Add window focus to ensure it's visible
            this.displayWindow.focus();

            // Monitor window close
            const checkWindow = setInterval(() => {
                if (this.displayWindow && this.displayWindow.closed) {
                    clearInterval(checkWindow);
                    console.log('Display window was closed manually');
                    this.stopStreaming();
                }
            }, 1000);

            // Add timeout for initial connection
            setTimeout(() => {
                if (!this.pc && this.isStreaming) {
                    console.warn('Connection not established within timeout period');
                    // Send a ping to check if display window is responsive
                    this.channel.postMessage({type: 'ping'});
                }
            }, 5000);

            return true;
        }

        async startStreaming() { // Clean up any existing connection and canvases first
            if (this.pc) {
                this.pc.close();
                this.pc = null;
            }

            // Clean up any existing stream
            if (this.stream) {
                this.stream.getTracks().forEach(track => track.stop());
                this.stream = null;
            }

            // Clear any pending ICE candidates from previous attempts
            this.pendingIceCandidates = [];
            
            // Reset offer tracking
            this.hasOffered = false;

            // Force cleanup of existing canvases
            if (this.captureCanvas) {
                if (this.captureCanvas.parentNode) {
                    this.captureCanvas.parentNode.removeChild(this.captureCanvas);
                }
                this.captureCanvas = null;
                this.captureCtx = null;
            }

            // Also cleanup temp video canvas
            this.tempVideoCanvas = null;
            this.tempVideoCtx = null;

            this.isStreaming = true;

            console.log('Starting fresh streaming session');

            // Send initial video filter state
            this.sendVideoFilters();

            // Send initial display settings
            this.channel.postMessage({type: 'display-settings', data: this.displaySettings});

            try { // Create capture canvas - this will now always create fresh
                this.setupCaptureCanvas();

                // Start capturing
                this.startCapture();

                // Get stream from capture canvas (try without frame rate parameter)
                this.stream = this.captureCanvas.captureStream();

                console.log('Stream created with tracks:', this.stream.getTracks().length);

                // Create peer connection with better config
                this.pc = new RTCPeerConnection({
                    iceServers: [
                        {
                            urls: 'stun:stun.l.google.com:19302'
                        }
                    ],
                    bundlePolicy: 'max-bundle',
                    rtcpMuxPolicy: 'require'
                });

                // Add tracks to peer connection with encoding parameters
                this.stream.getTracks().forEach(track => {
                    console.log('Adding track:', track.kind);
                    const sender = this.pc.addTrack(track, this.stream);

                    // Set high quality parameters for video track
                    if (track.kind === 'video') {
                        const params = sender.getParameters();
                        if (! params.encodings) {
                            params.encodings = [{}];
                        }

                        // Use configured bitrate and frame rate
                        params.encodings[0].maxBitrate = this.displaySettings.captureBitrate * 1000000;
                        params.encodings[0].scaleResolutionDownBy = 1.0; // No downscaling
                        params.encodings[0].maxFramerate = this.displaySettings.captureFrameRate;

                        sender.setParameters(params).then(() => console.log('Video parameters set for configured quality')).catch(e => console.error('Failed to set video parameters:', e));
                    }
                });

                // Handle ICE candidates
                this.pc.onicecandidate = (event) => {
                    if (event.candidate) { // Serialize the ICE candidate to a plain object
                        this.channel.postMessage({
                            type: 'ice-candidate',
                            data: {
                                candidate: event.candidate.candidate,
                                sdpMLineIndex: event.candidate.sdpMLineIndex,
                                sdpMid: event.candidate.sdpMid,
                                usernameFragment: event.candidate.usernameFragment
                            }
                        });
                    }
                };

                // Monitor connection state
                this.pc.onconnectionstatechange = () => {
                    console.log('PC Connection state:', this.pc.connectionState);
                    console.log('PC Signaling state:', this.pc.signalingState);
                    
                    if (this.pc.connectionState === 'connected') {
                        console.log('✅ WebRTC connection established successfully!');
                    } else if (this.pc.connectionState === 'failed') {
                        console.log('❌ Connection failed, may need to restart');
                        this.handleStreamingError(new Error('WebRTC connection failed'));
                    } else if (this.pc.connectionState === 'disconnected') {
                        console.log('⚠️ Connection disconnected');
                    }
                };

                // Create and send offer - only if we haven't already
                if (!this.hasOffered) {
                    const offer = await this.pc.createOffer();
                    await this.pc.setLocalDescription(offer);

                    this.channel.postMessage({type: 'offer', data: offer});
                    this.hasOffered = true;
                    console.log('✅ Offer sent successfully');
                } else {
                    console.log('Offer already sent, skipping duplicate');
                }

            } catch (error) {
                console.error('Error starting stream:', error);
                this.stopStreaming();
            }
        }

        setupCaptureCanvas() { // Always create a fresh canvas for capturing
            this.captureCanvas = document.createElement('canvas');
            this.captureCtx = this.captureCanvas.getContext('2d', {
                alpha: false,
                desynchronized: true,
                willReadFrequently: false
            });

            // Use configured resolution but always maintain 16:9 aspect ratio for display compatibility
            const width = this.displaySettings.captureResolution;
            const height = Math.round(width * 9 / 16); // Always use 16:9 for display window compatibility

            this.captureCanvas.width = width;
            this.captureCanvas.height = height;

            // Store base dimensions for consistent scaling (always base on 2K for visual consistency)
            this.baseCaptureWidth = 2560;
            this.baseCaptureHeight = 1440;
            this.captureScale = width / this.baseCaptureWidth; // Scale factor for quality enhancement

            console.log('Capture canvas size:', this.captureCanvas.width, 'x', this.captureCanvas.height, '(16:9 aspect ratio for display compatibility)');
            console.log('Capture scale factor:', this.captureScale, 'x for', this.displaySettings.captureResolution + 'px quality');
        }

        startCapture() {
            console.log('startCapture() method called');
            let frameCount = 0;
            let pulsePhase = 0; // For pulse animation

            const capture = () => {
                // Continue capturing if streaming OR if file video is playing
                if (!this.isStreaming && this.visualizer.videoMode !== 'file') {
                    return;
                }
                


                try {
                    const container = document.getElementById('visualizationContainer');
                    if (! container) {
                        console.error('Container not found');
                        this.animationFrame = requestAnimationFrame(capture);
                        return;
                    }

                    // Clear capture canvas
                    this.captureCtx.fillStyle = this.visualizer.backgroundColor || '#000000';
                    this.captureCtx.fillRect(0, 0, this.captureCanvas.width, this.captureCanvas.height);

                    // Layer 1: Video background - ONLY IF KALEIDOSCOPE VIDEO IS NOT ACTIVE
                    if ((this.visualizer.videoMode === 'camera' || this.visualizer.videoMode === 'file') && !(this.visualizer.kaleidoscopeEnabled && this.visualizer.kaleidoscopeApplyToVideo)) { // Create temporary canvas for video if needed
                        if (!this.tempVideoCanvas) {
                            this.tempVideoCanvas = document.createElement('canvas');
                            this.tempVideoCanvas.width = this.captureCanvas.width;
                            this.tempVideoCanvas.height = this.captureCanvas.height;
                            this.tempVideoCtx = this.tempVideoCanvas.getContext('2d');
                        }

                        // Update temp canvas size if capture canvas changed
                        if (this.tempVideoCanvas.width !== this.captureCanvas.width || this.tempVideoCanvas.height !== this.captureCanvas.height) {
                            this.tempVideoCanvas.width = this.captureCanvas.width;
                            this.tempVideoCanvas.height = this.captureCanvas.height;
                        }

                        const videoSource = this.visualizer.captureVideoElement || this.visualizer.videoElement;
                        
                        // Debug: Log what video elements are available
                        if (frameCount % 60 === 0) { // Log every 60 frames to avoid spam
                            console.log('Capture debug - videoMode:', this.visualizer.videoMode);
                            console.log('Available video elements:', {
                                captureVideoElement: !!this.visualizer.captureVideoElement,
                                videoElement: !!this.visualizer.videoElement
                            });
                            console.log('Selected videoSource:', videoSource ? videoSource.constructor.name : 'none');
                            if (videoSource) {
                                console.log('VideoSource details:', {
                                    readyState: videoSource.readyState,
                                    dimensions: videoSource.videoWidth + 'x' + videoSource.videoHeight,
                                    paused: videoSource.paused,
                                    currentTime: videoSource.currentTime
                                });
                            }
                        }

                        if (videoSource && videoSource.readyState >= 2) {
                            if (frameCount % 60 === 0) {
                                console.log('Video source found for capture:', videoSource.constructor.name, 'ready state:', videoSource.readyState, 'dimensions:', videoSource.videoWidth + 'x' + videoSource.videoHeight);
                            }
                            // Clear temp canvas
                            this.tempVideoCtx.clearRect(0, 0, this.tempVideoCanvas.width, this.tempVideoCanvas.height);

                            this.tempVideoCtx.save();

                            // Apply mirror transformations FIRST
                            if (this.visualizer.videoMirror === 'horizontal' || this.visualizer.videoMirror === 'both') {
                                this.tempVideoCtx.scale(-1, 1);
                                this.tempVideoCtx.translate(-this.tempVideoCanvas.width, 0);
                            }
                            if (this.visualizer.videoMirror === 'vertical' || this.visualizer.videoMirror === 'both') {
                                this.tempVideoCtx.scale(1, -1);
                                this.tempVideoCtx.translate(0, -this.tempVideoCanvas.height);
                            }

                            // Build filter string
                            const filters = [];

                            // Apply posterize FIRST with much stronger effect
                            if (this.visualizer.videoPosterize < 16) {
                                const steps = this.visualizer.videoPosterize;
                                const posterizeAmount = (16 - steps) / 16;
                                filters.push(`contrast(${
                                    300 + posterizeAmount * 200
                                }%)`);
                                filters.push(`brightness(${95}%)`);
                                filters.push(`saturate(${200}%)`);
                                if (steps < 8) {
                                    filters.push(`contrast(${150}%)`);
                                }
                            }

                            // Then other filters
                            if (this.visualizer.videoBrightness !== 100 && this.visualizer.videoPosterize >= 16) {
                                filters.push(`brightness(${
                                    this.visualizer.videoBrightness
                                }%)`);
                            }
                            if (this.visualizer.videoContrast !== 100 && this.visualizer.videoPosterize >= 16) {
                                filters.push(`contrast(${
                                    this.visualizer.videoContrast
                                }%)`);
                            }
                            if (this.visualizer.videoSaturation !== 100 && this.visualizer.videoPosterize >= 16) {
                                filters.push(`saturate(${
                                    this.visualizer.videoSaturation
                                }%)`);
                            }
                            if (this.visualizer.videoHueRotate !== 0) {
                                filters.push(`hue-rotate(${
                                    this.visualizer.videoHueRotate
                                }deg)`);
                            }
                            if (this.visualizer.videoGrayscale > 0) {
                                filters.push(`grayscale(${
                                    this.visualizer.videoGrayscale
                                }%)`);
                            }
                            if (this.visualizer.videoSepia > 0) {
                                filters.push(`sepia(${
                                    this.visualizer.videoSepia
                                }%)`);
                            }
                            if (this.visualizer.videoBlur > 0) {
                                filters.push(`blur(${
                                    this.visualizer.videoBlur
                                }px)`);
                            }
                            if (this.visualizer.videoInvert) {
                                filters.push('invert(100%)');
                            }

                            this.tempVideoCtx.filter = filters.length > 0 ? filters.join(' ') : 'none';
                            this.tempVideoCtx.globalAlpha = 1;

                            // Draw video to temp canvas
                            this.tempVideoCtx.drawImage(videoSource, 0, 0, this.tempVideoCanvas.width, this.tempVideoCanvas.height);

                            this.tempVideoCtx.restore();

                            // Calculate pulse scale if enabled
                            let scale = 1;
                            if (this.visualizer.videoPulse) {
                                const pulseDuration = this.visualizer.videoPulseRate * 1000; // Convert to ms
                                pulsePhase = (Date.now() % pulseDuration) / pulseDuration;
                                scale = 1 + (Math.sin(pulsePhase * Math.PI * 2) * 0.02); // 2% scale variation
                            }

                            // Draw temp canvas to main canvas with opacity and pulse
                            this.captureCtx.save();
                            this.captureCtx.globalAlpha = this.visualizer.videoOpacity || 1;

                            if (scale !== 1) {
                                const centerX = this.captureCanvas.width / 2;
                                const centerY = this.captureCanvas.height / 2;
                                this.captureCtx.translate(centerX, centerY);
                                this.captureCtx.scale(scale, scale);
                                this.captureCtx.translate(- centerX, - centerY);
                            }

                            this.captureCtx.drawImage(this.tempVideoCanvas, 0, 0);
                            this.captureCtx.restore();

                            // Draw vignette AFTER video but BEFORE visualization
                            if (this.visualizer.videoVignette > 0) {
                                this.captureCtx.save();
                                const intensity = this.visualizer.videoVignette / 100;
                                const size = (100 - this.visualizer.videoVignette) / 100;

                                const gradient = this.captureCtx.createRadialGradient(this.captureCanvas.width / 2, this.captureCanvas.height / 2, Math.min(this.captureCanvas.width, this.captureCanvas.height) * size * 0.5, this.captureCanvas.width / 2, this.captureCanvas.height / 2, Math.max(this.captureCanvas.width, this.captureCanvas.height) * 0.7);
                                gradient.addColorStop(0, 'rgba(0, 0, 0, 0)');
                                gradient.addColorStop(1, `rgba(0, 0, 0, ${intensity})`);

                                this.captureCtx.fillStyle = gradient;
                                this.captureCtx.fillRect(0, 0, this.captureCanvas.width, this.captureCanvas.height);
                                this.captureCtx.restore();
                            }
                        }
                    }

                    // Layer 2: Kaleidoscope video (if active) - WITH FILTERS APPLIED
                    if (this.visualizer.kaleidoscopeEnabled && this.visualizer.kaleidoscopeApplyToVideo && this.visualizer.kaleidoscopeVideoCanvas && this.visualizer.kaleidoscopeVideoCanvas.style.display !== 'none') {

                        this.captureCtx.save();

                        // Apply video filters to kaleidoscope
                        const filters = [];

                        if (this.visualizer.videoPosterize < 16) {
                            const steps = this.visualizer.videoPosterize;
                            const posterizeAmount = (16 - steps) / 16;
                            filters.push(`contrast(${
                                300 + posterizeAmount * 200
                            }%)`);
                            filters.push(`brightness(${95}%)`);
                            filters.push(`saturate(${200}%)`);
                            if (steps < 8) {
                                filters.push(`contrast(${150}%)`);
                            }
                        }

                        if (this.visualizer.videoBrightness !== 100 && this.visualizer.videoPosterize >= 16) {
                            filters.push(`brightness(${
                                this.visualizer.videoBrightness
                            }%)`);
                        }
                        if (this.visualizer.videoContrast !== 100 && this.visualizer.videoPosterize >= 16) {
                            filters.push(`contrast(${
                                this.visualizer.videoContrast
                            }%)`);
                        }
                        if (this.visualizer.videoSaturation !== 100 && this.visualizer.videoPosterize >= 16) {
                            filters.push(`saturate(${
                                this.visualizer.videoSaturation
                            }%)`);
                        }
                        if (this.visualizer.videoHueRotate !== 0) {
                            filters.push(`hue-rotate(${
                                this.visualizer.videoHueRotate
                            }deg)`);
                        }
                        if (this.visualizer.videoGrayscale > 0) {
                            filters.push(`grayscale(${
                                this.visualizer.videoGrayscale
                            }%)`);
                        }
                        if (this.visualizer.videoSepia > 0) {
                            filters.push(`sepia(${
                                this.visualizer.videoSepia
                            }%)`);
                        }
                        if (this.visualizer.videoBlur > 0) {
                            filters.push(`blur(${
                                this.visualizer.videoBlur
                            }px)`);
                        }
                        if (this.visualizer.videoInvert) {
                            filters.push('invert(100%)');
                        }

                        this.captureCtx.filter = filters.length > 0 ? filters.join(' ') : 'none';
                        this.captureCtx.globalAlpha = this.visualizer.videoOpacity || 1;

                        // Apply pulse if enabled
                        if (this.visualizer.videoPulse) {
                            const pulseDuration = this.visualizer.videoPulseRate * 1000;
                            pulsePhase = (Date.now() % pulseDuration) / pulseDuration;
                            const scale = 1 + (Math.sin(pulsePhase * Math.PI * 2) * 0.02);

                            if (scale !== 1) {
                                const centerX = this.captureCanvas.width / 2;
                                const centerY = this.captureCanvas.height / 2;
                                this.captureCtx.translate(centerX, centerY);
                                this.captureCtx.scale(scale, scale);
                                this.captureCtx.translate(- centerX, - centerY);
                            }
                        }

                        // Draw kaleidoscope video canvas with proper scaling
                        this.captureCtx.save();
                        this.captureCtx.scale(this.captureScale, this.captureScale);
                        this.captureCtx.drawImage(this.visualizer.kaleidoscopeVideoCanvas, 0, 0, this.baseCaptureWidth, this.baseCaptureHeight);
                        this.captureCtx.restore();

                        this.captureCtx.restore();

                        // Apply vignette to kaleidoscope if needed
                        if (this.visualizer.videoVignette > 0) {
                            this.captureCtx.save();
                            const intensity = this.visualizer.videoVignette / 100;
                            const size = (100 - this.visualizer.videoVignette) / 100;

                            const gradient = this.captureCtx.createRadialGradient(this.captureCanvas.width / 2, this.captureCanvas.height / 2, Math.min(this.captureCanvas.width, this.captureCanvas.height) * size * 0.5, this.captureCanvas.width / 2, this.captureCanvas.height / 2, Math.max(this.captureCanvas.width, this.captureCanvas.height) * 0.7);
                            gradient.addColorStop(0, 'rgba(0, 0, 0, 0)');
                            gradient.addColorStop(1, `rgba(0, 0, 0, ${intensity})`);

                            this.captureCtx.fillStyle = gradient;
                            this.captureCtx.fillRect(0, 0, this.captureCanvas.width, this.captureCanvas.height);
                            this.captureCtx.restore();
                        }

                        if (frameCount % 60 === 0) {
                            console.log('Captured video kaleidoscope with filters');
                        }
                    }

                    // Reset context state completely before viz layers
                    this.captureCtx.save();
                    this.captureCtx.filter = 'none';
                    this.captureCtx.globalAlpha = 1;
                    this.captureCtx.globalCompositeOperation = 'source-over';

                    // Layer 3: Main visualization - Only if kaleidoscope viz is NOT active
                    if (!this.visualizer.kaleidoscopeApplyToViz || !this.visualizer.kaleidoscopeEnabled) {
                        let vizCanvas = null;

                        if (this.visualizer.audioMotion && this.visualizer.audioMotion.canvas) {
                            vizCanvas = this.visualizer.audioMotion.canvas;
                        }

                        if (! vizCanvas) {
                            const canvases = container.getElementsByTagName('canvas');
                            for (let canvas of canvases) {
                                if (! canvas.classList.contains('kaleidoscope-canvas') && canvas.width > 0 && canvas.height > 0 && canvas.id !== 'bgVideoCaptureClean') {
                                    vizCanvas = canvas;
                                    break;
                                }
                            }
                        }

                        if (vizCanvas && vizCanvas.width > 0 && vizCanvas.height > 0) {
                            const isVisible = vizCanvas.style.visibility !== 'hidden' && vizCanvas.style.display !== 'none';

                            if (isVisible) {
                                // Scale the visualization to maintain consistent visual size regardless of capture resolution
                                this.captureCtx.save();
                                this.captureCtx.scale(this.captureScale, this.captureScale);
                                this.captureCtx.drawImage(vizCanvas, 0, 0, this.baseCaptureWidth, this.baseCaptureHeight);
                                this.captureCtx.restore();

                                if (frameCount % 60 === 0) {
                                    console.log('Capturing viz from canvas:', vizCanvas.width, 'x', vizCanvas.height, 'scaled by', this.captureScale + 'x');
                                }
                            }
                        }
                    }

                    this.captureCtx.restore();

                    // Layer 4: Kaleidoscope viz (if active)
                    if (this.visualizer.kaleidoscopeEnabled && this.visualizer.kaleidoscopeApplyToViz && this.visualizer.kaleidoscopeVizCanvas && this.visualizer.kaleidoscopeVizCanvas.style.display !== 'none') {

                        this.captureCtx.save();
                        this.captureCtx.globalAlpha = 1;
                        this.captureCtx.filter = 'none';

                        // Draw kaleidoscope viz canvas with proper scaling
                        this.captureCtx.save();
                        this.captureCtx.scale(this.captureScale, this.captureScale);
                        this.captureCtx.drawImage(this.visualizer.kaleidoscopeVizCanvas, 0, 0, this.baseCaptureWidth, this.baseCaptureHeight);
                        this.captureCtx.restore();

                        if (frameCount % 60 === 0) {
                            console.log('Captured viz kaleidoscope scaled by', this.captureScale + 'x');
                        }

                        this.captureCtx.restore();
                    }

                    // Layer 5: Infinite Zoom (only when NOT captured via kaleidoscope)
                    if (this.visualizer.infiniteZoom && this.visualizer.infiniteZoom.isActive && this.visualizer.infiniteZoom.canvas) {
                        // Only capture Infinite Zoom separately if kaleidoscope is OFF or not applying to viz or not applying to infinite zoom
                        const shouldCaptureSeparately = !this.visualizer.kaleidoscopeEnabled || !this.visualizer.kaleidoscopeApplyToViz || !this.visualizer.kaleidoscopeApplyToInfiniteZoom;
                        
                        if (shouldCaptureSeparately) {
                            this.captureCtx.save();
                            this.captureCtx.globalAlpha = this.visualizer.infiniteZoom.opacity || 1;
                            this.captureCtx.filter = 'none';

                            // Draw Infinite Zoom canvas with proper scaling
                            this.captureCtx.save();
                            this.captureCtx.scale(this.captureScale, this.captureScale);
                            this.captureCtx.drawImage(this.visualizer.infiniteZoom.canvas, 0, 0, this.baseCaptureWidth, this.baseCaptureHeight);
                            this.captureCtx.restore();

                            if (frameCount % 60 === 0) {
                                console.log('Captured Infinite Zoom separately scaled by', this.captureScale + 'x');
                            }

                            this.captureCtx.restore();
                        } else if (frameCount % 60 === 0) {
                            console.log('Infinite Zoom captured via kaleidoscope - skipping separate capture');
                        }
                    }

                    frameCount++;

                } catch (error) {
                    console.error('Capture error:', error);
                }

                this.animationFrame = requestAnimationFrame(capture);
            };

            capture();
        }

        async handleAnswer(answer) {
            try {
                if (!this.pc) {
                    console.warn('No peer connection available for answer');
                    return;
                }

                console.log('Handling answer, current signaling state:', this.pc.signalingState);
                console.log('Connection state:', this.pc.connectionState);

                if (this.pc.signalingState === 'have-local-offer') {
                    await this.pc.setRemoteDescription(answer);
                    console.log('Answer set successfully');
                    
                    // Process any queued ICE candidates now that we have remote description
                    await this.processPendingIceCandidates();
                } else if (this.pc.signalingState === 'stable') {
                    console.log('Peer connection already stable, ignoring duplicate answer');
                    // Connection might already be established, check if we have a stream
                    if (this.pc.connectionState === 'connected') {
                        console.log('Connection already established successfully');
                    }
                } else {
                    console.warn('Cannot set remote description, unexpected signaling state:', this.pc.signalingState);
                }
            } catch (error) {
                console.error('Error handling answer:', error);
                // If this fails, the connection might be in a bad state - close and retry
                if (this.pc) {
                    this.pc.close();
                    this.pc = null;
                }
            }
        }

        async handleIceCandidate(candidateData) {
            try {
                if (this.pc && this.pc.remoteDescription) { 
                    // Reconstruct RTCIceCandidate from plain object
                    const candidate = new RTCIceCandidate({candidate: candidateData.candidate, sdpMLineIndex: candidateData.sdpMLineIndex, sdpMid: candidateData.sdpMid, usernameFragment: candidateData.usernameFragment});
                    await this.pc.addIceCandidate(candidate);
                    console.log('ICE candidate added successfully from display window');
                } else if (this.pc) {
                    // Queue the candidate if we don't have remote description yet
                    console.log('Queueing ICE candidate until remote description is set');
                    this.pendingIceCandidates.push(candidateData);
                } else {
                    console.warn('Cannot add ICE candidate: no peer connection');
                }
            } catch (error) {
                console.error('Error adding ICE candidate:', error);
            }
        }

        async processPendingIceCandidates() {
            // Process any queued ICE candidates after remote description is set
            for (const candidateData of this.pendingIceCandidates) {
                try {
                    const candidate = new RTCIceCandidate({candidate: candidateData.candidate, sdpMLineIndex: candidateData.sdpMLineIndex, sdpMid: candidateData.sdpMid, usernameFragment: candidateData.usernameFragment});
                    await this.pc.addIceCandidate(candidate);
                    console.log('Queued ICE candidate added successfully');
                } catch (error) {
                    console.error('Error adding queued ICE candidate:', error);
                }
            }
            this.pendingIceCandidates = [];
        }

        handleStreamingError(error) {
            console.error('Streaming error occurred:', error);
            
            // Show user-friendly error message
            const errorMessage = error.message || 'Unknown connection error';
            console.warn('Connection error: ' + errorMessage);
            
            // Don't automatically retry - this was causing connection loops
            console.log('❌ Streaming stopped due to error. Manual restart required.');
            
            // Reset streaming state without auto-retry
            this.isStreaming = false;
            this.hasOffered = false;
            
            // Close peer connection but keep display window open
            if (this.pc) {
                this.pc.close();
                this.pc = null;
            }
            
            // Update button state
            const btn = document.getElementById('liveDisplayBtn');
            if (btn) {
                btn.classList.remove('active');
                btn.textContent = 'Live Display';
            }
        }

        stopStreaming() {
            this.isStreaming = false;

            // Reset offer tracking
            this.hasOffered = false;

            // Stop capture animation
            if (this.animationFrame) {
                cancelAnimationFrame(this.animationFrame);
                this.animationFrame = null;
            }

            // Remove debug canvas if it exists
            if (this.captureCanvas && this.captureCanvas.parentNode) {
                this.captureCanvas.parentNode.removeChild(this.captureCanvas);
            }

            // Close peer connection
            if (this.pc) {
                this.pc.close();
                this.pc = null;
            }

            // Stop stream tracks
            if (this.stream) {
                this.stream.getTracks().forEach(track => track.stop());
                this.stream = null;
            }

            // Notify display window
            this.channel.postMessage({type: 'close'});

            // Close display window
            if (this.displayWindow && !this.displayWindow.closed) {
                this.displayWindow.close();
            }
            this.displayWindow = null;

            // Update button state
            const btn = document.getElementById('liveDisplayBtn');
            if (btn) {
                btn.classList.remove('active');
                btn.textContent = 'Live Display';
            }
        }
    }


    // ****
    // ****

    // GitItUp Visualizer Class with Audio Input and Morph Support
    class GitItUpVisualizer {
        constructor() {
            this.audio = null;
            this.audioMotion = null;
            this.isPlaying = false;
            this.currentTrackIndex = 0;
            this.playlist = [];
            this.volume = 0.7;
            this.previousVolume = 0.7;
            this.isMuted = false;
            this.currentMode = 0;
            this.loopMode = 'off';
            this.currentColorScheme = 'default';
            this.backgroundColor = '#000000';
            this.isFullscreen = false;
            this.savedPresets = this.loadPresets();
            this.audioInitialized = false;
            this.streamManager = null;

            // Audio input properties
            this.inputMode = 'playlist';
            this.audioStream = null;
            this.streamSource = null;
            this.availableDevices = [];

            // Viz ON/OFF Toggle
            this.visualizationEnabled = true;

            // Morph properties
            this.isMorphing = false;
            this.morphInterval = null;
            this.morphStartConfig = null;
            this.morphTargetConfig = null;
            this.morphProgress = 0;
            this.morphDuration = 5000;
            this.morphMode = 'medium';

            // Auto-hide fullscreen controls
            this.controlsTimeout = null;
            this.controlsVisible = true;

            // Energy detection
            this.currentEnergy = 0;
            this.lastEnergy = 0;
            this.energyHistory = [];
            this.energyCheckInterval = null;

            // Video background properties
            this.videoMode = 'off'; // 'off', 'camera', 'file'
            this.videoStream = null;
            this.videoElement = null;
            this.availableVideoDevices = [];
            this.videoOpacity = 1.0;
            this.videoFadeTime = 3; // seconds
            this.videoFadeTimeout = null;
            this.currentVideoDeviceId = null;
            
            // Video file properties
            this.videoFile = null;
            this.videoFileLoop = true;
            this.videoFileMuted = true;
            this.videoAudioSource = null;
            this.videoAudioGain = null;
            this.matchVisualizationAspect = true; // Match visualization to video aspect ratio

            // Kaleidoscope properties
            this.kaleidoscopeEnabled = false;
            this.kaleidoscopeSegments = 6;
            this.kaleidoscopeRotation = 0;
            this.kaleidoscopeSpeed = 0;
            this.kaleidoscopeScale = 1.0;
            this.kaleidoscopeCenterX = 0.5;
            this.kaleidoscopeCenterY = 0.5;
            this.kaleidoscopeApplyToVideo = false;
            this.kaleidoscopeApplyToViz = false;
            this.kaleidoscopeApplyToInfiniteZoom = false; // Default to disabled
            this.kaleidoscopeRings = 1; // Number of rings
            this.kaleidoscopeRingSpacing = 0.2; // Spacing between rings (as percentage)
            this.kaleidoscopeShape = 'triangle'; // 'triangle', 'petal', 'rectangle'
            this.kaleidoscopeRingSpeedMultiplier = 0.5; // How much each ring's speed differs
            this.kaleidoscopeRingRotations = [
                0,
                0,
                0,
                0,
                0
            ]; // Track individual ring rotations
            this.kaleidoscopeBaseScale = 1; // Add this if not already there
            this.kaleidoscopeBeatRotation = false;
            this.kaleidoscopeBeatShape = false;
            this.kaleidoscopeShapeThreshold = 0.7; // Energy threshold for shape change
            this.kaleidoscopeOriginalShape = 'triangle';


            // Separate canvases for video and viz
            this.kaleidoscopeVideoCanvas = null;
            this.kaleidoscopeVideoCtx = null;
            this.kaleidoscopeVizCanvas = null;
            this.kaleidoscopeVizCtx = null;

            this.kaleidoscopeAnimationFrame = null;

            // REact to audio inout
            this.kaleidoscopeBeatReactive = false;
            this.kaleidoscopeBeatSensitivity = 0.5;
            this.kaleidoscopeBaseScale = 1;
            this.kaleidoscopeBaseSegments = 6;

            this.kaleidoscopePresets = [
                {
                    name: 'Classic',
                    segments: 6,
                    rings: 1,
                    shape: 'triangle',
                    scale: 100,
                    speed: 0,
                    ringSpacing: 20
                },
                {
                    name: 'Flower',
                    segments: 8,
                    rings: 3,
                    shape: 'petal',
                    scale: 120,
                    speed: 2,
                    ringSpacing: 15
                },
                {
                    name: 'Crystal',
                    segments: 12,
                    rings: 2,
                    shape: 'triangle',
                    scale: 100,
                    speed: 1,
                    ringSpacing: 25
                },
                {
                    name: 'Mandala',
                    segments: 16,
                    rings: 4,
                    shape: 'petal',
                    scale: 150,
                    speed: 0.5,
                    ringSpacing: 10
                }, {
                    name: 'Star',
                    segments: 5,
                    rings: 2,
                    shape: 'triangle',
                    scale: 110,
                    speed: 3,
                    ringSpacing: 30
                }
            ];


            // Enhanced video properties
            this.videoBrightness = 100;
            this.videoContrast = 100;
            this.videoHueRotate = 0;
            this.videoGrayscale = 0;
            this.videoSepia = 0;
            this.videoBlur = 0;
            this.videoSaturation = 100;
            this.videoPosterize = 16;
            this.videoVignette = 0;
            this.videoInvert = false;
            this.videoMirror = 'off'; // 'off', 'horizontal', 'vertical', 'both'
            this.videoPulse = false;
            this.vignetteElement = null;
            this.videoPulseRate = 2.0;
            // seconds for one complete pulse cycle

            // AudioMotion-style visualization modes
            this.visualizationModes = [
                // 0 - Spectrum
                {
                    alphaBars: false,
                    ansiBands: false,
                    barSpace: 0, // No spacing between bars for solid look
                    bgAlpha: 0.7,
                    channelLayout: 'single',
                    colorMode: 'gradient',
                    fadePeaks: false,
                    fftSize: 8192,
                    fillAlpha: 1,
                    frequencyScale: 'log',
                    gradient: 'classic', // Orange-yellow-green gradient
                    gravity: 3.8,
                    ledBars: false,
                    linearAmplitude: true,
                    linearBoost: 1.5,
                    lineWidth: 0,
                    loRes: false,
                    lumiBars: false,
                    maxDecibels: -25,
                    maxFPS: 0,
                    maxFreq: 22000,
                    minDecibels: -85,
                    minFreq: 20,
                    mirror: 0,
                    mode: 0, // This tells it to use maximum frequency bins
                    noteLabels: false,
                    outlineBars: false,
                    overlay: false,
                    peakFadeTime: 750, // As requested
                    peakHoldTime: 500, // As requested
                    peakLine: false, // As requested
                    radial: false,
                    radialInvert: false,
                    radius: 0.3,
                    reflexAlpha: 0.15,
                    reflexBright: 1,
                    reflexFit: true,
                    reflexRatio: 0,
                    roundBars: false,
                    showBgColor: true,
                    showFPS: false,
                    showPeaks: true, // As requested
                    showScaleX: false,
                    showScaleY: false,
                    smoothing: 0.7, // Increased for smoother animation
                    spinSpeed: 0,
                    splitGradient: false,
                    trueLeds: false,
                    useCanvas: true,
                    volume: 1,
                    weightingFilter: ''
                },
                // 1 - Mirror Wave
                {
                    alphaBars: false,
                    ansiBands: true,
                    barSpace: 0.4243301972800962,
                    bgAlpha: 0.8718491729657911,
                    channelLayout: 'single',
                    colorMode: 'gradient',
                    fadePeaks: false,
                    fftSize: 8192,
                    fillAlpha: 0.7409580781999876,
                    frequencyScale: 'linear',
                    gradient: 'prism',
                    gravity: 5.241110765118057,
                    ledBars: false,
                    lineWidth: 1.9277868849548745,
                    linearAmplitude: false,
                    linearBoost: 1.0031368643495397,
                    loRes: false,
                    lumiBars: false,
                    maxDecibels: -40,
                    maxFPS: 0,
                    maxFreq: 20000,
                    minDecibels: -110.00902526586772,
                    minFreq: 28.17293591192646,
                    mirror: 1,
                    mode: 0,
                    noteLabels: false,
                    outlineBars: false,
                    overlay: false,
                    peakFadeTime: 594.7913467712076,
                    peakHoldTime: 502.3206017658375,
                    peakLine: false,
                    radial: false,
                    radialInvert: true,
                    radius: 0.41579158468294086,
                    reflexAlpha: 0.9552641490887127,
                    reflexBright: 1,
                    reflexFit: true,
                    reflexRatio: 0.01,
                    roundBars: true,
                    showBgColor: false,
                    showFPS: false,
                    showPeaks: true,
                    showScaleX: false,
                    showScaleY: false,
                    smoothing: 0.3269721028259904,
                    spinSpeed: 0.5612575550887594,
                    splitGradient: false,
                    trueLeds: false,
                    useCanvas: true,
                    volume: 0.7515247792883378,
                    weightingFilter: 'D'
                },
                // 2 - Classic LED
                {
                    alphaBars: false,
                    ansiBands: true,
                    barSpace: 0.5,
                    bgAlpha: 0.7,
                    channelLayout: 'single',
                    colorMode: 'gradient',
                    fadePeaks: false,
                    fftSize: 8192,
                    fillAlpha: 1,
                    frequencyScale: 'log',
                    gradient: 'classic',
                    gravity: 3.8,
                    ledBars: true,
                    linearAmplitude: false,
                    linearBoost: 1,
                    lineWidth: 0,
                    loRes: false,
                    lumiBars: false,
                    maxDecibels: -25,
                    maxFPS: 0,
                    maxFreq: 20000,
                    minDecibels: -85,
                    minFreq: 25,
                    mirror: 0,
                    mode: 6,
                    noteLabels: false,
                    outlineBars: false,
                    overlay: false,
                    peakFadeTime: 750,
                    peakHoldTime: 500,
                    peakLine: false,
                    radial: false,
                    radialInvert: false,
                    radius: 0.3,
                    reflexAlpha: 0.15,
                    reflexBright: 1,
                    reflexFit: true,
                    reflexRatio: 0,
                    roundBars: false,
                    showBgColor: true,
                    showFPS: false,
                    showPeaks: true,
                    showScaleX: false,
                    showScaleY: false,
                    smoothing: 0.5,
                    spinSpeed: 0,
                    splitGradient: false,
                    trueLeds: true,
                    useCanvas: true,
                    volume: 1,
                    weightingFilter: ''
                },
                // 3 - Stereo
                {
                    alphaBars: false,
                    ansiBands: false,
                    barSpace: 0.1,
                    bgAlpha: 0.7,
                    channelLayout: 'dual-horizontal',
                    colorMode: 'gradient',
                    fadePeaks: false,
                    fftSize: 8192,
                    fillAlpha: 0.8,
                    frequencyScale: 'log',
                    gradient: 'rainbow',
                    gravity: 3.8,
                    ledBars: false,
                    linearAmplitude: false,
                    linearBoost: 1.8,
                    lineWidth: 2,
                    loRes: false,
                    lumiBars: false,
                    maxDecibels: -35,
                    maxFPS: 0,
                    maxFreq: 16000,
                    minDecibels: -85,
                    minFreq: 20,
                    mirror: 1,
                    mode: 2,
                    noteLabels: false,
                    outlineBars: true,
                    overlay: false,
                    peakFadeTime: 750,
                    peakHoldTime: 500,
                    peakLine: false,
                    radial: false,
                    radialInvert: false,
                    radius: 0.3,
                    reflexAlpha: 0.5,
                    reflexBright: 2,
                    reflexFit: true,
                    reflexRatio: 0.5,
                    roundBars: true,
                    showBgColor: true,
                    showFPS: false,
                    showPeaks: true,
                    showScaleX: false,
                    showScaleY: false,
                    smoothing: 0.7,
                    spinSpeed: 0,
                    splitGradient: false,
                    trueLeds: false,
                    useCanvas: true,
                    volume: 1,
                    weightingFilter: ''
                },
                // 4 - Radial Spectrum
                {
                    alphaBars: false,
                    ansiBands: true,
                    barSpace: 0.4243301972800962,
                    bgAlpha: 0.8718491729657911,
                    channelLayout: 'single',
                    colorMode: 'gradient',
                    fadePeaks: false,
                    fftSize: 8192,
                    fillAlpha: 0.9,
                    frequencyScale: 'linear',
                    gradient: 'prism',
                    gravity: 5.241110765118057,
                    ledBars: false,
                    lineWidth: 1.9277868849548745,
                    linearAmplitude: true,
                    linearBoost: 2.4,
                    loRes: false,
                    lumiBars: false,
                    maxDecibels: -22.957439488374686,
                    maxFPS: 0,
                    maxFreq: 17748.142603118187,
                    minDecibels: -95.00902526586772,
                    minFreq: 28.17293591192646,
                    mirror: 0,
                    mode: 0,
                    noteLabels: false,
                    outlineBars: false,
                    overlay: false,
                    peakFadeTime: 594.7913467712076,
                    peakHoldTime: 502.3206017658375,
                    peakLine: false,
                    radial: true,
                    radialInvert: false,
                    radius: 1.2,
                    reflexAlpha: 0.9552641490887127,
                    reflexBright: 1,
                    reflexFit: true,
                    reflexRatio: 0.0827583789810725,
                    roundBars: true,
                    showBgColor: false,
                    showFPS: false,
                    showPeaks: true,
                    showScaleX: false,
                    showScaleY: false,
                    smoothing: 0.3269721028259904,
                    spinSpeed: 0.5612575550887594,
                    splitGradient: false,
                    trueLeds: false,
                    useCanvas: true,
                    volume: 0.7515247792883378,
                    weightingFilter: 'D'
                },
                // 5 - Energy
                {
                    alphaBars: false,
                    ansiBands: false,
                    barSpace: 0.1,
                    bgAlpha: 0.0,
                    channelLayout: 'single',
                    colorMode: 'gradient',
                    fadePeaks: false,
                    fftSize: 8192,
                    fillAlpha: 0.7,
                    frequencyScale: 'log',
                    gradient: 'steelblue',
                    gravity: 3.8,
                    ledBars: false,
                    linearAmplitude: false,
                    linearBoost: 1,
                    lineWidth: 3,
                    loRes: false,
                    lumiBars: false,
                    maxDecibels: -25,
                    maxFPS: 0,
                    maxFreq: 16000,
                    minDecibels: -85,
                    minFreq: 30,
                    mirror: -1,
                    mode: 10,
                    noteLabels: false,
                    outlineBars: false,
                    overlay: false,
                    peakFadeTime: 750,
                    peakHoldTime: 500,
                    peakLine: false,
                    radial: false,
                    radialInvert: false,
                    radius: 0.3,
                    reflexAlpha: 0,
                    reflexBright: 1,
                    reflexFit: true,
                    reflexRatio: 0.5,
                    roundBars: false,
                    showBgColor: true,
                    showFPS: false,
                    showPeaks: false,
                    showScaleX: false,
                    showScaleY: false,
                    smoothing: 0.5,
                    spinSpeed: 0,
                    splitGradient: false,
                    trueLeds: false,
                    useCanvas: true,
                    volume: 1,
                    weightingFilter: ''
                },
                // 6 - Mirror (Center-split Stereo)
                {
                    alphaBars: false,
                    ansiBands: false,
                    barSpace: 0.2,
                    bgAlpha: 0.7,
                    channelLayout: 'dual-vertical',
                    colorMode: 'gradient',
                    fadePeaks: false,
                    fftSize: 8192,
                    fillAlpha: 0.9,
                    frequencyScale: 'log',
                    gradient: 'orangered',
                    gravity: 3.8,
                    ledBars: false,
                    linearAmplitude: false,
                    linearBoost: 1,
                    lineWidth: 0,
                    loRes: false,
                    lumiBars: false,
                    maxDecibels: -25,
                    maxFPS: 0,
                    maxFreq: 20000,
                    minDecibels: -85,
                    minFreq: 20,
                    mirror: 0,
                    mode: 1,
                    noteLabels: false,
                    outlineBars: false,
                    overlay: false,
                    peakFadeTime: 750,
                    peakHoldTime: 500,
                    peakLine: false,
                    radial: false,
                    radialInvert: false,
                    radius: 0.3,
                    reflexAlpha: 0.4,
                    reflexBright: 1,
                    reflexFit: true,
                    reflexRatio: 0.01,
                    roundBars: false,
                    showBgColor: true,
                    showFPS: false,
                    showPeaks: false,
                    showScaleX: false,
                    showScaleY: false,
                    smoothing: 0.5,
                    spinSpeed: 0,
                    splitGradient: false,
                    trueLeds: false,
                    useCanvas: true,
                    volume: 1,
                    weightingFilter: ''
                }
            ];

            this.init();
        }

        async init() {
            try {
                this.setupEventListeners();
                this.loadPlaylist();

                this.loadBackgroundColor();
                this.updatePresetSelector();

                await this.initAudioMotion();

                this.streamManager = new StreamManager(this);
                this.recordManager = new RecordManager(this);
                this.playlistManager = new PlaylistManager(this);
                this.aiAutopilot = new AIAutopilot(this);
                this.infiniteZoom = new InfiniteZoomVisualization(this);
                
                // Initialize playlist UI handlers
                this.initializePlaylistUI();

                this.setBackgroundColor(this.backgroundColor);

                await this.initializeAudioInput();

                await this.initializeFirstTrack();
                this.hideLoading();
            } catch (error) {
                console.error('Initialization error:', error);
                this.showError('Failed to initialize audio visualizer: ' + error.message);
            }
        }

        async initializeFirstTrack() {
            await this.preloadTrack(0);
            this.audioInitialized = true;
        }

        async initAudioMotion() {
            try {
                console.log('Creating SpectrumAnalyzer instance...');

                this.audioMotion = new SpectrumAnalyzer(document.getElementById('visualizer'), this.visualizationModes[0]);

                console.log('SpectrumAnalyzer initialized successfully');

            } catch (error) {
                console.error('SpectrumAnalyzer initialization error:', error);
                throw error;
            }
        }

        // Audio Input Methods
        async initializeAudioInput() {
            try {
                const devices = await navigator.mediaDevices.enumerateDevices();
                this.availableDevices = devices.filter(d => d.kind === 'audioinput');
                this.updateDeviceList();
            } catch (e) {
                console.log('Cannot enumerate devices yet');
            }
        }

        updateDeviceList() {
            const select = document.getElementById('audioDeviceSelect');
            if (! select) 
                return;
            


            select.innerHTML = '<option value="">Select Audio Input...</option>';

            this.availableDevices.forEach(device => {
                const option = document.createElement('option');
                option.value = device.deviceId;
                let displayName = device.label || `Input ${
                    device.deviceId.substr(0, 5)
                }`;

                if (displayName.includes('BlackHole') || displayName.includes('Loopback') || displayName.includes('Virtual') || displayName.includes('Soundflower')) {
                    displayName = '🎵 ' + displayName;
                }

                option.textContent = displayName;
                select.appendChild(option);
            });


            const helpOption = document.createElement('option');
            helpOption.value = 'help';
            helpOption.textContent = '❓ How to capture system audio...';
            select.appendChild(helpOption);
        }

        async toggleInputMode() {
            const btn = document.getElementById('inputModeBtn');
            const btnText = btn.querySelector('.input-mode-text');
            const deviceSelect = document.getElementById('audioDeviceSelect');

            if (this.inputMode === 'playlist') {
                try {
                    let devices = await navigator.mediaDevices.enumerateDevices();
                    let audioInputs = devices.filter(d => d.kind === 'audioinput');

                    const hasLabels = audioInputs.length > 0 && audioInputs.some(d => d.label && d.label !== '');

                    if (! hasLabels) {
                        console.log('No device labels, requesting permission...');

                        try {
                            const stream = await navigator.mediaDevices.getUserMedia({audio: true});

                            stream.getTracks().forEach(track => {
                                track.stop();
                                console.log('Stopped track:', track.label);
                            });

                            devices = await navigator.mediaDevices.enumerateDevices();
                            audioInputs = devices.filter(d => d.kind === 'audioinput');
                            console.log('Found audio inputs:', audioInputs);

                        } catch (err) {
                            console.error('getUserMedia error:', err);

                            if (err.name === 'NotAllowedError' || err.name === 'PermissionDeniedError') {
                                this.showError('Microphone blocked. Click the lock icon in the address bar, set Microphone to "Allow", then refresh the page.');
                            } else if (err.name === 'NotFoundError' || err.name === 'DevicesNotFoundError') {
                                this.showError('No microphone found. Please connect a microphone.');
                            } else if (err.name === 'NotReadableError' || err.name === 'TrackStartError') {
                                this.showError('Microphone is being used by another application.');
                            } else {
                                this.showError(`Microphone error: ${
                                    err.name
                                } - ${
                                    err.message
                                }`);
                            }
                            return;
                        }
                    }

                    this.availableDevices = audioInputs;

                    if (this.availableDevices.length === 0) {
                        this.showError('No audio input devices found. Please connect a microphone.');
                        return;
                    }

                    this.updateDeviceList();
                    deviceSelect.style.display = 'block';
                    btnText.textContent = 'Select Input';
                    this.inputMode = 'selecting';

                } catch (e) {
                    console.error('Unexpected error:', e);
                    this.showError(`Error: ${
                        e.message
                    }`);
                }
            } else {
                this.stopLiveInput();
                btnText.textContent = 'Audio Input';
                btn.classList.remove('live-mode');
                deviceSelect.style.display = 'none';
                this.inputMode = 'playlist';
                this.resumePlaylist();
            }
        }

        async initializeVideoInput() {
            try { // Request permission if needed
                const devices = await navigator.mediaDevices.enumerateDevices();
                let videoDevices = devices.filter(d => d.kind === 'videoinput');

                // If no labels, request permission
                if (videoDevices.length > 0 && ! videoDevices[0].label) {
                    const tempStream = await navigator.mediaDevices.getUserMedia({video: true});
                    tempStream.getTracks().forEach(track => track.stop());

                    // Re-enumerate with permissions
                    const devicesWithLabels = await navigator.mediaDevices.enumerateDevices();
                    videoDevices = devicesWithLabels.filter(d => d.kind === 'videoinput');
                }

                this.availableVideoDevices = videoDevices;
                this.updateVideoDeviceList();

            } catch (e) {
                console.log('Video device enumeration failed:', e);
            }
        }

        updateVideoDeviceList() {
            const select = document.getElementById('videoDeviceSelect');
            if (! select) 
                return;
            


            select.innerHTML = '<option value="">Select Video Input...</option>';

            this.availableVideoDevices.forEach(device => {
                const option = document.createElement('option');
                option.value = device.deviceId;
                let displayName = device.label || `Camera ${
                    device.deviceId.substr(0, 5)
                }`;

                // Add icons for common camera types including Continuity Camera
                if (displayName.toLowerCase().includes('iphone') || 
                    displayName.toLowerCase().includes('ipad') ||
                    displayName.toLowerCase().includes('continuity')) {
                    displayName = '📱 ' + displayName + ' (Continuity Camera)';
                } else if (displayName.toLowerCase().includes('obs')) {
                    displayName = '🎬 ' + displayName;
                } else if (displayName.toLowerCase().includes('virtual')) {
                    displayName = '💻 ' + displayName;
                } else if (displayName.toLowerCase().includes('back') || displayName.toLowerCase().includes('rear')) {
                    displayName = '📷 ' + displayName;
                } else {
                    displayName = '📹 ' + displayName;
                } option.textContent = displayName;
                select.appendChild(option);
            });

            // Add separator
            const separator = document.createElement('option');
            separator.disabled = true;
            separator.textContent = '──────────────';
            select.appendChild(separator);

            // Add video from file option
            const fileOption = document.createElement('option');
            fileOption.value = 'file';
            fileOption.textContent = '📁 Video from file' + (this.videoFile ? ` (${this.videoFile.name})` : '');
            select.appendChild(fileOption);
            
            console.log('Video device list updated. Total options:', select.options.length);
        }

        async toggleVideoInput() {
            const btn = document.getElementById('videoInputBtn');
            const btnText = btn.querySelector('.video-mode-text');
            const deviceSelect = document.getElementById('videoDeviceSelect');
            const controlsPanel = document.getElementById('videoControlsPanel');

            if (this.videoMode === 'off') { // Show device selector
                await this.initializeVideoInput();

                deviceSelect.style.display = 'block';
                btnText.textContent = 'Select Video Source';
                this.videoMode = 'selecting';

            } else { // Turn off video
                this.stopVideoInput();
                btnText.textContent = 'Video Input';
                btn.classList.remove('video-active');
                deviceSelect.style.display = 'none';
                controlsPanel.style.display = 'none';
                this.videoMode = 'off';
            }
        }

        updateVisualizationAspectRatio() {
            console.log('=== updateVisualizationAspectRatio called ===');
            console.log('matchVisualizationAspect:', this.matchVisualizationAspect);
            console.log('videoElement exists:', !!this.videoElement);
            console.log('audioMotion exists:', !!this.audioMotion);
            console.log('videoMode:', this.videoMode);

            if (!this.matchVisualizationAspect || !this.videoElement || !this.audioMotion) {
                console.log('Early return - missing required components');
                return;
            }

            try {
                // Get video dimensions
                const videoWidth = this.videoElement.videoWidth;
                const videoHeight = this.videoElement.videoHeight;
                
                console.log('Raw video dimensions:', videoWidth, 'x', videoHeight);
                console.log('Video readyState:', this.videoElement.readyState);
                console.log('Video currentTime:', this.videoElement.currentTime);
                
                if (!videoWidth || !videoHeight) {
                    console.warn('Video dimensions not available yet - scheduling retry');
                    // Try again in a bit
                    setTimeout(() => this.updateVisualizationAspectRatio(), 500);
                    return;
                }

                const videoAspect = videoWidth / videoHeight;
                console.log(`✓ Video aspect ratio: ${videoWidth}x${videoHeight} (${videoAspect.toFixed(3)})`);

                // Get current canvas dimensions
                const currentWidth = this.audioMotion.canvas.width;
                const currentHeight = this.audioMotion.canvas.height;
                const currentAspect = currentWidth / currentHeight;

                console.log(`✓ Current canvas aspect ratio: ${currentWidth}x${currentHeight} (${currentAspect.toFixed(3)})`);

                // Only resize if aspect ratios are significantly different (avoid tiny adjustments)
                const aspectDiff = Math.abs(videoAspect - currentAspect);
                console.log('Aspect ratio difference:', aspectDiff);
                
                if (aspectDiff < 0.01) {
                    console.log('✓ Aspect ratios already match, no resize needed');
                    return;
                }

                // Calculate new canvas dimensions maintaining current height
                const newWidth = Math.round(currentHeight * videoAspect);
                
                console.log(`🔄 Resizing visualization canvas: ${currentWidth}x${currentHeight} → ${newWidth}x${currentHeight}`);
                
                // Resize the AudioMotion canvas
                this.audioMotion.canvas.width = newWidth;
                this.audioMotion.canvas.height = currentHeight;
                
                console.log('Canvas resized, triggering AudioMotion handleResize...');
                
                // Trigger AudioMotion to handle the resize
                if (this.audioMotion.handleResize) {
                    this.audioMotion.handleResize();
                    console.log('✓ AudioMotion handleResize called');
                } else {
                    console.log('⚠ AudioMotion handleResize not available, using fallback');
                    // Fallback: manually trigger resize handling
                    const container = document.getElementById('visualizer');
                    if (container) {
                        container.style.width = newWidth + 'px';
                        container.style.height = currentHeight + 'px';
                        console.log('✓ Container resized manually');
                    }
                }

                console.log('✅ Visualization canvas resized to match video aspect ratio');

            } catch (error) {
                console.error('❌ Error updating visualization aspect ratio:', error);
            }
        }

        restoreOriginalAspectRatio() {
            if (!this.audioMotion) return;

            try {
                // Get the container's natural dimensions
                const container = document.getElementById('visualizer');
                if (container) {
                    const rect = container.getBoundingClientRect();
                    const containerWidth = rect.width || 800;
                    const containerHeight = rect.height || 400;

                    console.log(`Restoring original canvas dimensions: ${containerWidth}x${containerHeight}`);

                    this.audioMotion.canvas.width = containerWidth;
                    this.audioMotion.canvas.height = containerHeight;

                    if (this.audioMotion.handleResize) {
                        this.audioMotion.handleResize();
                    }
                }
            } catch (error) {
                console.error('Error restoring original aspect ratio:', error);
            }
        }

        async connectVideoAudio() {
            try {
                if (!this.videoElement || !this.audioMotion || !this.audioMotion.audioCtx) {
                    console.warn('Cannot connect video audio: missing video element or audio context');
                    return;
                }

                // Disconnect any existing video audio connection
                this.disconnectVideoAudio();

                const audioCtx = this.audioMotion.audioCtx;
                
                // Resume audio context if needed
                if (audioCtx.state === 'suspended') {
                    await audioCtx.resume();
                }

                // Create audio source from video element
                this.videoAudioSource = audioCtx.createMediaElementSource(this.videoElement);
                
                // Create gain node for mute control
                this.videoAudioGain = audioCtx.createGain();
                
                // Set initial gain based on mute state
                this.videoAudioGain.gain.value = this.videoFileMuted ? 0 : 1;
                
                // Connect: videoElement -> audioSource -> gainNode -> destination
                this.videoAudioSource.connect(this.videoAudioGain);
                this.videoAudioGain.connect(audioCtx.destination);
                
                // Connect to analyzer for visualization
                // Note: This will work alongside playlist audio if both are playing
                this.videoAudioGain.connect(this.audioMotion.analyser);
                
                // Connect to stereo analyzer if available
                if (this.audioMotion.analyserRight && 
                    (this.audioMotion.channelLayout === 'dual-vertical' || this.audioMotion.channelLayout === 'dual-horizontal')) {
                    // For stereo, we need a splitter
                    if (this.audioMotion.splitter) {
                        this.videoAudioGain.connect(this.audioMotion.splitter);
                        this.audioMotion.splitter.connect(this.audioMotion.analyser, 0);
                        this.audioMotion.splitter.connect(this.audioMotion.analyserRight, 1);
                    } else {
                        this.videoAudioGain.connect(this.audioMotion.analyser);
                    }
                }
                
                console.log('Video audio connected to AudioMotion with gain control');
                
            } catch (error) {
                console.error('Failed to connect video audio:', error);
            }
        }

        disconnectVideoAudio() {
            try {
                if (this.videoAudioSource) {
                    this.videoAudioSource.disconnect();
                    this.videoAudioSource = null;
                }
                if (this.videoAudioGain) {
                    this.videoAudioGain.disconnect();
                    this.videoAudioGain = null;
                }
                console.log('Video audio disconnected');
            } catch (error) {
                console.error('Error disconnecting video audio:', error);
            }
        }

        initializePlaylistUI() {
            // Prevent dropdown from closing when clicking inside playlist content
            const playlistDropdown = document.getElementById('playlistDropdown');
            if (playlistDropdown) {
                playlistDropdown.addEventListener('click', (e) => {
                    e.stopPropagation();
                    console.log('Click inside playlist dropdown - preventing close');
                });
            }
            
            // Close button handler - try to find it, if not found, retry later
            this.initializeCloseButtonHandler();
            
            // Playlist scan button
            const scanBtn = document.getElementById('playlistScanBtn');
            if (scanBtn) {
                // Remove any existing listeners to prevent duplicates
                const newScanBtn = scanBtn.cloneNode(true);
                scanBtn.parentNode.replaceChild(newScanBtn, scanBtn);
                
                newScanBtn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    console.log('Playlist scan button clicked');
                    if (this.playlistManager) {
                        // Use setTimeout to ensure user activation is preserved
                        setTimeout(() => {
                            this.playlistManager.scanFolder();
                        }, 0);
                    }
                });
            }
            
            // Playlist import button
            const importBtn = document.getElementById('playlistImportBtn');
            const importInput = document.getElementById('playlistImportInput');
            if (importBtn && importInput) {
                // Remove any existing listeners to prevent duplicates
                const newImportBtn = importBtn.cloneNode(true);
                importBtn.parentNode.replaceChild(newImportBtn, importBtn);
                
                newImportBtn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    console.log('Playlist import button clicked');
                    importInput.click();
                });
                
                // Only attach the change listener once
                importInput.removeEventListener('change', this._importHandler);
                this._importHandler = (e) => {
                    const file = e.target.files?.[0];
                    if (file && this.playlistManager) {
                        this.playlistManager.importPlaylist(file);
                    }
                    e.target.value = ''; // Reset input
                };
                importInput.addEventListener('change', this._importHandler);
            }
            
            // Playlist export button
            const exportBtn = document.getElementById('playlistExportBtn');
            if (exportBtn) {
                // Remove any existing listeners to prevent duplicates
                const newExportBtn = exportBtn.cloneNode(true);
                exportBtn.parentNode.replaceChild(newExportBtn, exportBtn);
                
                newExportBtn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    console.log('Playlist export button clicked');
                    if (this.playlistManager) {
                        this.playlistManager.exportPlaylist();
                    }
                });
            }
            
            // Playlist sort button
            const sortBtn = document.getElementById('playlistSortBtn');
            if (sortBtn) {
                // Remove any existing listeners to prevent duplicates
                const newSortBtn = sortBtn.cloneNode(true);
                sortBtn.parentNode.replaceChild(newSortBtn, sortBtn);
                
                newSortBtn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    console.log('Playlist sort button clicked');
                    if (this.playlistManager) {
                        this.playlistManager.resetToAlphabetical();
                    }
                });
            }
            
            // Progress cancel button
            const cancelBtn = document.getElementById('progressCancelBtn');
            if (cancelBtn) {
                cancelBtn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    console.log('Progress cancel button clicked');
                    if (this.playlistManager) {
                        this.playlistManager.cancelScan();
                    }
                });
            }
            
            // AI Autopilot button
            const aiAutopilotBtn = document.getElementById('aiAutopilotBtn');
            if (aiAutopilotBtn) {
                // Remove any existing listeners to prevent duplicates
                const newAIBtn = aiAutopilotBtn.cloneNode(true);
                aiAutopilotBtn.parentNode.replaceChild(newAIBtn, aiAutopilotBtn);
                
                newAIBtn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    console.log('AI Autopilot button clicked');
                    if (this.aiAutopilot) {
                        if (this.aiAutopilot.isActive) {
                            this.aiAutopilot.deactivate();
                        } else {
                            this.aiAutopilot.activate();
                        }
                    }
                });
            }
            
            // AI Autopilot settings button
            const aiAutopilotSettingsBtn = document.getElementById('aiAutopilotSettingsBtn');
            if (aiAutopilotSettingsBtn) {
                aiAutopilotSettingsBtn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    console.log('AI Autopilot settings button clicked');
                    const panel = document.getElementById('aiAutopilotSettingsPanel');
                    if (panel) {
                        const isVisible = panel.style.display !== 'none';
                        panel.style.display = isVisible ? 'none' : 'block';
                        console.log('Settings panel', isVisible ? 'closed' : 'opened');
                    } else {
                        console.error('AI Autopilot settings panel not found');
                    }
                });
            }
            
            // AI Autopilot settings panel close button
            const aiSettingsClose = document.getElementById('aiAutopilotSettingsClose');
            if (aiSettingsClose) {
                aiSettingsClose.addEventListener('click', () => {
                    const panel = document.getElementById('aiAutopilotSettingsPanel');
                    if (panel) panel.style.display = 'none';
                });
            }
            
            // Scope buttons
            document.querySelectorAll('.scope-btn').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    const scope = e.target.dataset.scope;
                    if (this.aiAutopilot) {
                        this.aiAutopilot.scope = scope;
                        console.log(`🎯 Autopilot scope set to: ${scope}`);
                        
                        // Update button states
                        document.querySelectorAll('.scope-btn').forEach(b => b.classList.remove('active'));
                        e.target.classList.add('active');
                        
                        // If scope is specific (radial, energy), immediately switch to that mode
                        if (scope === 'radial' || scope === 'energy') {
                            const targetMode = scope === 'radial' ? 4 : 5;
                            console.log(`🎯 Scope change: Immediately switching to mode ${targetMode} (${scope})`);
                            this.setVisualizationMode(targetMode);
                            
                            // Force a decision engine update to respect the new scope
                            setTimeout(() => {
                                if (this.aiAutopilot && this.aiAutopilot.decisionEngine) {
                                    console.log(`🎯 Scope change: Forcing decision engine update for scope ${scope}`);
                                    this.aiAutopilot.decisionEngine.lastDecision = 0; // Reset decision timer
                                }
                            }, 100);
                        }
                    }
                });
            });
            
            // Auto color schemes toggle
            const autoColorBtn = document.getElementById('autoColorSchemesBtn');
            if (autoColorBtn) {
                autoColorBtn.addEventListener('click', (e) => {
                    if (this.aiAutopilot) {
                        this.aiAutopilot.autoColorSchemes = !this.aiAutopilot.autoColorSchemes;
                        const isOn = this.aiAutopilot.autoColorSchemes;
                        e.target.textContent = `Auto Color Schemes: ${isOn ? 'On' : 'Off'}`;
                        e.target.classList.toggle('active', isOn);
                        console.log(`🎨 Auto color schemes: ${isOn ? 'enabled' : 'disabled'}`);
                    }
                });
            }
            
            // Timing buttons
            document.querySelectorAll('.timing-btn').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    const timing = e.target.dataset.timing;
                    if (this.aiAutopilot) {
                        this.aiAutopilot.changeTiming = timing;
                        console.log(`⏱️ Change timing set to: ${timing}`);
                        
                        // Update button states
                        document.querySelectorAll('.timing-btn').forEach(b => b.classList.remove('active'));
                        e.target.classList.add('active');
                    }
                });
            });
            
            // Sensitivity buttons
            document.querySelectorAll('.sensitivity-btn').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    const sensitivity = e.target.dataset.sensitivity;
                    if (this.aiAutopilot) {
                        this.aiAutopilot.sensitivity = sensitivity;
                        console.log(`🎚️ Sensitivity set to: ${sensitivity}`);
                        
                        // Update button states
                        document.querySelectorAll('.sensitivity-btn').forEach(b => b.classList.remove('active'));
                        e.target.classList.add('active');
                    }
                });
            });
            
            // Genre selection buttons
            document.querySelectorAll('.genre-btn').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    const genre = e.target.dataset.genre;
                    if (this.aiAutopilot) {
                        if (genre === 'auto') {
                            this.aiAutopilot.manualGenre = null;
                            console.log(`🎵 Genre detection set to: Auto`);
                        } else {
                            this.aiAutopilot.manualGenre = genre;
                            this.aiAutopilot.currentGenre = genre;
                            this.aiAutopilot.genreConfidence = 1.0;
                            console.log(`🎵 Manual genre set to: ${genre}`);
                        }
                        
                        // Update button states
                        document.querySelectorAll('.genre-btn').forEach(b => b.classList.remove('active'));
                        e.target.classList.add('active');
                        
                        // Update display
                        this.updateGenreDisplay();
                    }
                });
            });
            
            // Parameter control toggle
            const paramControlBtn = document.getElementById('enableParameterControlBtn');
            if (paramControlBtn) {
                paramControlBtn.addEventListener('click', (e) => {
                    if (this.aiAutopilot) {
                        this.aiAutopilot.parameterControlEnabled = !this.aiAutopilot.parameterControlEnabled;
                        const isOn = this.aiAutopilot.parameterControlEnabled;
                        e.target.textContent = `Parameter Control: ${isOn ? 'On' : 'Off'}`;
                        e.target.classList.toggle('active', isOn);
                        console.log(`🎛️ Parameter control: ${isOn ? 'enabled' : 'disabled'}`);
                    }
                });
            }
            
            // Learning controls
            const enableLearningBtn = document.getElementById('enableLearningBtn');
            if (enableLearningBtn) {
                enableLearningBtn.addEventListener('click', (e) => {
                    if (this.aiAutopilot) {
                        this.aiAutopilot.learningEnabled = !this.aiAutopilot.learningEnabled;
                        const isOn = this.aiAutopilot.learningEnabled;
                        e.target.textContent = `Learning: ${isOn ? 'On' : 'Off'}`;
                        e.target.classList.toggle('active', isOn);
                        console.log(`🧠 Pattern learning: ${isOn ? 'enabled' : 'disabled'}`);
                    }
                });
            }
            
            // Reset learning data
            const resetLearningBtn = document.getElementById('resetLearningBtn');
            if (resetLearningBtn) {
                resetLearningBtn.addEventListener('click', (e) => {
                    if (this.aiAutopilot && confirm('Are you sure you want to reset all learning data? This cannot be undone.')) {
                        this.aiAutopilot.patternLearning.patterns = {};
                        this.aiAutopilot.patternLearning.userBehavior = {};
                        this.aiAutopilot.patternLearning.performanceMetrics = {};
                        this.aiAutopilot.patternLearning.saveLearningData();
                        this.updateLearningAnalytics();
                        console.log('🧠 Learning data reset');
                    }
                });
            }
            
            // User feedback buttons
            const thumbsUpBtn = document.getElementById('thumbsUpBtn');
            if (thumbsUpBtn) {
                thumbsUpBtn.addEventListener('click', (e) => {
                    if (this.aiAutopilot) {
                        const context = {
                            genre: this.aiAutopilot.currentGenre,
                            energy: this.aiAutopilot.audioAnalyzer.getEnergy(),
                            tempo: this.aiAutopilot.audioAnalyzer.getTempo()
                        };
                        this.aiAutopilot.parameterController.recordUserFeedback('positive', context);
                        this.updateFeedbackStats();
                        console.log('👍 User liked current settings');
                    }
                });
            }
            
            const thumbsDownBtn = document.getElementById('thumbsDownBtn');
            if (thumbsDownBtn) {
                thumbsDownBtn.addEventListener('click', (e) => {
                    if (this.aiAutopilot) {
                        const context = {
                            genre: this.aiAutopilot.currentGenre,
                            energy: this.aiAutopilot.audioAnalyzer.getEnergy(),
                            tempo: this.aiAutopilot.audioAnalyzer.getTempo()
                        };
                        this.aiAutopilot.parameterController.recordUserFeedback('negative', context);
                        this.updateFeedbackStats();
                        console.log('👎 User disliked current settings');
                    }
                });
            }
            
            // Adaptive tuning controls
            const enableAdaptiveTuningBtn = document.getElementById('enableAdaptiveTuningBtn');
            if (enableAdaptiveTuningBtn) {
                enableAdaptiveTuningBtn.addEventListener('click', (e) => {
                    if (this.aiAutopilot) {
                        this.aiAutopilot.adaptiveTuningEnabled = !this.aiAutopilot.adaptiveTuningEnabled;
                        const isOn = this.aiAutopilot.adaptiveTuningEnabled;
                        e.target.textContent = `Adaptive Tuning: ${isOn ? 'On' : 'Off'}`;
                        e.target.classList.toggle('active', isOn);
                        console.log(`🎯 Adaptive tuning: ${isOn ? 'enabled' : 'disabled'}`);
                    }
                });
            }
            
            const forceOptimizationBtn = document.getElementById('forceOptimizationBtn');
            if (forceOptimizationBtn) {
                forceOptimizationBtn.addEventListener('click', (e) => {
                    console.log('🎯 Force Optimization button clicked');
                    if (this.aiAutopilot) {
                        console.log('🎯 AI Autopilot exists:', !!this.aiAutopilot);
                        if (this.aiAutopilot.adaptiveTuning) {
                            console.log('🎯 Adaptive Tuning exists:', !!this.aiAutopilot.adaptiveTuning);
                            console.log('🎯 Performance window length:', this.aiAutopilot.adaptiveTuning.performanceWindow.length);
                            
                            // Force optimization regardless of normal conditions
                            this.aiAutopilot.adaptiveTuning.optimizeParameters(true);
                            console.log('🎯 Forced parameter optimization completed');
                        } else {
                            console.error('🎯 Adaptive Tuning not available');
                        }
                    } else {
                        console.error('🎯 AI Autopilot not available');
                    }
                });
            } else {
                console.error('🎯 Force Optimization button not found');
            }
            
            // Predictive behavior controls
            const enablePredictiveBehaviorBtn = document.getElementById('enablePredictiveBehaviorBtn');
            if (enablePredictiveBehaviorBtn) {
                enablePredictiveBehaviorBtn.addEventListener('click', (e) => {
                    if (this.aiAutopilot) {
                        this.aiAutopilot.predictiveBehaviorEnabled = !this.aiAutopilot.predictiveBehaviorEnabled;
                        const isOn = this.aiAutopilot.predictiveBehaviorEnabled;
                        e.target.textContent = `Predictive Behavior: ${isOn ? 'On' : 'Off'}`;
                        e.target.classList.toggle('active', isOn);
                        console.log(`🎯 Predictive behavior: ${isOn ? 'enabled' : 'disabled'}`);
                    }
                });
            }
            
            const testPredictionBtn = document.getElementById('testPredictionBtn');
            if (testPredictionBtn) {
                testPredictionBtn.addEventListener('click', (e) => {
                    if (this.aiAutopilot && this.aiAutopilot.predictiveBehavior) {
                        const audioFeatures = this.aiAutopilot.audioAnalyzer.getCurrentFeatures();
                        const currentParams = this.aiAutopilot.getCurrentParameters();
                        const predictions = this.aiAutopilot.predictiveBehavior.predictOptimalActions(
                            audioFeatures, 
                            this.aiAutopilot.visualizer.currentMode, 
                            currentParams
                        );
                        
                        if (predictions) {
                            console.log('🎯 Test prediction result:', predictions);
                            alert(`Prediction: ${predictions.modeChange?.reason || 'No mode change'}\nConfidence: ${Math.round(predictions.confidence * 100)}%`);
                        } else {
                            console.log('🎯 No prediction available (low confidence)');
                            alert('No prediction available - confidence too low');
                        }
                    }
                });
            }
            
            // Multi-layered intelligence controls
            const enableMultiLayeredIntelligenceBtn = document.getElementById('enableMultiLayeredIntelligenceBtn');
            if (enableMultiLayeredIntelligenceBtn) {
                enableMultiLayeredIntelligenceBtn.addEventListener('click', (e) => {
                    if (this.aiAutopilot) {
                        this.aiAutopilot.multiLayeredIntelligenceEnabled = !this.aiAutopilot.multiLayeredIntelligenceEnabled;
                        const isOn = this.aiAutopilot.multiLayeredIntelligenceEnabled;
                        e.target.textContent = `Multi-layered Intelligence: ${isOn ? 'On' : 'Off'}`;
                        e.target.classList.toggle('active', isOn);
                        console.log(`🧠 Multi-layered intelligence: ${isOn ? 'enabled' : 'disabled'}`);
                    }
                });
            }
            
            const testIntelligenceBtn = document.getElementById('testIntelligenceBtn');
            if (testIntelligenceBtn) {
                testIntelligenceBtn.addEventListener('click', (e) => {
                    if (this.aiAutopilot && this.aiAutopilot.multiLayeredIntelligence) {
                        const audioFeatures = this.aiAutopilot.audioAnalyzer.getCurrentFeatures();
                        const currentParams = this.aiAutopilot.getCurrentParameters();
                        const decision = this.aiAutopilot.multiLayeredIntelligence.makeIntelligentDecision(
                            audioFeatures, 
                            this.aiAutopilot.visualizer.currentMode, 
                            currentParams
                        );
                        
                        if (decision) {
                            console.log('🧠 Test intelligence result:', decision);
                            alert(`Intelligence Decision: ${decision.reason}\nAction: ${decision.action}\nConfidence: ${Math.round(decision.confidence * 100)}%\nSource: ${decision.sourceLayer}`);
                        } else {
                            console.log('🧠 No intelligence decision available');
                            alert('No intelligence decision available');
                        }
                    }
                });
            }
            
            // Learning Analytics Dashboard controls
            const learningAnalyticsBtn = document.getElementById('learningAnalyticsBtn');
            if (learningAnalyticsBtn) {
                learningAnalyticsBtn.addEventListener('click', () => {
                    this.openLearningAnalyticsDashboard();
                });
            }

            const analyticsCloseBtn = document.getElementById('analyticsCloseBtn');
            if (analyticsCloseBtn) {
                analyticsCloseBtn.addEventListener('click', () => {
                    this.closeLearningAnalyticsDashboard();
                });
            }

            const updateFrequencySelect = document.getElementById('updateFrequency');
            if (updateFrequencySelect) {
                updateFrequencySelect.addEventListener('change', (e) => {
                    this.setAnalyticsUpdateFrequency(parseInt(e.target.value));
                });
            }

            const exportLearningDataBtn = document.getElementById('exportLearningDataBtn');
            if (exportLearningDataBtn) {
                exportLearningDataBtn.addEventListener('click', () => {
                    this.exportLearningData();
                });
            }

            const resetLearningDataBtn = document.getElementById('resetLearningDataBtn');
            if (resetLearningDataBtn) {
                resetLearningDataBtn.addEventListener('click', () => {
                    this.resetAllLearningData();
                });
            }

            // Initialize analytics update frequency
            this.analyticsUpdateInterval = 5000; // Default 5 seconds
            this.analyticsUpdateTimer = null;

            // Update learning analytics periodically
            this.startAnalyticsUpdates();
            
            // Video effects toggle
            const videoEffectsBtn = document.getElementById('enableVideoEffectsBtn');
            if (videoEffectsBtn) {
                videoEffectsBtn.addEventListener('click', (e) => {
                    if (this.aiAutopilot) {
                        this.aiAutopilot.videoEffectsEnabled = !this.aiAutopilot.videoEffectsEnabled;
                        const isOn = this.aiAutopilot.videoEffectsEnabled;
                        e.target.textContent = `Video Effects: ${isOn ? 'On' : 'Off'}`;
                        e.target.classList.toggle('active', isOn);
                        console.log(`🎬 Video effects: ${isOn ? 'enabled' : 'disabled'}`);
                    }
                });
            }
            
            
            // Test parameter control button
            const testParamBtn = document.getElementById('testParameterControlBtn');
            if (testParamBtn) {
                testParamBtn.addEventListener('click', (e) => {
                    if (this.aiAutopilot) {
                        this.aiAutopilot.testParameterControl();
                        console.log('🧪 Test parameter control triggered');
                    }
                });
            }
            
            // Test parameters button
            const testParametersBtn = document.getElementById('testParametersBtn');
            if (testParametersBtn) {
                testParametersBtn.addEventListener('click', (e) => {
                    if (this.aiAutopilot && this.aiAutopilot.multiLayeredIntelligence) {
                        console.log('🧪 Testing parameter changes...');
                        
                        // Test dramatic parameter changes
                        const testParams = {
                            linearBoost: 5.0,
                            gradient: 0.9,
                            fillAlpha: 0.8,
                            volume: 3.0,
                            smoothing: 0.2,
                            peakHoldTime: 200
                        };
                        
                        this.aiAutopilot.multiLayeredIntelligence.applyParameterAdjustments(testParams);
                        
                        // Test video effects
                        if (this.aiAutopilot.videoEffectsEnabled) {
                            const testVideoParams = {
                                colorEffects: {
                                    brightness: 1.5,
                                    contrast: 1.3,
                                    saturation: 1.4,
                                    hue: 45
                                }
                            };
                            this.aiAutopilot.multiLayeredIntelligence.applyVideoAdjustments(testVideoParams);
                        }
                        
                        alert('Test parameters applied! Check console for details.');
                    }
                });
            }
        }
        
        updateGenreDisplay() {
            if (this.aiAutopilot) {
                this.aiAutopilot.updateGenreDisplay();
            }
        }
        
        updateLearningAnalytics() {
            if (!this.aiAutopilot || !this.aiAutopilot.patternLearning) return;
            
            const analytics = this.aiAutopilot.patternLearning.getLearningAnalytics();
            
            // Update learning progress display
            const progressDisplay = document.getElementById('learningProgressDisplay');
            if (progressDisplay) {
                const progressPercent = Math.round(analytics.learningProgress * 100);
                progressDisplay.textContent = `Learning: ${progressPercent}%`;
            }
            
            // Update pattern count display
            const patternDisplay = document.getElementById('patternCountDisplay');
            if (patternDisplay) {
                patternDisplay.textContent = `Patterns: ${analytics.patterns.total}`;
            }
            
            // Update success rate display
            const successDisplay = document.getElementById('successRateDisplay');
            if (successDisplay) {
                const successPercent = Math.round(analytics.patterns.avgSuccessRate * 100);
                successDisplay.textContent = `Success Rate: ${successPercent}%`;
            }
        }
        
        updateFeedbackStats() {
            if (!this.aiAutopilot || !this.aiAutopilot.parameterController) return;
            
            const stats = this.aiAutopilot.parameterController.getFeedbackStats();
            
            // Update feedback stats display
            const feedbackDisplay = document.getElementById('feedbackStatsDisplay');
            if (feedbackDisplay) {
                const satisfactionPercent = Math.round(stats.satisfaction * 100);
                feedbackDisplay.textContent = `Satisfaction: ${satisfactionPercent}% (${stats.positive}/${stats.total})`;
            }
        }
        
        updateAdaptiveTuningAnalytics() {
            if (!this.aiAutopilot || !this.aiAutopilot.adaptiveTuning) return;
            
            const analytics = this.aiAutopilot.adaptiveTuning.getOptimizationAnalytics();
            
            // Update performance display
            const performanceDisplay = document.getElementById('performanceDisplay');
            if (performanceDisplay) {
                const performancePercent = Math.round(analytics.currentPerformance * 100);
                performanceDisplay.textContent = `Performance: ${performancePercent}%`;
            }
            
            // Update optimization count display
            const optimizationDisplay = document.getElementById('optimizationCountDisplay');
            if (optimizationDisplay) {
                optimizationDisplay.textContent = `Optimizations: ${analytics.totalOptimizations}`;
            }
            
            // Update performance trend display
            const trendDisplay = document.getElementById('performanceTrendDisplay');
            if (trendDisplay) {
                const trendText = analytics.performanceTrend.charAt(0).toUpperCase() + analytics.performanceTrend.slice(1);
                trendDisplay.textContent = `Trend: ${trendText}`;
            }
        }

        updatePredictiveBehaviorAnalytics() {
            if (!this.aiAutopilot || !this.aiAutopilot.predictiveBehavior) return;
            
            const analytics = this.aiAutopilot.predictiveBehavior.getPredictionAnalytics();
            
            // Update prediction count display
            const predictionCountDisplay = document.getElementById('predictionCountDisplay');
            if (predictionCountDisplay) {
                predictionCountDisplay.textContent = `Predictions: ${analytics.totalPredictions}`;
            }
            
            // Update prediction accuracy display
            const predictionAccuracyDisplay = document.getElementById('predictionAccuracyDisplay');
            if (predictionAccuracyDisplay) {
                predictionAccuracyDisplay.textContent = `Accuracy: ${analytics.accuracy}%`;
            }
            
            // Update prediction confidence display
            const predictionConfidenceDisplay = document.getElementById('predictionConfidenceDisplay');
            if (predictionConfidenceDisplay) {
                predictionConfidenceDisplay.textContent = `Confidence: ${analytics.confidence}%`;
            }
        }

        updateMultiLayeredIntelligenceAnalytics() {
            if (!this.aiAutopilot || !this.aiAutopilot.multiLayeredIntelligence) return;
            
            const analytics = this.aiAutopilot.multiLayeredIntelligence.getIntelligenceAnalytics();
            
            // Update intelligence decisions display
            const intelligenceDecisionsDisplay = document.getElementById('intelligenceDecisionsDisplay');
            if (intelligenceDecisionsDisplay) {
                intelligenceDecisionsDisplay.textContent = `Decisions: ${analytics.totalDecisions}`;
            }
            
            // Update meta-learning display
            const metaLearningDisplay = document.getElementById('metaLearningDisplay');
            if (metaLearningDisplay) {
                metaLearningDisplay.textContent = `Meta-Learning: ${analytics.metaLearningProgress.progress}%`;
            }
            
            // Update layer performance display
            const layerPerformanceDisplay = document.getElementById('layerPerformanceDisplay');
            if (layerPerformanceDisplay) {
                const layerCount = Object.keys(analytics.layerPerformance).length;
                const avgSuccessRate = layerCount > 0 ? 
                    Object.values(analytics.layerPerformance).reduce((sum, layer) => sum + parseFloat(layer.successRate), 0) / layerCount : 0;
                
                let performanceText = 'Balanced';
                if (avgSuccessRate > 80) performanceText = 'Excellent';
                else if (avgSuccessRate > 60) performanceText = 'Good';
                else if (avgSuccessRate > 40) performanceText = 'Fair';
                else if (avgSuccessRate > 0) performanceText = 'Poor';
                
                layerPerformanceDisplay.textContent = `Performance: ${performanceText}`;
            }
        }

        // Learning Analytics Dashboard Methods
        openLearningAnalyticsDashboard() {
            const modal = document.getElementById('learningAnalyticsModal');
            if (modal) {
                modal.style.display = 'flex';
                this.updateDashboardAnalytics();
                this.logActivity('Learning Analytics Dashboard opened');
            }
        }

        closeLearningAnalyticsDashboard() {
            const modal = document.getElementById('learningAnalyticsModal');
            if (modal) {
                modal.style.display = 'none';
                this.logActivity('Learning Analytics Dashboard closed');
            }
        }

        setAnalyticsUpdateFrequency(interval) {
            this.analyticsUpdateInterval = interval;
            this.startAnalyticsUpdates();
            this.logActivity(`Analytics update frequency changed to ${interval/1000} seconds`);
        }

        startAnalyticsUpdates() {
            // Clear existing timer
            if (this.analyticsUpdateTimer) {
                clearInterval(this.analyticsUpdateTimer);
            }

            // Start new timer
            this.analyticsUpdateTimer = setInterval(() => {
                if (this.aiAutopilot) {
                    this.updateLearningAnalytics();
                    this.updateFeedbackStats();
                    this.updateAdaptiveTuningAnalytics();
                    this.updatePredictiveBehaviorAnalytics();
                    this.updateMultiLayeredIntelligenceAnalytics();
                    this.updateDashboardAnalytics();
                }
            }, this.analyticsUpdateInterval);
        }

        updateDashboardAnalytics() {
            if (!this.aiAutopilot) return;

            // Update Learning Progress
            const patternLearning = this.aiAutopilot.patternLearning;
            if (patternLearning) {
                const learningAnalytics = patternLearning.getLearningAnalytics();
                
                const patternCount = document.getElementById('dashboardPatternCount');
                if (patternCount) patternCount.textContent = learningAnalytics.patternCount;

                const successRate = document.getElementById('dashboardSuccessRate');
                if (successRate) successRate.textContent = `${learningAnalytics.successRate}%`;

                const learningProgress = document.getElementById('dashboardLearningProgress');
                if (learningProgress) learningProgress.textContent = `${learningAnalytics.learningProgress}%`;
            }

            // Update User Feedback
            const parameterController = this.aiAutopilot.parameterController;
            if (parameterController) {
                const feedbackStats = parameterController.getFeedbackStats();
                
                const totalFeedback = document.getElementById('dashboardTotalFeedback');
                if (totalFeedback) totalFeedback.textContent = feedbackStats.total;

                const satisfaction = document.getElementById('dashboardSatisfaction');
                if (satisfaction) satisfaction.textContent = `${Math.round(feedbackStats.satisfaction * 100)}%`;

                const positiveFeedback = document.getElementById('dashboardPositiveFeedback');
                if (positiveFeedback) positiveFeedback.textContent = feedbackStats.positive;
            }

            // Update Predictive Behavior
            const predictiveBehavior = this.aiAutopilot.predictiveBehavior;
            if (predictiveBehavior) {
                const predictionAnalytics = predictiveBehavior.getPredictionAnalytics();
                
                const predictions = document.getElementById('dashboardPredictions');
                if (predictions) predictions.textContent = predictionAnalytics.totalPredictions;

                const predictionAccuracy = document.getElementById('dashboardPredictionAccuracy');
                if (predictionAccuracy) predictionAccuracy.textContent = `${predictionAnalytics.accuracy}%`;

                const confidence = document.getElementById('dashboardConfidence');
                if (confidence) confidence.textContent = `${predictionAnalytics.confidence}%`;
            }

            // Update Adaptive Tuning
            const adaptiveTuning = this.aiAutopilot.adaptiveTuning;
            if (adaptiveTuning) {
                const tuningAnalytics = adaptiveTuning.getOptimizationAnalytics();
                
                const optimizations = document.getElementById('dashboardOptimizations');
                if (optimizations) optimizations.textContent = tuningAnalytics.totalOptimizations;

                const performance = document.getElementById('dashboardPerformance');
                if (performance) performance.textContent = `${Math.round(tuningAnalytics.currentPerformance * 100)}%`;

                const trend = document.getElementById('dashboardTrend');
                if (trend) {
                    const trendText = tuningAnalytics.performanceTrend.charAt(0).toUpperCase() + tuningAnalytics.performanceTrend.slice(1);
                    trend.textContent = trendText;
                }
            }
        }

        logActivity(message) {
            const activityLog = document.getElementById('activityLog');
            if (activityLog) {
                const timestamp = new Date().toLocaleTimeString();
                const activityItem = document.createElement('div');
                activityItem.className = 'activity-item';
                activityItem.textContent = `[${timestamp}] ${message}`;
                
                // Add to top of log
                activityLog.insertBefore(activityItem, activityLog.firstChild);
                
                // Keep only last 20 items
                while (activityLog.children.length > 20) {
                    activityLog.removeChild(activityLog.lastChild);
                }
            }
        }

        exportLearningData() {
            if (!this.aiAutopilot) return;

            try {
                const exportData = {
                    timestamp: new Date().toISOString(),
                    patternLearning: this.aiAutopilot.patternLearning ? this.aiAutopilot.patternLearning.getLearningAnalytics() : null,
                    userFeedback: this.aiAutopilot.parameterController ? this.aiAutopilot.parameterController.getFeedbackStats() : null,
                    predictiveBehavior: this.aiAutopilot.predictiveBehavior ? this.aiAutopilot.predictiveBehavior.getPredictionAnalytics() : null,
                    adaptiveTuning: this.aiAutopilot.adaptiveTuning ? this.aiAutopilot.adaptiveTuning.getOptimizationAnalytics() : null
                };

                const dataStr = JSON.stringify(exportData, null, 2);
                const dataBlob = new Blob([dataStr], {type: 'application/json'});
                const url = URL.createObjectURL(dataBlob);
                
                const link = document.createElement('a');
                link.href = url;
                link.download = `learning-data-${new Date().toISOString().split('T')[0]}.json`;
                link.click();
                
                URL.revokeObjectURL(url);
                this.logActivity('Learning data exported successfully');
            } catch (error) {
                console.error('Error exporting learning data:', error);
                this.logActivity('Error exporting learning data');
            }
        }

        resetAllLearningData() {
            if (!this.aiAutopilot) return;

            if (confirm('Are you sure you want to reset all learning data? This action cannot be undone.')) {
                try {
                    // Reset pattern learning
                    if (this.aiAutopilot.patternLearning) {
                        localStorage.removeItem('autopilot_ml_patterns');
                    }

                    // Reset user feedback
                    if (this.aiAutopilot.parameterController) {
                        this.aiAutopilot.parameterController.feedbackHistory = [];
                        this.aiAutopilot.parameterController.userAdjustments = [];
                    }

                    // Reset predictive behavior
                    if (this.aiAutopilot.predictiveBehavior) {
                        localStorage.removeItem('autopilot_predictions');
                    }

                    // Reset adaptive tuning
                    if (this.aiAutopilot.adaptiveTuning) {
                        localStorage.removeItem('autopilot_adaptive_tuning');
                    }

                    // Reload the page to reset everything
                    window.location.reload();
                    this.logActivity('All learning data reset - page reloading');
                } catch (error) {
                    console.error('Error resetting learning data:', error);
                    this.logActivity('Error resetting learning data');
                }
            }
        }

        closePlaylistPanel() {
            const playlistDropdown = document.getElementById('playlistDropdown');
            if (playlistDropdown) {
                // Use the same method as the dropdown system
                playlistDropdown.classList.remove('show');
                
                // Reset any inline styles that might interfere
                playlistDropdown.style.display = '';
                
                // Find the parent dropdown and reset its state
                const parentDropdown = playlistDropdown.closest('.dropdown');
                if (parentDropdown) {
                    const toggle = parentDropdown.querySelector('.dropdown-toggle');
                    if (toggle) {
                        toggle.classList.remove('active');
                    }
                }
                
                console.log('✅ Playlist panel closed properly');
            }
        }

        updatePlaylistFromManager(playlist) {
            if (!playlist || !playlist.tracks) {
                console.warn('Invalid playlist provided to updatePlaylistFromManager');
                return;
            }
            
            // Clear current playing track when loading new playlist (unless preserving state)
            if (!this._preservePlayingState) {
                if (this.audio) {
                    this.audio.pause();
                    this.audio.src = '';
                }
                this.currentTrackIndex = 0;
                this.isPlaying = false;
            }
            
            // Convert PlaylistManager format to visualizer format
            this.playlist = playlist.tracks.map((track, index) => {
                const visualizerTrack = {
                    name: track.title,
                    url: track.url,
                    image: track.artwork,
                    artist: track.artist,
                    album: track.album,
                    duration: track.duration
                };
                
                // Debug URL validity
                if (track.url) {
                    console.log(`Track "${track.title}" has URL: ${track.url.substring(0, 50)}...`);
                } else {
                    console.warn(`Track "${track.title}" has no URL - needs rescan`);
                }
                
                return visualizerTrack;
            });
            
            // Update current track index if needed
            if (this.currentTrackIndex >= this.playlist.length) {
                this.currentTrackIndex = 0;
            }
            
            // If a track is currently playing, find its new index after playlist update
            if (this.audio && this.audio.src) {
                const currentUrl = this.audio.src;
                const newIndex = this.playlist.findIndex(track => track.url === currentUrl);
                if (newIndex >= 0 && newIndex !== this.currentTrackIndex) {
                    console.log(`Updating current track index from ${this.currentTrackIndex} to ${newIndex} after playlist update`);
                    this.currentTrackIndex = newIndex;
                }
            }
            
            // Update UI
            this.updatePlaylistDropdown();
            this.updateTrackInfo();
            
            console.log(`✅ Visualizer playlist updated with ${this.playlist.length} tracks`);
            
            // Debug: Check if any tracks have valid URLs and clear track display if needed
            const playableTracks = this.playlist.filter(t => t.url && t.url.startsWith('blob:'));
            if (playableTracks.length === 0) {
                // Update track title to show no track loaded
                const trackTitle = document.getElementById('trackTitle');
                if (trackTitle) {
                    trackTitle.textContent = 'No track loaded';
                }
            }
            console.log(`Playable tracks: ${playableTracks.length}/${this.playlist.length}`);
        }
        
        playTrackById(trackId) {
            console.log('=== playTrackById called ===');
            console.log('trackId:', trackId);
            console.log('playlistManager exists:', !!this.playlistManager);
            
            if (!this.playlistManager) {
                console.error('PlaylistManager not available');
                return;
            }
            
            const track = this.playlistManager.findTrackById(trackId);
            console.log('Found track:', track ? `${track.title} by ${track.artist}` : 'null');
            
            if (!track) {
                console.error('Track not found for ID:', trackId);
                return;
            }
            
            // Find index in current playlist
            console.log('Current playlist length:', this.playlist?.length || 0);
            console.log('Looking for URL:', track.url);
            
            const index = this.playlist.findIndex(t => t.url === track.url);
            console.log('Found index:', index);
            
            if (index >= 0) {
                console.log(`Playing track at index ${index}: ${track.title}`);
                // Use selectTrack to load the track, then force playback
                this.selectTrack(index).then(() => {
                    console.log('Track selected, starting playback...');
                    this.play(); // Force playback to start
                }).catch(error => {
                    console.error('Error selecting/playing track:', error);
                });
            } else {
                console.error('Track URL not found in visualizer playlist');
                console.log('Available URLs:', this.playlist.map(t => t.url));
            }
        }

        initializeCloseButtonHandler() {
            const closeBtn = document.getElementById('playlistPanelClose');
            const dropdown = document.getElementById('playlistDropdown');
            
            console.log('GitItUpVisualizer: Close button found:', !!closeBtn);
            console.log('GitItUpVisualizer: Dropdown found:', !!dropdown);
            
            if (dropdown) {
                console.log('Dropdown content length:', dropdown.innerHTML.length);
                console.log('Dropdown contains panel-header:', dropdown.innerHTML.includes('panel-header'));
                console.log('Dropdown contains playlistPanelClose:', dropdown.innerHTML.includes('playlistPanelClose'));
            }
            
            if (closeBtn) {
                // Remove any existing listeners
                const newCloseBtn = closeBtn.cloneNode(true);
                closeBtn.parentNode.replaceChild(newCloseBtn, closeBtn);
                
                newCloseBtn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    console.log('Playlist panel close button clicked');
                    this.closePlaylistPanel();
                });
                
                console.log('✅ GitItUpVisualizer: Close button event handler attached');
            } else if (this.closeButtonRetries < 3) {
                // Limit retries to prevent infinite loop
                this.closeButtonRetries = (this.closeButtonRetries || 0) + 1;
                console.warn(`❌ GitItUpVisualizer: Close button not found, retry ${this.closeButtonRetries}/3`);
                
                setTimeout(() => {
                    this.initializeCloseButtonHandler();
                }, 500);
            } else {
                console.error('❌ Close button initialization failed after 3 attempts');
            }
        }

        async startVideoInput(deviceId) {
            try { // Check if we're switching sources
                const isSourceSwitch = this.videoElement && this.videoStream;

                if (isSourceSwitch) { // Store current opacity for smooth transition
                    const currentOpacity = this.videoElement.style.opacity || this.videoOpacity;

                    // Start fade out
                    this.videoElement.style.transition = `opacity 0.5s linear`;
                    this.videoElement.style.opacity = '0';

                    // Wait for fade out to complete
                    await new Promise(resolve => setTimeout(resolve, 500));

                    // Stop the old stream without removing elements
                    if (this.videoStream) {
                        this.videoStream.getTracks().forEach(track => {
                            track.stop();
                            console.log('Stopped video track:', track.label);
                        });
                        this.videoStream = null;
                    }

                    // Clear the video source but keep the element
                    if (this.videoElement) {
                        this.videoElement.srcObject = null;
                    this.videoElement.src = '';
                    }
                    if (this.captureVideoElement) {
                        this.captureVideoElement.srcObject = null;
                    }
                } else { // Normal stop for initial setup
                    this.stopVideoInput(false);
                }

                // Get device info to check if it's a Continuity Camera
                let isContinuityCamera = false;
                if (deviceId && this.availableVideoDevices) {
                    const device = this.availableVideoDevices.find(d => d.deviceId === deviceId);
                    if (device && device.label) {
                        isContinuityCamera = device.label.toLowerCase().includes('iphone') || 
                                           device.label.toLowerCase().includes('ipad') ||
                                           device.label.toLowerCase().includes('continuity');
                    }
                }

                // Determine optimal resolution
                const constraints = {
                    video: {
                        deviceId: deviceId ? {
                            exact: deviceId
                        } : undefined,
                        width: {
                            ideal: isContinuityCamera ? 1920 : 3840,  // Continuity Camera works better at 1080p
                            max: isContinuityCamera ? 1920 : 3840
                        },
                        height: {
                            ideal: isContinuityCamera ? 1080 : 2160,
                            max: isContinuityCamera ? 1080 : 2160
                        },
                        frameRate: {
                            ideal: 30
                        }
                    }
                };

                // Try requested resolution, with appropriate fallbacks
                try {
                    this.videoStream = await navigator.mediaDevices.getUserMedia(constraints);
                } catch (e) {
                    if (!isContinuityCamera) {
                    console.log('4K not available, trying 1080p');
                    constraints.video.width = {
                        ideal: 1920
                    };
                    constraints.video.height = {
                        ideal: 1080
                    };
                        try {
                            this.videoStream = await navigator.mediaDevices.getUserMedia(constraints);
                        } catch (e2) {
                            // Final fallback - let browser choose best resolution
                            console.log('1080p not available, using default resolution');
                            delete constraints.video.width;
                            delete constraints.video.height;
                    this.videoStream = await navigator.mediaDevices.getUserMedia(constraints);
                        }
                    } else {
                        // For Continuity Camera, try lower resolution if 1080p fails
                        console.log('Continuity Camera: trying 720p');
                        constraints.video.width = { ideal: 1280 };
                        constraints.video.height = { ideal: 720 };
                        try {
                            this.videoStream = await navigator.mediaDevices.getUserMedia(constraints);
                        } catch (e2) {
                            // Final fallback for Continuity Camera
                            console.log('Continuity Camera: using default resolution');
                            delete constraints.video.width;
                            delete constraints.video.height;
                            this.videoStream = await navigator.mediaDevices.getUserMedia(constraints);
                        }
                    }
                }

                // Get container reference
                const container = document.getElementById('visualizationContainer');
                const visualizer = document.getElementById('visualizer');

                // Create backdrop with current background color behind video (only if not source switch)
                if (!document.getElementById('videoBackdrop')) {
                    const backdrop = document.createElement('div');
                    backdrop.id = 'videoBackdrop';
                    backdrop.style.cssText = `
                position: absolute;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background: ${
                        this.backgroundColor
                    };
                z-index: 0;
            `;
                    container.insertBefore(backdrop, container.firstChild);
                }

                // Create or reuse DISPLAY video element (with filters)
                if (!this.videoElement) {
                    this.videoElement = document.createElement('video');
                    this.videoElement.id = 'bgVideo';
                    this.videoElement.muted = true;
                    this.videoElement.playsInline = true;
                    this.videoElement.autoplay = true;

                    // Critical: Set proper z-index and positioning
                    this.videoElement.style.cssText = `
                position: absolute;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                object-fit: cover;
                z-index: 1;
                opacity: 0;
                transition: opacity ${
                        this.videoFadeTime
                    }s linear;
                pointer-events: none;
            `;

                    // Insert video after backdrop but before visualizer
                    const backdrop = document.getElementById('videoBackdrop');
                    container.insertBefore(this.videoElement, backdrop.nextSibling);
                }

                if (!this.captureVideoElement) {
                    this.captureVideoElement = document.createElement('video');
                    this.captureVideoElement.id = 'bgVideoCaptureClean';
                    this.captureVideoElement.muted = true;
                    this.captureVideoElement.playsInline = true;
                    this.captureVideoElement.autoplay = true;

                    // Detect actual camera stream properties
                    this.captureVideoElement.onloadedmetadata = () => {
                        this.detectCameraStreamInfo();
                    };
                    this.captureVideoElement.style.cssText = `
        position: absolute;
        top: -9999px;
        left: -9999px;
        width: 1px;
        height: 1px;
        visibility: hidden;
        pointer-events: none;
        filter: none !important; /* Force no filters */
        opacity: 1 !important; /* Force full opacity */
        transform: none !important; /* Force no transform */
    `;
                    document.body.appendChild(this.captureVideoElement);
                }

                // Ensure video is transparent before setting new source
                this.videoElement.style.opacity = '0';

                // Make all relevant elements transparent (only if not already done)
                if (! container.classList.contains('video-active')) {
                    const mainArea = document.querySelector('.main-area');

                    // Add class for CSS rules
                    container.classList.add('video-active');

                    // Force transparent backgrounds
                    container.style.backgroundColor = 'transparent';
                    mainArea.style.backgroundColor = 'transparent';
                    visualizer.style.backgroundColor = 'transparent';

                    // Ensure visualizer has proper positioning
                    visualizer.style.position = 'absolute';
                    visualizer.style.zIndex = '1';

                    // Ensure canvas itself is transparent
                    if (this.audioMotion && this.audioMotion.canvas) {
                        this.audioMotion.canvas.style.background = 'transparent';
                        this.audioMotion.canvas.style.backgroundColor = 'transparent';

                        // Set z-index to ensure canvas is above video layers
                        this.audioMotion.canvas.style.position = 'absolute';
                        this.audioMotion.canvas.style.zIndex = '3';
                    }

                    // Force the AudioMotion background to be transparent
                    if (this.audioMotion) { // Store original background color
                        this.originalBackgroundColor = this.backgroundColor;

                        // Set transparent background in AudioMotion
                        this.audioMotion.backgroundColor = 'transparent';
                        this.audioMotion.showBgColor = false;

                        // Force a redraw
                        if (this.audioMotion.ctx) {
                            this.audioMotion.ctx.clearRect(0, 0, this.audioMotion.canvas.width, this.audioMotion.canvas.height);
                        }
                    }
                }

                // Apply settings TO BOTH VIDEO ELEMENTS
                this.videoElement.srcObject = this.videoStream;
                this.captureVideoElement.srcObject = this.videoStream;

                // Add stream detection to main video element too
                this.videoElement.onloadedmetadata = () => {
                    this.detectCameraStreamInfo();
                };

                // Wait for video to be ready
                await new Promise((resolve, reject) => {
                    let resolved = false;

                    const handleReady = () => {
                        if (! resolved) {
                            resolved = true;
                            this.videoElement.play().then(() => { // Also ensure capture video is playing
                                return this.captureVideoElement.play();
                            }).then(() => { // Apply filters ONLY TO DISPLAY VIDEO
                                this.applyVideoFilters();
                                resolve();
                            }).catch(reject);
                        }
                    };

                    this.videoElement.onloadedmetadata = handleReady;
                    this.videoElement.onerror = reject;

                    // Timeout after 5 seconds
                    setTimeout(() => {
                        if (! resolved) {
                            reject(new Error('Video load timeout'));
                        }
                    }, 5000);
                });

                // Get actual video dimensions
                const settings = this.videoStream.getVideoTracks()[0].getSettings();
                console.log(`Video started: ${
                    settings.width
                }x${
                    settings.height
                } @ ${
                    settings.frameRate
                }fps`);

                this.updateDisplayFilters();

                // Update visualization aspect ratio to match video
                if (this.matchVisualizationAspect) {
                    // Small delay to ensure video dimensions are available
                    setTimeout(() => this.updateVisualizationAspectRatio(), 200);
                }

                // Smooth fade in after video is fully ready
                await new Promise(resolve => setTimeout(resolve, 100));

                // Fade in with proper transition
                this.videoElement.style.transition = `opacity ${
                    isSourceSwitch ? 1 : this.videoFadeTime
                }s linear`;
                this.videoElement.style.opacity = this.videoOpacity.toString();

                // Update UI
                const btn = document.getElementById('videoInputBtn');
                const btnText = btn.querySelector('.video-mode-text');
                const controlsPanel = document.getElementById('videoControlsPanel');

                btn.classList.add('video-active');
                btnText.textContent = 'Camera Active';
                this.videoMode = 'camera';
                this.currentVideoDeviceId = deviceId;
                

                // Video Settings Button (only add if not already present)
                if (!document.getElementById('videoSettingsBtn')) {
                    const settingsBtn = document.createElement('button');
                    settingsBtn.id = 'videoSettingsBtn';
                    settingsBtn.innerHTML = '⚙';
                    settingsBtn.className = 'video-settings-toggle';
                    settingsBtn.title = 'Video Settings';
                    btn.parentNode.appendChild(settingsBtn);
                }

                // Keep device selector visible and update selection
                const deviceSelect = document.getElementById('videoDeviceSelect');
                if (deviceSelect) {
                    deviceSelect.value = deviceId;
                    deviceSelect.style.display = 'block';
                    // Update the list to refresh file name if needed
                    this.updateVideoDeviceList();
                }

                // Add cleanup listener for unexpected stream end
                const videoTrack = this.videoStream.getVideoTracks()[0];
                if (videoTrack) {
                    videoTrack.addEventListener('ended', () => {
                        console.log('Video track ended unexpectedly');
                        this.stopVideoInput();
                    });
                }

            } catch (error) {
                console.error('Failed to start video:', error);

                if (error.name === 'NotAllowedError' || error.name === 'PermissionDeniedError') {
                    this.showError('Camera access denied. Please allow camera access and try again.');
                } else if (error.name === 'NotFoundError' || error.name === 'DevicesNotFoundError') {
                    this.showError('Camera not found or not available');
                } else if (error.name === 'NotReadableError' || error.name === 'TrackStartError') {
                    this.showError('Camera is being used by another application');
                } else if (error.message === 'Video load timeout') {
                    this.showError('Video took too long to load. Please try again.');
                } else {
                    this.showError(`Failed to access camera: ${
                        error.message
                    }`);
                }

                this.stopVideoInput();
            }
        }

        detectCameraStreamInfo() {
            if (!this.videoStream) return;

            // Get video track information
            const videoTracks = this.videoStream.getVideoTracks();
            if (videoTracks.length > 0) {
                const track = videoTracks[0];
                const settings = track.getSettings();
                const capabilities = track.getCapabilities();

                // Store camera info
                let cameraLabel = track.label || 'Unknown Camera';
                let isContinuity = false;
                
                // Check if this is a Continuity Camera
                if (cameraLabel.toLowerCase().includes('iphone') || 
                    cameraLabel.toLowerCase().includes('ipad') ||
                    cameraLabel.toLowerCase().includes('continuity')) {
                    isContinuity = true;
                    // Add indicator if not already present
                    if (!cameraLabel.includes('(Continuity Camera)')) {
                        cameraLabel = `📱 ${cameraLabel} (Continuity Camera)`;
                    }
                }
                
                this.cameraInfo = {
                    label: cameraLabel,
                    resolution: `${settings.width || 'Unknown'}x${settings.height || 'Unknown'}`,
                    frameRate: settings.frameRate || 'Unknown',
                    facingMode: settings.facingMode || 'Unknown',
                    capabilities: capabilities,
                    isContinuity: isContinuity
                };

                // Get actual video element dimensions
                const videoElement = this.captureVideoElement || this.videoElement;
                if (videoElement && videoElement.videoWidth > 0) {
                    this.cameraInfo.actualResolution = `${videoElement.videoWidth}x${videoElement.videoHeight}`;
                }

                console.log('🎥 Camera Stream Info:', this.cameraInfo);

                // Update stats display if it exists
                this.updateCameraStats();
            }
        }

        updateCameraStats() {
            const statsContainer = document.getElementById('cameraStatsContainer');
            if (statsContainer && this.cameraInfo) {
                const streamManager = this.streamManager;
                const captureRes = streamManager ? streamManager.displaySettings.captureResolution : 'Unknown';
                const bitrate = streamManager ? streamManager.displaySettings.captureBitrate : 'Unknown';
                const frameRate = streamManager ? streamManager.displaySettings.captureFrameRate : 'Unknown';

                statsContainer.innerHTML = `
                    <div class="stats-row">
                        <span class="stats-label">Camera:</span>
                        <span class="stats-value">${this.cameraInfo.label}</span>
                    </div>
                    ${this.cameraInfo.isContinuity ? `
                    <div class="stats-row" style="color: var(--accent-color);">
                        <span class="stats-label">Type:</span>
                        <span class="stats-value">Apple Continuity Camera</span>
                    </div>
                    ` : ''}
                    <div class="stats-row">
                        <span class="stats-label">Input Resolution:</span>
                        <span class="stats-value">${this.cameraInfo.actualResolution || this.cameraInfo.resolution}</span>
                    </div>
                    <div class="stats-row">
                        <span class="stats-label">Input Frame Rate:</span>
                        <span class="stats-value">${this.cameraInfo.frameRate} fps</span>
                    </div>
                    <div class="stats-row">
                        <span class="stats-label">Capture Resolution:</span>
                        <span class="stats-value">${captureRes}px</span>
                    </div>
                    <div class="stats-row">
                        <span class="stats-label">Capture Frame Rate:</span>
                        <span class="stats-value">${frameRate} fps</span>
                    </div>
                    <div class="stats-row">
                        <span class="stats-label">Stream Bitrate:</span>
                        <span class="stats-value">${bitrate} Mbps</span>
                    </div>
                `;
            }
        }

        async startVideoFile(file) {
            try {
                // Check if we're switching sources
                const isSourceSwitch = this.videoElement && (this.videoStream || this.videoFile);

                if (isSourceSwitch) {
                    // Store current opacity for smooth transition
                    const currentOpacity = this.videoElement.style.opacity || this.videoOpacity;

                    // Start fade out
                    this.videoElement.style.transition = `opacity 0.5s linear`;
                    this.videoElement.style.opacity = '0';

                    // Wait for fade out to complete
                    await new Promise(resolve => setTimeout(resolve, 500));

                    // Stop the old source without removing elements
                    this.stopVideoInput(false);
                } else {
                    // Normal stop for initial setup
                    this.stopVideoInput(false);
                }

                // Store the file
                this.videoFile = file;

                // Get container reference
                const container = document.getElementById('visualizationContainer');

                // Create backdrop if needed
                if (!document.getElementById('videoBackdrop')) {
                    const backdrop = document.createElement('div');
                    backdrop.id = 'videoBackdrop';
                    backdrop.style.cssText = `
                        position: absolute;
                        top: 0;
                        left: 0;
                        width: 100%;
                        height: 100%;
                        background: ${this.backgroundColor};
                        z-index: 0;
                    `;
                    container.insertBefore(backdrop, container.firstChild);
                }

                // Create or reuse DISPLAY video element
                if (!this.videoElement) {
                    this.videoElement = document.createElement('video');
                    this.videoElement.id = 'bgVideo';
                    this.videoElement.muted = false; // Keep unmuted, control via gain node
                    this.videoElement.playsInline = true;
                    this.videoElement.autoplay = true;
                    this.videoElement.loop = this.videoFileLoop;

                    this.videoElement.style.cssText = `
                        position: absolute;
                        top: 0;
                        left: 0;
                        width: 100%;
                        height: 100%;
                        object-fit: cover;
                        z-index: 1;
                        opacity: 0;
                        transition: opacity ${this.videoFadeTime}s linear;
                        pointer-events: none;
                    `;

                    const backdrop = document.getElementById('videoBackdrop');
                    container.insertBefore(this.videoElement, backdrop.nextSibling);
                } else {
                    // Update settings for existing element
                    this.videoElement.muted = false; // Keep unmuted, control via gain node
                    this.videoElement.loop = this.videoFileLoop;
                }

                // Set video source
                const url = URL.createObjectURL(file);
                this.videoElement.src = url;
                this.videoElement.loop = this.videoFileLoop;
                this.videoElement.muted = false; // Keep unmuted, control via gain node

                // Make containers transparent if not already done (same as camera video)
                if (!container.classList.contains('video-active')) {
                    const mainArea = document.querySelector('.main-area');
                    const visualizer = document.getElementById('visualizer');

                    // Add class for CSS rules
                    container.classList.add('video-active');

                    // Force transparent backgrounds
                    container.style.backgroundColor = 'transparent';
                    mainArea.style.backgroundColor = 'transparent';
                    visualizer.style.backgroundColor = 'transparent';

                    // Ensure visualizer has proper positioning
                    visualizer.style.position = 'absolute';
                    visualizer.style.zIndex = '1';

                    // Ensure canvas itself is transparent
                    if (this.audioMotion && this.audioMotion.canvas) {
                        this.audioMotion.canvas.style.background = 'transparent';
                        this.audioMotion.canvas.style.backgroundColor = 'transparent';

                        // Set z-index to ensure canvas is above video layers
                        this.audioMotion.canvas.style.position = 'absolute';
                        this.audioMotion.canvas.style.zIndex = '3';
                    }

                    // Force the AudioMotion background to be transparent
                    if (this.audioMotion) {
                        this.originalBackgroundColor = this.audioMotion.backgroundColor;

                        // Set transparent background in AudioMotion
                        this.audioMotion.backgroundColor = 'transparent';
                        this.audioMotion.showBgColor = false;

                        // Force a redraw
                        if (this.audioMotion.ctx) {
                            this.audioMotion.ctx.clearRect(0, 0, this.audioMotion.canvas.width, this.audioMotion.canvas.height);
                        }
                    }
                }

                // Wait for metadata and play
                await new Promise((resolve, reject) => {
                    let resolved = false;
                    const timeout = setTimeout(() => {
                        if (!resolved) {
                            resolved = true;
                            reject(new Error('Video load timeout'));
                        }
                    }, 10000);

                    this.videoElement.onloadedmetadata = () => {
                        if (!resolved) {
                            resolved = true;
                            clearTimeout(timeout);
                            this.videoElement.play().then(() => {
                                this.applyVideoFilters();
                                this.detectVideoFileInfo();
                                
                                // Fade in after short delay
                                setTimeout(() => {
                                    if (this.videoElement) {
                                        this.videoElement.style.opacity = this.videoOpacity.toString();
                                    }
                                }, 100);
                                
                                resolve();
                            }).catch(reject);
                        }
                    };

                    this.videoElement.onerror = () => {
                        if (!resolved) {
                            resolved = true;
                            clearTimeout(timeout);
                            reject(new Error('Failed to load video'));
                        }
                    };
                });
                
                // Connect video audio to AudioMotion after video is loaded
                await this.connectVideoAudio();

                // Update visualization aspect ratio to match video
                if (this.matchVisualizationAspect) {
                    // Small delay to ensure video dimensions are available
                    setTimeout(() => this.updateVisualizationAspectRatio(), 200);
                }

                // Update UI
                const btn = document.getElementById('videoInputBtn');
                const btnText = btn.querySelector('.video-mode-text');
                const deviceSelect = document.getElementById('videoDeviceSelect');

                btn.classList.add('video-active');
                btnText.textContent = 'File Active';
                this.videoMode = 'file';
                
                // Hide dropdown and show file info
                deviceSelect.style.display = 'none';
                
                const fileInfo = document.getElementById('videoFileInfo');
                const fileName = document.getElementById('videoFileName');
                if (fileInfo && fileName) {
                    fileInfo.style.display = 'flex';
                    fileName.textContent = file.name;
                }

                // Show controls panel
                const controlsPanel = document.getElementById('videoControlsPanel');
                controlsPanel.style.display = 'block';

                // Add settings button if not exists
                if (!document.getElementById('videoSettingsBtn')) {
                    const settingsBtn = document.createElement('button');
                    settingsBtn.id = 'videoSettingsBtn';
                    settingsBtn.innerHTML = '⚙';
                    settingsBtn.className = 'video-settings-toggle';
                    settingsBtn.title = 'Video Settings';
                    btn.parentNode.appendChild(settingsBtn);
                }

                // If stream manager active, rebuild capture
                if (this.streamManager && this.streamManager.isStreaming) {
                    this.streamManager.reconfigureCapture();
                }

                console.log('Video file started:', file.name);
                
                // Debug video visibility after a short delay
                setTimeout(() => {
                    this.debugVideoVisibility();
                }, 500);

            } catch (error) {
                console.error('Error starting video file:', error);
                this.showError(`Failed to load video: ${error.message}`);
                this.stopVideoInput();
            }
        }
        
        debugVideoVisibility() {
            const videoElement = this.videoElement;
            const container = document.getElementById('visualizationContainer');
            const mainArea = document.querySelector('.main-area');
            const visualizer = document.getElementById('visualizer');
            
            console.log('=== VIDEO DEBUG INFO ===');
            console.log('Video Mode:', this.videoMode);
            console.log('Video Element exists:', !!videoElement);
            
            if (videoElement) {
                const rect = videoElement.getBoundingClientRect();
                const computedStyle = window.getComputedStyle(videoElement);
                
                console.log('Video Element:');
                console.log('  - Position:', computedStyle.position);
                console.log('  - Z-index:', computedStyle.zIndex);
                console.log('  - Opacity:', computedStyle.opacity);
                console.log('  - Display:', computedStyle.display);
                console.log('  - Width:', computedStyle.width);
                console.log('  - Height:', computedStyle.height);
                console.log('  - Filter:', computedStyle.filter);
                console.log('  - BoundingRect:', rect);
                console.log('  - Src:', videoElement.src);
                console.log('  - ReadyState:', videoElement.readyState);
                console.log('  - Paused:', videoElement.paused);
                console.log('  - Current Time:', videoElement.currentTime);
            }
            
            console.log('\nContainer backgrounds:');
            console.log('  - Visualization Container BG:', container.style.backgroundColor);
            console.log('  - Main Area BG:', mainArea.style.backgroundColor);
            console.log('  - Visualizer BG:', visualizer.style.backgroundColor);
            
            console.log('\nAudioMotion Canvas:');
            if (this.audioMotion && this.audioMotion.canvas) {
                const canvasStyle = window.getComputedStyle(this.audioMotion.canvas);
                console.log('  - Z-index:', canvasStyle.zIndex);
                console.log('  - Position:', canvasStyle.position);
                console.log('  - Visibility:', canvasStyle.visibility);
                console.log('  - Display:', canvasStyle.display);
            }
            
            console.log('=== END DEBUG INFO ===');
        }

        detectVideoFileInfo() {
            if (this.videoElement && this.videoMode === 'file') {
                const videoInfo = {
                    name: this.videoFile?.name || 'Unknown',
                    resolution: `${this.videoElement.videoWidth}x${this.videoElement.videoHeight}`,
                    duration: this.videoElement.duration,
                    loop: this.videoFileLoop
                };

                console.log('📹 Video File Info:', videoInfo);

                // Update stats if needed
                this.updateVideoFileStats(videoInfo);
            }
        }

        updateVideoFileStats(videoInfo) {
            const statsContainer = document.getElementById('cameraStatsContainer');
            if (statsContainer && videoInfo) {
                const streamManager = this.streamManager;
                const captureRes = streamManager ? streamManager.displaySettings.captureResolution : 'Unknown';
                const bitrate = streamManager ? streamManager.displaySettings.captureBitrate : 'Unknown';
                const frameRate = streamManager ? streamManager.displaySettings.captureFrameRate : 'Unknown';

                statsContainer.innerHTML = `
                    <div class="stats-row">
                        <span class="stats-label">File:</span>
                        <span class="stats-value" style="overflow: hidden; text-overflow: ellipsis;">${videoInfo.name}</span>
                    </div>
                    <div class="stats-row">
                        <span class="stats-label">Resolution:</span>
                        <span class="stats-value">${videoInfo.resolution}</span>
                    </div>
                    <div class="stats-row">
                        <span class="stats-label">Duration:</span>
                        <span class="stats-value">${Math.round(videoInfo.duration)}s</span>
                    </div>
                    <div class="stats-row">
                        <span class="stats-label">Loop:</span>
                        <span class="stats-value">${videoInfo.loop ? 'On' : 'Off'}</span>
                    </div>
                    <div class="stats-row">
                        <span class="stats-label">Capture Resolution:</span>
                        <span class="stats-value">${captureRes}px</span>
                    </div>
                    <div class="stats-row">
                        <span class="stats-label">Stream Bitrate:</span>
                        <span class="stats-value">${bitrate} Mbps</span>
                    </div>
                `;
            }
        }

        stopVideoInput(updateUI = true, isSourceSwitch = false) { // Clear any existing fade timeout immediately
            if (this.videoFadeTimeout) {
                clearTimeout(this.videoFadeTimeout);
                this.videoFadeTimeout = null;
            }
            
            // Disconnect video audio
            this.disconnectVideoAudio();

            // Restore original aspect ratio when video stops (unless it's just a source switch)
            if (updateUI && this.matchVisualizationAspect) {
                this.restoreOriginalAspectRatio();
            }

            // If this is a source switch, do a quick fade and cleanup
            if (isSourceSwitch) {
                if (this.videoStream) {
                    this.videoStream.getTracks().forEach(track => {
                        track.stop();
                        console.log('Stopped video track:', track.label);
                    });
                    this.videoStream = null;
                }

                // Don't remove the video elements or backdrop during source switch
                // Just clear the sources
                if (this.videoElement) {
                    this.videoElement.srcObject = null;
                }
                if (this.captureVideoElement) {
                    this.captureVideoElement.srcObject = null;
                }

                return; // Exit early for source switch
            }

            // Normal stop behavior (when turning video off completely)
            if (this.videoElement) {
                this.videoElement.style.transition = `opacity ${
                    this.videoFadeTime
                }s linear`;
                this.videoElement.style.opacity = '0';

                this.videoFadeTimeout = setTimeout(() => { // Stop video stream
                    if (this.videoStream) {
                        this.videoStream.getTracks().forEach(track => {
                            track.stop();
                            console.log('Stopped video track:', track.label);
                        });
                        this.videoStream = null;
                    }

                    // Remove display video element
                    if (this.videoElement) {
                        this.videoElement.srcObject = null;
                        if (this.videoElement.parentNode) {
                            this.videoElement.parentNode.removeChild(this.videoElement);
                        }
                        this.videoElement = null;
                    }

                    // Remove capture video element
                    if (this.captureVideoElement) {
                        this.captureVideoElement.srcObject = null;
                        if (this.captureVideoElement.parentNode) {
                            this.captureVideoElement.parentNode.removeChild(this.captureVideoElement);
                        }
                        this.captureVideoElement = null;
                    }


                    // Remove backdrop
                    const backdrop = document.getElementById('videoBackdrop');
                    if (backdrop && backdrop.parentNode) {
                        backdrop.parentNode.removeChild(backdrop);
                    }

                    // Restore backgrounds
                    const container = document.getElementById('visualizationContainer');
                    const mainArea = document.querySelector('.main-area');
                    const visualizer = document.getElementById('visualizer');

                    container.classList.remove('video-active');

                    // Restore original background colors
                    container.style.backgroundColor = this.backgroundColor;
                    mainArea.style.backgroundColor = this.backgroundColor;
                    visualizer.style.backgroundColor = '';

                    // Restore canvas background
                    if (this.audioMotion && this.audioMotion.canvas) {
                        this.audioMotion.canvas.style.background = '';
                        this.audioMotion.canvas.style.backgroundColor = '';
                    }

                    // Restore AudioMotion background color
                    if (this.audioMotion) {
                        this.audioMotion.backgroundColor = this.originalBackgroundColor || this.backgroundColor;
                        this.audioMotion.setBackgroundColor(this.backgroundColor);
                        this.audioMotion.showBgColor = true;
                    }

                }, this.videoFadeTime * 1000);
            } else { // No video element, just cleanup capture element if it exists
                if (this.captureVideoElement) {
                    this.captureVideoElement.srcObject = null;
                    if (this.captureVideoElement.parentNode) {
                        this.captureVideoElement.parentNode.removeChild(this.captureVideoElement);
                    }
                    this.captureVideoElement = null;
                }


                const backdrop = document.getElementById('videoBackdrop');
                if (backdrop && backdrop.parentNode) {
                    backdrop.parentNode.removeChild(backdrop);
                }

                const container = document.getElementById('visualizationContainer');
                const mainArea = document.querySelector('.main-area');

                if (container) {
                    container.classList.remove('video-active');
                    container.style.backgroundColor = this.backgroundColor;
                }
                if (mainArea) {
                    mainArea.style.backgroundColor = this.backgroundColor;
                }

                if (this.audioMotion) {
                    this.audioMotion.setBackgroundColor(this.backgroundColor);
                }
            }

            if (updateUI) {
                const btn = document.getElementById('videoInputBtn');
                const btnText = btn.querySelector('.video-mode-text');
                const deviceSelect = document.getElementById('videoDeviceSelect');
                const controlsPanel = document.getElementById('videoControlsPanel');

                if (btn) {
                    btn.classList.remove('video-active');
                }
                if (btnText) {
                    btnText.textContent = 'Video Input';
                }
                if (deviceSelect) {
                    deviceSelect.style.display = 'none';
                    deviceSelect.value = '';
                }
                
                // Hide file info
                const fileInfo = document.getElementById('videoFileInfo');
                if (fileInfo) {
                    fileInfo.style.display = 'none';
                }
                
                if (controlsPanel) {
                    controlsPanel.style.display = 'none';
                }

                this.videoMode = 'off';
                
                this.currentVideoDeviceId = null;
                this.videoFile = null;
            }

            const settingsBtn = document.getElementById('videoSettingsBtn');
            if (settingsBtn) 
                settingsBtn.remove();
            

        }

        updateDisplayFilters() {
            if (this.streamManager && this.streamManager.isStreaming) {
                this.streamManager.sendVideoFilters();
            }
        }

        applyDisplayPreset(preset) {
            const presets = {
                cinema: {
                    presentationMode: 'fit',
                    aspectRatio: '21:9',
                    captureResolution: 2560,
                    captureFrameRate: 24,
                    captureBitrate: 30,
                    displaySharpness: 20,
                    letterboxColor: '#000000',
                    mirrorBackground: false
                },
                presentation: {
                    presentationMode: 'fit',
                    aspectRatio: '16:9',
                    captureResolution: 2560,
                    captureFrameRate: 30,
                    captureBitrate: 30,
                    displaySharpness: 30,
                    letterboxColor: '#1a1a1a',
                    mirrorBackground: false
                },
                social: {
                    presentationMode: 'fit',
                    aspectRatio: '1:1',
                    captureResolution: 2560,
                    captureFrameRate: 30,
                    captureBitrate: 30,
                    displaySharpness: 0,
                    letterboxColor: '#ffffff',
                    mirrorBackground: false
                },
                performance: {
                    presentationMode: 'fit',
                    aspectRatio: 'auto',
                    captureResolution: 2560,
                    captureFrameRate: 60,
                    captureBitrate: 30,
                    displaySharpness: 0,
                    letterboxColor: '#000000',
                    mirrorBackground: false
                },
                projector: {
                    presentationMode: 'fit',
                    aspectRatio: '4:3',
                    captureResolution: 2560,
                    captureFrameRate: 60,
                    captureBitrate: 30,
                    displaySharpness: 50,
                    letterboxColor: '#000000',
                    mirrorBackground: true,
                    mirrorBackgroundBlur: 30
                }
            };

            const settings = presets[preset];
            if (settings && this.streamManager) {
                this.streamManager.updateDisplaySettings(settings);
                this.updateDisplaySettingsUI(settings);
            }
        }

        updateDisplaySettingsUI(settings) { // Update presentation mode buttons
            document.querySelectorAll('.display-mode-btn').forEach(btn => {
                btn.classList.toggle('active', btn.dataset.mode === settings.presentationMode);
            });

            // Update aspect ratio buttons if they exist
            document.querySelectorAll('.aspect-ratio-btn').forEach(btn => {
                btn.classList.toggle('active', btn.dataset.ratio === settings.aspectRatio);
            });

            // Update capture resolution
            const captureResolution = document.getElementById('captureResolution');
            if (captureResolution && settings.captureResolution !== undefined) {
                captureResolution.value = settings.captureResolution;
            }

            // Update capture frame rate
            const captureFrameRate = document.getElementById('captureFrameRate');
            if (captureFrameRate && settings.captureFrameRate !== undefined) {
                captureFrameRate.value = settings.captureFrameRate;
            }

            // Update capture bitrate
            const captureBitrate = document.getElementById('captureBitrate');
            if (captureBitrate && settings.captureBitrate !== undefined) {
                captureBitrate.value = settings.captureBitrate;
                const bitrateValue = document.getElementById('captureBitrateValue');
                if (bitrateValue) {
                    bitrateValue.textContent = `${
                        settings.captureBitrate
                    } Mbps`;
                }
            }

            // Update display sharpness
            const displaySharpness = document.getElementById('displaySharpness');
            if (displaySharpness && settings.displaySharpness !== undefined) {
                displaySharpness.value = settings.displaySharpness;
                const sharpnessValue = document.getElementById('displaySharpnessValue');
                if (sharpnessValue) {
                    sharpnessValue.textContent = `${
                        settings.displaySharpness
                    }%`;
                }
            }

            // Update letterbox color
            const letterboxColor = document.getElementById('letterboxColor');
            if (letterboxColor && settings.letterboxColor !== undefined) {
                letterboxColor.value = settings.letterboxColor;
                const colorValue = document.getElementById('letterboxColorValue');
                if (colorValue) {
                    colorValue.textContent = settings.letterboxColor;
                }
            }

            // Update mirror background
            if (settings.mirrorBackground !== undefined) {
                const mirrorBtn = document.getElementById('mirrorBackgroundBtn');
                if (mirrorBtn) {
                    mirrorBtn.classList.toggle('active', settings.mirrorBackground);
                    mirrorBtn.textContent = `Mirror Background: ${
                        settings.mirrorBackground ? 'On' : 'Off'
                    }`;
                }

                // Show/hide mirror blur container
                const mirrorBlurContainer = document.getElementById('mirrorBlurContainer');
                if (mirrorBlurContainer) {
                    mirrorBlurContainer.style.display = settings.mirrorBackground ? 'flex' : 'none';
                }

                // Update mirror background blur
                if (settings.mirrorBackgroundBlur !== undefined) {
                    const mirrorBlur = document.getElementById('mirrorBackgroundBlur');
                    if (mirrorBlur) {
                        mirrorBlur.value = settings.mirrorBackgroundBlur;
                        const blurValue = document.getElementById('mirrorBackgroundBlurValue');
                        if (blurValue) {
                            blurValue.textContent = `${
                                settings.mirrorBackgroundBlur
                            }px`;
                        }
                    }
                }
            }
        }

        applyVideoFilters() {
            if (!this.videoElement) 
                return;
            


            let filters = [];

            // Apply posterize FIRST with much stronger effect
            if (this.videoPosterize < 16) { // Much stronger posterize for visible effect
                const steps = this.videoPosterize;
                const posterizeAmount = (16 - steps) / 16;

                // Use multiple contrast passes for stronger effect
                filters.push(`contrast(${
                    300 + posterizeAmount * 200
                }%)`); // 300-500%
                filters.push(`brightness(${95}%)`);
                filters.push(`saturate(${200}%)`);

                // Add a second contrast pass for extra posterization
                if (steps < 8) {
                    filters.push(`contrast(${150}%)`);
                }
            }

            // Then apply other adjustments
            if (this.videoBrightness !== 100 && this.videoPosterize >= 16) {
                filters.push(`brightness(${
                    this.videoBrightness
                }%)`);
            }
            if (this.videoContrast !== 100 && this.videoPosterize >= 16) {
                filters.push(`contrast(${
                    this.videoContrast
                }%)`);
            }
            if (this.videoSaturation !== 100 && this.videoPosterize >= 16) {
                filters.push(`saturate(${
                    this.videoSaturation
                }%)`);
            }
            if (this.videoHueRotate !== 0) {
                filters.push(`hue-rotate(${
                    this.videoHueRotate
                }deg)`);
            }
            if (this.videoGrayscale > 0) {
                filters.push(`grayscale(${
                    this.videoGrayscale
                }%)`);
            }
            if (this.videoSepia > 0) {
                filters.push(`sepia(${
                    this.videoSepia
                }%)`);
            }
            if (this.videoBlur > 0) {
                filters.push(`blur(${
                    this.videoBlur
                }px)`);
            }
            if (this.videoInvert) {
                filters.push('invert(100%)');
            }

            // Apply combined filters
            this.videoElement.style.filter = filters.length > 0 ? filters.join(' ') : 'none';

            console.log('Applied filters to LIVE VIDEO (videoElement):', this.videoElement.style.filter);

            // Apply vignette overlay
            this.applyVignette();

            // Apply mirror transformations
            this.applyMirror();

            // Apply pulse animation
            this.applyPulse();
            
            // Also update kaleidoscope filters if it's active
            if (this.kaleidoscopeEnabled && this.kaleidoscopeApplyToVideo) {
                this.applyFiltersToKaleidoscopeContext();
            }
        }

        applyVignette() {
            const container = document.getElementById('visualizationContainer');

            if (this.videoVignette > 0) {
                if (!this.vignetteElement) {
                    this.vignetteElement = document.createElement('div');
                    this.vignetteElement.className = 'video-vignette';
                    container.appendChild(this.vignetteElement);
                }

                const intensity = this.videoVignette / 100;
                const size = 100 - this.videoVignette;

                this.vignetteElement.style.background = `
            radial-gradient(
                ellipse at center,
                transparent ${size}%,
                rgba(0, 0, 0, ${intensity}) 100%
            )
        `;
                this.vignetteElement.style.display = 'block';
            } else if (this.vignetteElement) {
                this.vignetteElement.style.display = 'none';
            }
        }

        applyMirror() {
            if (!this.videoElement) 
                return;
            


            // Remove all mirror classes
            this.videoElement.classList.remove('mirror-horizontal', 'mirror-vertical', 'mirror-both');

            // Apply appropriate mirror class
            switch (this.videoMirror) {
                case 'horizontal':
                    this.videoElement.classList.add('mirror-horizontal');
                    break;
                case 'vertical':
                    this.videoElement.classList.add('mirror-vertical');
                    break;
                case 'both':
                    this.videoElement.classList.add('mirror-both');
                    break;
            }
        }

        applyPulse() {
            if (!this.videoElement) 
                return;
            


            if (this.videoPulse) {
                this.videoElement.classList.add('pulse-active');
                this.videoElement.style.setProperty('--pulse-duration', `${
                    this.videoPulseRate
                }s`);
            } else {
                this.videoElement.classList.remove('pulse-active');
            }
        }

        setVideoPulseRate(value) {
            this.videoPulseRate = value;
            if (this.videoPulse) {
                this.applyPulse();
            }
        }

        toggleVideoPulse() {
            this.videoPulse = !this.videoPulse;
            const pulseRateContainer = document.getElementById('videoPulseRateContainer');
            if (pulseRateContainer) {
                pulseRateContainer.style.display = this.videoPulse ? 'flex' : 'none';
            }
            this.applyPulse();
            this.updateDisplayFilters(); // ADD THIS LINE
        }

        // Individual setter methods
        setVideoBrightness(value) {
            this.videoBrightness = value;
            this.applyVideoFilters();
            this.updateDisplayFilters(); // ADD THIS LINE
        }

        setVideoContrast(value) {
            this.videoContrast = value;
            this.applyVideoFilters();
            this.updateDisplayFilters(); // ADD THIS LINE
        }

        setVideoSaturation(value) {
            this.videoSaturation = value;
            this.applyVideoFilters();
            this.updateDisplayFilters(); // ADD THIS LINE
        }

        setVideoHueRotate(value) {
            this.videoHueRotate = value;
            this.applyVideoFilters();
            this.updateDisplayFilters(); // ADD THIS LINE
        }

        setVideoGrayscale(value) {
            this.videoGrayscale = value;
            this.applyVideoFilters();
            this.updateDisplayFilters(); // ADD THIS LINE
        }

        setVideoSepia(value) {
            this.videoSepia = value;
            this.applyVideoFilters();
            this.updateDisplayFilters(); // ADD THIS LINE
        }

        setVideoBlur(value) {
            this.videoBlur = value;
            this.applyVideoFilters();
            this.updateDisplayFilters(); // ADD THIS LINE
        }

        setVideoPosterize(value) {
            this.videoPosterize = value;
            this.applyVideoFilters();
            this.updateDisplayFilters(); // ADD THIS LINE
        }

        setVideoVignette(value) {
            this.videoVignette = value;
            this.applyVideoFilters();
            this.updateDisplayFilters(); // ADD THIS LINE
        }

        toggleVideoInvert() {
            this.videoInvert = !this.videoInvert;
            this.applyVideoFilters();
            this.updateDisplayFilters(); // ADD THIS LINE
        }

        cycleVideoMirror() {
            const modes = ['off', 'horizontal', 'vertical', 'both'];
            const currentIndex = modes.indexOf(this.videoMirror);
            this.videoMirror = modes[(currentIndex + 1) % modes.length];
            this.applyVideoFilters();
            this.updateDisplayFilters(); // ADD THIS LINE
        }


        // Video presets
        applyVideoPreset(preset) {
            switch (preset) {
                case 'normal':
                    this.videoBrightness = 100;
                    this.videoContrast = 100;
                    this.videoSaturation = 100;
                    this.videoHueRotate = 0;
                    this.videoGrayscale = 0;
                    this.videoSepia = 0;
                    this.videoBlur = 0;
                    this.videoVignette = 0;
                    this.videoPosterize = 16;
                    this.videoInvert = false;
                    break;

                case 'dreamy':
                    this.videoBrightness = 110;
                    this.videoContrast = 90;
                    this.videoSaturation = 120;
                    this.videoHueRotate = 0;
                    this.videoGrayscale = 0;
                    this.videoSepia = 10;
                    this.videoBlur = 3;
                    this.videoVignette = 30;
                    this.videoPosterize = 16;
                    this.videoInvert = false;
                    break;

                case 'noir':
                    this.videoBrightness = 90;
                    this.videoContrast = 130;
                    this.videoSaturation = 0;
                    this.videoHueRotate = 0;
                    this.videoGrayscale = 100;
                    this.videoSepia = 0;
                    this.videoBlur = 0;
                    this.videoVignette = 50;
                    this.videoPosterize = 16;
                    this.videoInvert = false;
                    break;

                case 'cyberpunk':
                    this.videoBrightness = 120;
                    this.videoContrast = 150;
                    this.videoSaturation = 150;
                    this.videoHueRotate = 180;
                    this.videoGrayscale = 0;
                    this.videoSepia = 0;
                    this.videoBlur = 1;
                    this.videoVignette = 40;
                    this.videoPosterize = 8;
                    this.videoInvert = false;
                    break;

                case 'vintage':
                    this.videoBrightness = 95;
                    this.videoContrast = 110;
                    this.videoSaturation = 70;
                    this.videoHueRotate = 0;
                    this.videoGrayscale = 0;
                    this.videoSepia = 40;
                    this.videoBlur = 0;
                    this.videoVignette = 60;
                    this.videoPosterize = 16;
                    this.videoInvert = false;
                    break;

                case 'retro-tv':
                    this.videoBrightness = 105;
                    this.videoContrast = 95;
                    this.videoSaturation = 85;
                    this.videoHueRotate = 5;
                    this.videoGrayscale = 10;
                    this.videoSepia = 5;
                    this.videoBlur = 0.5;
                    this.videoVignette = 35;
                    this.videoPosterize = 12;
                    this.videoInvert = false;
                    break;

                case 'underwater':
                    this.videoBrightness = 85;
                    this.videoContrast = 110;
                    this.videoSaturation = 130;
                    this.videoHueRotate = 200; // Blue-green shift
                    this.videoGrayscale = 0;
                    this.videoSepia = 0;
                    this.videoBlur = 2;
                    this.videoVignette = 25;
                    this.videoPosterize = 16;
                    this.videoInvert = false;
                    break;

                case 'infrared':
                    this.videoBrightness = 110;
                    this.videoContrast = 140;
                    this.videoSaturation = 0;
                    this.videoHueRotate = 0;
                    this.videoGrayscale = 100;
                    this.videoSepia = 0;
                    this.videoBlur = 0;
                    this.videoVignette = 20;
                    this.videoPosterize = 16;
                    this.videoInvert = true; // Key for infrared look
                    break;

                case 'acid':
                    this.videoBrightness = 130;
                    this.videoContrast = 170;
                    this.videoSaturation = 200;
                    this.videoHueRotate = 270; // Purple-pink shift
                    this.videoGrayscale = 0;
                    this.videoSepia = 0;
                    this.videoBlur = 0.5;
                    this.videoVignette = 0;
                    this.videoPosterize = 6; // Heavy posterization
                    this.videoInvert = false;
                    break;

                case 'film-negative':
                    this.videoBrightness = 100;
                    this.videoContrast = 100;
                    this.videoSaturation = 100;
                    this.videoHueRotate = 180; // Complement colors
                    this.videoGrayscale = 0;
                    this.videoSepia = 0;
                    this.videoBlur = 0;
                    this.videoVignette = 10;
                    this.videoPosterize = 16;
                    this.videoInvert = true;
                    break;

                case 'thermal':
                    this.videoBrightness = 120;
                    this.videoContrast = 160;
                    this.videoSaturation = 150;
                    this.videoHueRotate = 280; // Red-orange-yellow gradient
                    this.videoGrayscale = 0;
                    this.videoSepia = 20;
                    this.videoBlur = 1;
                    this.videoVignette = 15;
                    this.videoPosterize = 8;
                    this.videoInvert = false;
                    break;

                case 'matrix':
                    this.videoBrightness = 70;
                    this.videoContrast = 150;
                    this.videoSaturation = 100;
                    this.videoHueRotate = 90; // Green tint
                    this.videoGrayscale = 50; // Partial desaturation
                    this.videoSepia = 0;
                    this.videoBlur = 0;
                    this.videoVignette = 70; // Heavy vignette
                    this.videoPosterize = 4; // Heavy posterization
                    this.videoInvert = false;
                    break;

                case 'glitch':
                    this.videoBrightness = 110;
                    this.videoContrast = 130;
                    this.videoSaturation = 120;
                    this.videoHueRotate = Math.random() * 360; // Random hue
                    this.videoGrayscale = 0;
                    this.videoSepia = 0;
                    this.videoBlur = 0;
                    this.videoVignette = 0;
                    this.videoPosterize = 3; // Extreme posterization
                    this.videoInvert = Math.random() > 0.5; // Random invert
                    break;

            }

            // Update all sliders and buttons to reflect new values
            this.updateVideoControlsUI();
            this.applyVideoFilters();
            this.updateDisplayFilters();
        }

        updateVideoControlsUI() { // Update sliders
            const updates = {
                'videoOpacitySlider': [
                    this.videoOpacity * 100,
                    '%'
                ],
                'videoBrightnessSlider': [
                    this.videoBrightness, '%'
                ],
                'videoContrastSlider': [
                    this.videoContrast, '%'
                ],
                'videoSaturationSlider': [
                    this.videoSaturation, '%'
                ],
                'videoHueRotateSlider': [
                    this.videoHueRotate, '°'
                ],
                'videoGrayscaleSlider': [
                    this.videoGrayscale, '%'
                ],
                'videoSepiaSlider': [
                    this.videoSepia, '%'
                ],
                'videoBlurSlider': [
                    this.videoBlur, 'px'
                ],
                'videoVignetteSlider': [
                    this.videoVignette, '%'
                ],
                'videoPosterizeSlider': [
                    this.videoPosterize, ''
                ],
                'videoPulseRateSlider': [this.videoPulseRate, 's']
            };

            for (const [id, [
                    value, unit
                ]
            ] of Object.entries(updates)) {
                const slider = document.getElementById(id);
                const display = document.getElementById(id.replace('Slider', 'Value'));
                if (slider) {
                    slider.value = value;
                    if (display) {
                        if (id === 'videoPosterizeSlider') {
                            display.textContent = value >= 16 ? 'Off' : `${value} levels`;
                        } else {
                            display.textContent = `${
                                Math.round(value)
                            }${unit}`;
                        }
                    }
                }
            }

            // Update toggle buttons
            const invertBtn = document.getElementById('videoInvertBtn');
            if (invertBtn) {
                invertBtn.textContent = `Invert: ${
                    this.videoInvert ? 'On' : 'Off'
                }`;
                invertBtn.classList.toggle('active', this.videoInvert);
            }

            const mirrorBtn = document.getElementById('videoMirrorBtn');
            if (mirrorBtn) {
                const mirrorText = this.videoMirror === 'off' ? 'Off' : this.videoMirror.charAt(0).toUpperCase() + this.videoMirror.slice(1);
                mirrorBtn.textContent = `Mirror: ${mirrorText}`;
                mirrorBtn.classList.toggle('active', this.videoMirror !== 'off');
            }

            const pulseBtn = document.getElementById('videoPulseBtn');
            if (pulseBtn) {
                pulseBtn.textContent = `Pulse: ${
                    this.videoPulse ? 'On' : 'Off'
                }`;
                pulseBtn.classList.toggle('active', this.videoPulse);
            }

            const pulseRateContainer = document.getElementById('videoPulseRateContainer');
            if (pulseRateContainer) {
                pulseRateContainer.style.display = this.videoPulse ? 'flex' : 'none';
            }
        }

        setVideoOpacity(value) {
            this.videoOpacity = value;
            if (this.videoElement) {
                this.videoElement.style.transition = 'opacity 0.2s ease';
                this.videoElement.style.opacity = value.toString();

                setTimeout(() => {
                    this.videoElement.style.transition = `opacity ${
                        this.videoFadeTime
                    }s linear`;
                }, 200);
            }
            this.updateDisplayFilters(); // ADD THIS LINE
        }

        setVideoFadeTime(seconds) {
            this.videoFadeTime = seconds;
            if (this.videoElement) {
                this.videoElement.style.transition = `opacity ${seconds}s linear`;
            }
        }

        async startLiveInput(deviceId) {
            try {
                this.stopLiveInput();

                if (this.audio) {
                    this.audio.pause();
                }

                this.audioStream = await navigator.mediaDevices.getUserMedia({
                    audio: {
                        deviceId: deviceId ? {
                            exact: deviceId
                        } : undefined,
                        echoCancellation: false,
                        noiseSuppression: false,
                        autoGainControl: false,
                        sampleRate: 48000,
                        channelCount: 2
                    }
                });

                if (this.audioMotion && this.audioMotion.audioCtx) {
                    if (this.audioMotion.audioCtx.state === 'suspended') {
                        await this.audioMotion.audioCtx.resume();
                    }

                    this.audioMotion.disconnectInput();

                    this.streamSource = this.audioMotion.audioCtx.createMediaStreamSource(this.audioStream);

                    // Check if we need stereo processing
                    const audioTracks = this.audioStream.getAudioTracks();
                    const settings = audioTracks[0] ?. getSettings();
                    const channelCount = settings ?. channelCount || 1;

                    if (channelCount > 1 && this.audioMotion.splitter) { // Stereo source - use splitter
                        this.streamSource.connect(this.audioMotion.splitter);
                        this.audioMotion.splitter.connect(this.audioMotion.analyser, 0);
                        this.audioMotion.splitter.connect(this.audioMotion.analyserRight, 1);
                    } else { // Mono source or no splitter - direct connection
                        this.streamSource.connect(this.audioMotion.analyser);
                    }

                    this.audioMotion.isConnected = true;
                }

                const btn = document.getElementById('inputModeBtn');
                const btnText = btn.querySelector('.input-mode-text');
                btn.classList.add('live-mode');
                btnText.textContent = 'LIVE INPUT';
                this.inputMode = 'microphone';

                document.getElementById('trackTitle').textContent = 'Live Audio Input';
                document.getElementById('playBtn').disabled = true;
                document.getElementById('nextBtn').disabled = true;
                document.getElementById('prevBtn').disabled = true;

            } catch (e) {
                console.error('Failed to start live input:', e);
                this.showError('Failed to start audio input');
            }
        }

        stopLiveInput() {
            if (this.audioStream) {
                this.audioStream.getTracks().forEach(track => track.stop());
                this.audioStream = null;
            }

            if (this.streamSource) {
                try {
                    this.streamSource.disconnect();
                } catch (e) { // Ignore
                }
                this.streamSource = null;
            }
        }

        resumePlaylist() {
            document.getElementById('playBtn').disabled = false;
            document.getElementById('nextBtn').disabled = false;
            document.getElementById('prevBtn').disabled = false;

            if (this.audio && this.audioMotion) {
                this.audioMotion.connectInput(this.audio);
                this.updateTrackInfo();
            }
        }

        showSystemAudioHelp() {
            const helpText = `
To capture system audio on Mac:

1. Install BlackHole (free): 
   https://existential.audio/blackhole/

2. Open "Audio MIDI Setup" (in Applications/Utilities)

3. Click "+" button → "Create Multi-Output Device"

4. Check both "BlackHole 2ch" and your speakers

5. Set this Multi-Output as system output

6. In GitItUp, select "BlackHole 2ch" as input

This routes system audio to both speakers and visualizer.

Alternative: Loopback ($99) - easier but paid
https://rogueamoeba.com/loopback/
    `;

            alert(helpText);
        }

        // Preset Methods
        exportPresets() {
            try {
                const dataStr = JSON.stringify(this.savedPresets, null, 2);
                const dataBlob = new Blob([dataStr], {type: 'application/json'});
                const url = URL.createObjectURL(dataBlob);
                const link = document.createElement('a');
                link.href = url;
                link.download = `gitup_presets_${
                    Date.now()
                }.json`;
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
                URL.revokeObjectURL(url);
            } catch (e) {
                console.error('Error exporting presets:', e);
                alert('Failed to export presets');
            }
        }

        importPresets(file) {
            const reader = new FileReader();
            reader.onload = (e) => {
                try {
                    const imported = JSON.parse(e.target.result);
                    if (Array.isArray(imported)) {
                        imported.forEach(importedPreset => {
                            const existingIndex = this.savedPresets.findIndex(p => p.name === importedPreset.name);
                            if (existingIndex >= 0) {
                                if (confirm(`Preset "${
                                    importedPreset.name
                                }" already exists. Overwrite?`)) {
                                    this.savedPresets[existingIndex] = importedPreset;
                                }
                            } else {
                                this.savedPresets.push(importedPreset);
                            }
                        });

                        if (this.savedPresets.length > 30) {
                            this.savedPresets = this.savedPresets.slice(-30);
                        }

                        this.savePresets();
                        this.updatePresetSelector();
                        alert(`Successfully imported ${
                            imported.length
                        } preset(s)`);
                    } else {
                        alert('Invalid preset file format');
                    }
                } catch (error) {
                    console.error('Error importing presets:', error);
                    alert('Failed to import presets: Invalid file');
                }
            };
            reader.readAsText(file);
        }

        // METHODS

        applyBrightnessBoost(config) { // Force minimum opacity
            if (config.fillAlpha !== undefined) {
                config.fillAlpha = Math.max(0.8, Math.min(1, config.fillAlpha * 2));
            } else {
                config.fillAlpha = 0.9;
            }

            // Force brighter reflections
            if (config.reflexAlpha !== undefined) {
                config.reflexAlpha = Math.max(0.5, Math.min(1, config.reflexAlpha * 2));
            }

            // Amplitude settings for full screen
            config.linearAmplitude = true;
            config.linearBoost = 5;
            config.maxDecibels = -5;
            config.minDecibels = -60;
            config.volume = 2.5;

            // Bar spacing
            config.barSpace = 0.05;

            // Radial settings - FIX FOR MISSING LINES
            if (config.radial) {
                config.radius = 0.8;
                config.lineWidth = Math.max(5, config.lineWidth || 5); // Force thick lines
                if (config.spinSpeed) {
                    config.spinSpeed = config.spinSpeed * 0.5;
                }
            }

            // Force line width for line modes
            if (config.mode === 10) {
                config.lineWidth = Math.max(3, config.lineWidth || 2);
            }

            return config;
        }

        applyMorphConfig(config) {
            if (!this.audioMotion) 
                return;
            


            // Don't recalculate frequency bands during morph - keep them stable
            const morphConfig = {
                ...config,
                _isMorphing: true, // Add this flag to prevent resets in setOptions
                showScaleX: false,
                fftSize: config.fftSize || 8192,
                fillAlpha: Math.max(0.6, config.fillAlpha || 0.8),
                volume: config.volume || 1,
                linearBoost: config.linearBoost || 1.5,
                maxDecibels: config.maxDecibels || -25,
                minDecibels: config.minDecibels || -85
            };

            // Save current frequency scale to prevent band recalculation
            const currentFreqScale = this.audioMotion.frequencyScale;
            const currentAnsiBands = this.audioMotion.ansiBands;
            const currentSpinAngle = this.audioMotion.spinAngle;

            try {
                this.audioMotion.setOptions(morphConfig);

                // Force preserve critical animation state
                if (this.isMorphing) { // Restore spin angle if it got reset somehow
                    if (this.audioMotion.spinAngle !== currentSpinAngle) {
                        this.audioMotion.spinAngle = currentSpinAngle;
                    }

                    // If frequency scale changed, force it back to prevent wobble
                    if (this.audioMotion.frequencyScale !== currentFreqScale || this.audioMotion.ansiBands !== currentAnsiBands) {
                        this.audioMotion.frequencyScale = currentFreqScale;
                        this.audioMotion.ansiBands = currentAnsiBands;
                    }
                }
            } catch (e) {
                console.error('Error applying morph config:', e);
            }
        }

        setVisualizationMode(modeIndex) {
            console.log(`🎨 setVisualizationMode called: ${this.currentMode} → ${modeIndex}`);
            console.trace('🎨 setVisualizationMode call stack');
            this.currentMode = modeIndex;

            if (this.audioMotion && modeIndex >= 0 && modeIndex < this.visualizationModes.length) {
                const config = {
                    ...this.visualizationModes[modeIndex]
                };
                // DON'T apply brightness boost to standard presets - they're already tuned

                try {
                    console.log('Setting visualization mode', modeIndex, 'with config:', config);
                    this.audioMotion.setOptions(config);
                    console.log('Visualization mode applied successfully');
                } catch (error) {
                    console.warn(`Could not set visualization mode ${modeIndex}:`, error);
                }
            }
        }

        setRandomVisualization() {
            const randomMode = Math.floor(Math.random() * 11);

            const randomConfig = {
                mode: randomMode,
                alphaBars: false,
                ansiBands: randomMode === 1 || randomMode === 2 ? Math.random() > 0.5 : false,
                barSpace: randomMode === 0 ? 0 : Math.random() * 0.05, // No space for mode 0 (fluid)
                bgAlpha: 0.3 + Math.random() * 0.7,
                fillAlpha: 0.8 + Math.random() * 0.2, // Keep high for brightness (0.8-1.0)
                frequencyScale: Math.random() > 0.5 ? 'log' : 'linear',
                gradient: [
                    'classic',
                    'rainbow',
                    'prism',
                    'steelblue',
                    'orangered'
                ][Math.floor(Math.random() * 5)],
                gravity: 1 + Math.random() * 5,
                ledBars: randomMode === 6 ? Math.random() > 0.3 : false,
                linearAmplitude: true, // Always true for better visibility
                linearBoost: 2 + Math.random() * 2, // 2-4 for good brightness
                lineWidth: randomMode === 10 ? 3 + Math.random() * 2 : Math.random() * 5,
                maxDecibels: -20 + Math.random() * 10, // Better range
                minDecibels: -80 + Math.random() * 10,
                maxFreq: 16000 + Math.random() * 6000,
                minFreq: 20 + Math.random() * 30,
                mirror: Math.random() > 0.7 ? (Math.random() > 0.5 ? 1 : -1) : 0,
                outlineBars: Math.random() > 0.7,
                peakFadeTime: 500 + Math.random() * 500,
                peakHoldTime: 300 + Math.random() * 400,
                radial: Math.random() > 0.6,
                radialInvert: Math.random() > 0.5,
                radius: 0.8 + Math.random() * 0.4, // Larger radius (0.8-1.2)
                reflexAlpha: 0.5 + Math.random() * 0.5, // Higher minimum
                reflexRatio: Math.random() * 0.5,
                roundBars: Math.random() > 0.5,
                showBgColor: Math.random() > 0.3,
                showPeaks: Math.random() > 0.3,
                showScaleX: false,
                smoothing: 0.5 + Math.random() * 0.3, // 0.5-0.8 for smoother animation
                spinSpeed: Math.random() > 0.6 ? Math.random() * 2 : 0,
                trueLeds: randomMode === 6 ? Math.random() > 0.5 : false,
                volume: 1.5 + Math.random() * 1, // 1.5-2.5 for better amplitude
                channelLayout: Math.random() > 0.7 ? (Math.random() > 0.5 ? 'dual-vertical' : 'dual-horizontal') : 'single',
                colorMode: 'gradient',
                fadePeaks: false,
                fftSize: 8192,
                loRes: false,
                lumiBars: false,
                maxFPS: 0,
                noteLabels: false,
                overlay: false,
                peakLine: false,
                reflexBright: 1,
                reflexFit: true,
                showFPS: false,
                showScaleY: false,
                splitGradient: false,
                useCanvas: true,
                weightingFilter: ''
            };

            // Special handling for radial mode to ensure visibility
            if (randomConfig.radial) {
                randomConfig.lineWidth = Math.max(3, randomConfig.lineWidth || 3); // Minimum line width
                randomConfig.radius = 0.8 + Math.random() * 0.6; // 0.8-1.4 for better visibility
                randomConfig.fillAlpha = 1; // Full opacity for radial
            }

            document.querySelectorAll('#vizModeDropdown .dropdown-item').forEach(item => {
                item.classList.remove('active');
            });
            document.getElementById('vizModeToggle').textContent = 'Random';

            if (this.audioMotion) {
                console.log('Setting random visualization with config:', randomConfig);
                this.audioMotion.setOptions(randomConfig);

                const preset = {
                    name: 'Last Random',
                    timestamp: Date.now(),
                    config: randomConfig
                };

                const lastRandomIndex = this.savedPresets.findIndex(p => p.name === 'Last Random');
                if (lastRandomIndex >= 0) {
                    this.savedPresets[lastRandomIndex] = preset;
                } else {
                    this.savedPresets.push(preset);
                }

                this.savePresets();
                this.updatePresetSelector();
            }
        }

        // Kaleidoscope
        initKaleidoscope() {
            const container = document.getElementById('visualizationContainer');
            const rect = container.getBoundingClientRect();

            // Create video kaleidoscope canvas if needed
            if (!this.kaleidoscopeVideoCanvas) {
                this.kaleidoscopeVideoCanvas = document.createElement('canvas');
                this.kaleidoscopeVideoCanvas.className = 'kaleidoscope-canvas kaleidoscope-video';
                this.kaleidoscopeVideoCanvas.style.display = 'none';
                this.kaleidoscopeVideoCanvas.style.zIndex = '2'; // Above video but below viz
                container.appendChild(this.kaleidoscopeVideoCanvas);
                this.kaleidoscopeVideoCtx = this.kaleidoscopeVideoCanvas.getContext('2d');
            }

            // Create viz kaleidoscope canvas if needed
            if (!this.kaleidoscopeVizCanvas) {
                this.kaleidoscopeVizCanvas = document.createElement('canvas');
                this.kaleidoscopeVizCanvas.className = 'kaleidoscope-canvas kaleidoscope-viz';
                this.kaleidoscopeVizCanvas.style.display = 'none';
                this.kaleidoscopeVizCanvas.style.zIndex = '3'; // On top
                container.appendChild(this.kaleidoscopeVizCanvas);
                this.kaleidoscopeVizCtx = this.kaleidoscopeVizCanvas.getContext('2d');
            }

            // Set canvas sizes
            this.kaleidoscopeVideoCanvas.width = rect.width;
            this.kaleidoscopeVideoCanvas.height = rect.height;
            this.kaleidoscopeVizCanvas.width = rect.width;
            this.kaleidoscopeVizCanvas.height = rect.height;
        }

        toggleKaleidoscope() {
            const panel = document.getElementById('kaleidoscopePanel');
            const btn = document.getElementById('kaleidoscopeBtn');
            const btnText = btn.querySelector('.kaleidoscope-btn-text');

            // Toggle panel visibility
            if (panel) {
                const isVisible = panel.style.display !== 'none';
                panel.style.display = isVisible ? 'none' : 'block';

                // Update button based on kaleidoscope state (not panel state)
                if (this.kaleidoscopeEnabled) {
                    btnText.textContent = 'Kaleidoscope On';
                    btn.classList.add('active');
                } else {
                    btnText.textContent = 'Kaleidoscope Off';
                    btn.classList.remove('active');
                }
            }
        }
        
        toggleInfiniteZoom() {
            const panel = document.getElementById('infiniteZoomPanel');
            const btn = document.getElementById('infiniteZoomBtn');
            const btnText = btn.querySelector('.kaleidoscope-btn-text');
            
            // Toggle panel visibility
            if (panel) {
                const isVisible = panel.style.display !== 'none';
                panel.style.display = isVisible ? 'none' : 'block';
                
                if (!isVisible) {
                    // Panel is opening - toggle infinite zoom state
                    if (this.infiniteZoom) {
                        if (this.infiniteZoom.isActive) {
                            this.infiniteZoom.stop();
                            btnText.textContent = 'Infinite Zoom Off';
                            btn.classList.remove('active');
                        } else {
                            this.infiniteZoom.initialize();
                            this.infiniteZoom.start();
                            btnText.textContent = 'Infinite Zoom On';
                            btn.classList.add('active');
                        }
                    }
                }
            }
        }

        startKaleidoscopeAnimation() {
            const animate = () => {
                if (!this.kaleidoscopeEnabled) 
                    return;
                


                // Continue animating even if visualization is disabled

                // Update beat reaction
                this.updateKaleidoscopeBeatReaction();

                // Calculate rotation with curve (exponential easing)
                let effectiveSpeed = this.kaleidoscopeSpeed;
                if (effectiveSpeed > 0) { // Apply exponential curve for smoother acceleration
                    effectiveSpeed = Math.pow(effectiveSpeed / 6, 1.5) * 6;
                }

                // Add beat boost if enabled
                if (this.kaleidoscopeTempSpeedBoost) {
                    effectiveSpeed += this.kaleidoscopeTempSpeedBoost;
                }

                // Update base rotation (reduced from 0.01 to 0.006 for 60% speed)
                if (effectiveSpeed > 0) {
                    this.kaleidoscopeRotation += effectiveSpeed * 0.006;
                }

                // Update individual ring rotations
                for (let i = 0; i < this.kaleidoscopeRingRotations.length; i++) {
                    const speedMultiplier = 1 + (i * this.kaleidoscopeRingSpeedMultiplier);
                    this.kaleidoscopeRingRotations[i] += effectiveSpeed * 0.006 * speedMultiplier;
                }

                this.applyKaleidoscopeEffect();
                this.kaleidoscopeAnimationFrame = requestAnimationFrame(animate);
            };
            animate();
        }

        stopKaleidoscopeAnimation() {
            if (this.kaleidoscopeAnimationFrame) {
                cancelAnimationFrame(this.kaleidoscopeAnimationFrame);
                this.kaleidoscopeAnimationFrame = null;
            }

            // Clear kaleidoscope canvases
            if (this.kaleidoscopeVideoCtx) {
                this.kaleidoscopeVideoCtx.clearRect(0, 0, this.kaleidoscopeVideoCanvas.width, this.kaleidoscopeVideoCanvas.height);
            }
            if (this.kaleidoscopeVizCtx) {
                this.kaleidoscopeVizCtx.clearRect(0, 0, this.kaleidoscopeVizCanvas.width, this.kaleidoscopeVizCanvas.height);
            }

            // Hide kaleidoscope canvases
            if (this.kaleidoscopeVideoCanvas) {
                this.kaleidoscopeVideoCanvas.style.display = 'none';
            }
            if (this.kaleidoscopeVizCanvas) {
                this.kaleidoscopeVizCanvas.style.display = 'none';
            }
            
            // Show the original visualization canvas when kaleidoscope is stopped
            if (this.audioMotion && this.audioMotion.canvas) {
                this.audioMotion.canvas.style.visibility = 'visible';
            }

            // Restore video opacity if needed
            if (this.videoElement && this.videoMode === 'camera') {
                this.videoElement.style.opacity = this.videoOpacity.toString();
            }
        }

        updateKaleidoscopeBeatReaction() {
            if (!this.kaleidoscopeBeatReactive || !this.audioMotion || !this.audioMotion.dataArray) 
                return;
            


            let energy = 0;
            const dataArray = this.audioMotion.dataArray;
            const sampleEnd = Math.min(Math.floor(dataArray.length * 0.4), dataArray.length);

            for (let i = 0; i < sampleEnd; i++) {
                energy += dataArray[i];
            }
            energy = energy / sampleEnd / 255;

            // Scale reaction
            const scaleBoost = 1 + (energy * this.kaleidoscopeBeatSensitivity * 2);
            const newScale = Math.min(2, Math.max(0.3, this.kaleidoscopeBaseScale * scaleBoost));
            this.kaleidoscopeScale = newScale;

            // Rotation speed reaction
            if (this.kaleidoscopeBeatRotation) {
                const rotationBoost = energy * this.kaleidoscopeBeatSensitivity * 5;
                this.kaleidoscopeTempSpeedBoost = rotationBoost;
            } else {
                this.kaleidoscopeTempSpeedBoost = 0;
            }

            // Shape change on beat - FIXED VERSION
            if (this.kaleidoscopeBeatShape) { // Initialize cooldown if not exists
                if (this.shapeChangeCooldown === undefined) {
                    this.shapeChangeCooldown = false;
                }

                // Lower threshold and check for beat spike
                const threshold = 0.4 * this.kaleidoscopeBeatSensitivity; // Adjustable with sensitivity

                if (!this.shapeChangeCooldown && energy > threshold) {
                    const shapes = ['triangle', 'petal', 'rectangle'];
                    const currentIndex = shapes.indexOf(this.kaleidoscopeShape);
                    this.kaleidoscopeShape = shapes[(currentIndex + 1) % shapes.length];

                    // Update UI
                    const shapeBtn = document.getElementById('kaleidoscopeShapeBtn');
                    if (shapeBtn) {
                        shapeBtn.textContent = `Shape: ${
                            this.kaleidoscopeShape.charAt(0).toUpperCase() + this.kaleidoscopeShape.slice(1)
                        }`;
                    }

                    // Set cooldown
                    this.shapeChangeCooldown = true;
                    setTimeout(() => {
                        this.shapeChangeCooldown = false;
                    }, 300); // Reduced from 500ms for more responsive changes
                }
            }

            // Update scale slider
            const scaleSlider = document.getElementById('kaleidoscopeScale');
            const scaleValue = document.getElementById('kaleidoscopeScaleValue');
            if (scaleSlider && scaleValue) {
                scaleSlider.value = Math.round(newScale * 100);
                scaleValue.textContent = `${
                    Math.round(newScale * 100)
                }%`;
            }
        }
        applyKaleidoscopePreset(preset) {
            this.kaleidoscopeSegments = preset.segments;
            this.kaleidoscopeRings = preset.rings;
            this.kaleidoscopeShape = preset.shape;
            this.kaleidoscopeScale = preset.scale / 100;
            this.kaleidoscopeSpeed = preset.speed;
            this.kaleidoscopeRingSpacing = preset.ringSpacing / 100;

            // Update UI sliders
            document.getElementById('kaleidoscopeSegments').value = preset.segments;
            document.getElementById('kaleidoscopeSegmentsValue').textContent = preset.segments;
            document.getElementById('kaleidoscopeRings').value = preset.rings;
            document.getElementById('kaleidoscopeRingsValue').textContent = preset.rings;
            document.getElementById('kaleidoscopeSpeed').value = preset.speed;
            document.getElementById('kaleidoscopeSpeedValue').textContent = preset.speed;
            document.getElementById('kaleidoscopeScale').value = preset.scale;
            document.getElementById('kaleidoscopeScaleValue').textContent = `${
                preset.scale
            }%`;
            document.getElementById('kaleidoscopeRingSpacing').value = preset.ringSpacing;
            document.getElementById('kaleidoscopeRingSpacingValue').textContent = `${
                preset.ringSpacing
            }%`;

            const shapeBtn = document.getElementById('kaleidoscopeShapeBtn');
            if (shapeBtn) {
                shapeBtn.textContent = `Shape: ${
                    preset.shape.charAt(0).toUpperCase() + preset.shape.slice(1)
                }`;
            }

            if (this.kaleidoscopeEnabled) {
                this.applyKaleidoscopeEffect();
            }
        }

        applyFiltersToKaleidoscopeContext() {
            if (!this.kaleidoscopeVideoCtx) return;
            
            // Apply the same filters to the kaleidoscope canvas context
            let filters = [];

            // Apply posterize FIRST with much stronger effect (same logic as applyVideoFilters)
            if (this.videoPosterize < 16) {
                const steps = this.videoPosterize;
                const posterizeAmount = (16 - steps) / 16;

                filters.push(`contrast(${300 + posterizeAmount * 200}%)`);
                filters.push(`brightness(${95}%)`);
                filters.push(`saturate(${200}%)`);

                if (steps < 8) {
                    filters.push(`contrast(${150}%)`);
                }
            }

            // Then apply other adjustments
            if (this.videoBrightness !== 100 && this.videoPosterize >= 16) {
                filters.push(`brightness(${this.videoBrightness}%)`);
            }
            if (this.videoContrast !== 100 && this.videoPosterize >= 16) {
                filters.push(`contrast(${this.videoContrast}%)`);
            }
            if (this.videoSaturation !== 100 && this.videoPosterize >= 16) {
                filters.push(`saturate(${this.videoSaturation}%)`);
            }
            if (this.videoHueRotate !== 0) {
                filters.push(`hue-rotate(${this.videoHueRotate}deg)`);
            }
            if (this.videoGrayscale > 0) {
                filters.push(`grayscale(${this.videoGrayscale}%)`);
            }
            if (this.videoSepia > 0) {
                filters.push(`sepia(${this.videoSepia}%)`);
            }
            if (this.videoBlur > 0) {
                filters.push(`blur(${this.videoBlur}px)`);
            }
            if (this.videoInvert) {
                filters.push('invert(100%)');
            }

            // Apply combined filters to the kaleidoscope canvas
            this.kaleidoscopeVideoCanvas.style.filter = filters.length > 0 ? filters.join(' ') : 'none';
            
            // Apply pulse animation if enabled
            if (this.videoPulse) {
                this.kaleidoscopeVideoCanvas.classList.add('pulse-active');
                this.kaleidoscopeVideoCanvas.style.setProperty('--pulse-duration', `${this.videoPulseRate}s`);
            } else {
                this.kaleidoscopeVideoCanvas.classList.remove('pulse-active');
            }
            
            console.log('Applied filters to kaleidoscope canvas:', this.kaleidoscopeVideoCanvas.style.filter);
        }

        applyKaleidoscopeEffect() {
            if (!this.kaleidoscopeVideoCanvas || !this.kaleidoscopeVizCanvas) {
                console.error('Kaleidoscope canvases not initialized');
                return;
            }

            console.log('Applying kaleidoscope effect:', {
                videoMode: this.videoMode,
                applyToVideo: this.kaleidoscopeApplyToVideo,
                applyToViz: this.kaleidoscopeApplyToViz,
                videoElement: !!this.videoElement,
                captureVideoElement: !!this.captureVideoElement,
                videoReady: this.videoElement ?. readyState,
                captureReady: this.captureVideoElement ?. readyState
            });

            let width = this.kaleidoscopeVideoCanvas.width;
            let height = this.kaleidoscopeVideoCanvas.height;

            // Make sure canvases are properly sized
            if (width === 0 || height === 0) {
                const container = document.getElementById('visualizationContainer');
                const rect = container.getBoundingClientRect();
                this.kaleidoscopeVideoCanvas.width = rect.width;
                this.kaleidoscopeVideoCanvas.height = rect.height;
                this.kaleidoscopeVizCanvas.width = rect.width;
                this.kaleidoscopeVizCanvas.height = rect.height;
                width = rect.width;
                height = rect.height;
                console.log('Resized kaleidoscope canvases to:', width, 'x', height);
            }

            // Skip viz kaleidoscope if visualization is disabled
            if (!this.visualizationEnabled) {
                if (this.kaleidoscopeVizCanvas) {
                    this.kaleidoscopeVizCanvas.style.display = 'none';
                }
                // Still process video kaleidoscope if enabled
            }

            const centerX = width * this.kaleidoscopeCenterX;
            const centerY = height * this.kaleidoscopeCenterY;
            const angleStep = (Math.PI * 2) / this.kaleidoscopeSegments;

            // Calculate base radius for 90% viewport fill
            const baseRadius = width * 0.45;
            let shapeRadius;

            switch (this.kaleidoscopeShape) {
                case 'petal': shapeRadius = baseRadius * 1.0;
                    break;
                case 'rectangle': shapeRadius = baseRadius * 1.0;
                    break;
                case 'triangle':
                default: shapeRadius = baseRadius * 1.1;
                    break;
            }

            // Apply kaleidoscope to VIDEO if enabled
            if (this.kaleidoscopeApplyToVideo && (this.videoMode === 'camera' || this.videoMode === 'file')) {
                let videoSource = null;

                if (this.captureVideoElement && this.captureVideoElement.readyState >= 2) {
                    videoSource = this.captureVideoElement;
                    console.log('Using captureVideoElement for kaleidoscope');
                } else if (this.videoElement && this.videoElement.readyState >= 2) {
                    videoSource = this.videoElement;
                    console.log('Using videoElement for kaleidoscope');
                } else {
                    console.warn('No video source ready for kaleidoscope');
                }

                if (videoSource) {
                    this.kaleidoscopeVideoCanvas.style.display = 'block';
                    this.kaleidoscopeVideoCtx.clearRect(0, 0, width, height);

                    console.log('Drawing video kaleidoscope with', this.kaleidoscopeSegments, 'segments');
                    
                    // Apply video filters to kaleidoscope canvas
                    this.applyFiltersToKaleidoscopeContext();
                    
                    // Apply video opacity to kaleidoscope canvas
                    this.kaleidoscopeVideoCanvas.style.opacity = this.videoOpacity.toString();

                    // Draw multiple rings for VIDEO
                    for (let ring = 0; ring < this.kaleidoscopeRings; ring++) {
                        const ringScale = this.kaleidoscopeScale * Math.pow(1 - this.kaleidoscopeRingSpacing, ring);
                        const ringRotationOffset = this.kaleidoscopeRingRotations[ring] || (ring * (Math.PI / this.kaleidoscopeSegments));

                        // Draw video kaleidoscope segments for this ring
                        for (let i = 0; i < this.kaleidoscopeSegments; i++) {
                            this.kaleidoscopeVideoCtx.save();
                            this.kaleidoscopeVideoCtx.translate(centerX, centerY);
                            this.kaleidoscopeVideoCtx.rotate(angleStep * i + this.kaleidoscopeRotation + ringRotationOffset);
                            this.kaleidoscopeVideoCtx.scale(ringScale, ringScale);

                            // Create clipping path based on shape
                            this.kaleidoscopeVideoCtx.beginPath();

                            switch (this.kaleidoscopeShape) {
                                case 'petal':
                                    // Curved petal shape
                                    this.kaleidoscopeVideoCtx.moveTo(0, 0);
                                    const scaleAdjust = Math.max(1, this.kaleidoscopeScale);
                                    const petalAngle = angleStep * (1.2 * scaleAdjust);
                                    const controlRadius = shapeRadius * 0.7;
                                    this.kaleidoscopeVideoCtx.quadraticCurveTo(controlRadius * Math.cos(petalAngle * 0.3), controlRadius * Math.sin(petalAngle * 0.3), shapeRadius * Math.cos(petalAngle * 0.5), shapeRadius * Math.sin(petalAngle * 0.5));
                                    this.kaleidoscopeVideoCtx.quadraticCurveTo(controlRadius * Math.cos(petalAngle * 0.7), controlRadius * Math.sin(petalAngle * 0.7), 0, 0);
                                    break;

                                case 'rectangle':
                                    // Draw rectangle as a path from origin
                                    const rectAngle = angleStep * 0.45;
                                    this.kaleidoscopeVideoCtx.moveTo(0, 0);
                                    this.kaleidoscopeVideoCtx.lineTo(shapeRadius * Math.cos(- rectAngle), shapeRadius * Math.sin(- rectAngle));
                                    this.kaleidoscopeVideoCtx.lineTo(shapeRadius * Math.cos(- rectAngle), shapeRadius * Math.sin(- rectAngle) + shapeRadius * 0.3);
                                    this.kaleidoscopeVideoCtx.lineTo(shapeRadius * Math.cos(rectAngle), shapeRadius * Math.sin(rectAngle) + shapeRadius * 0.3);
                                    this.kaleidoscopeVideoCtx.lineTo(shapeRadius * Math.cos(rectAngle), shapeRadius * Math.sin(rectAngle));
                                    this.kaleidoscopeVideoCtx.lineTo(0, 0);
                                    break;

                                case 'triangle':
                                default:
                                    // Original triangular shape
                                    this.kaleidoscopeVideoCtx.moveTo(0, 0);
                                    this.kaleidoscopeVideoCtx.lineTo(shapeRadius * Math.cos(0), shapeRadius * Math.sin(0));
                                    this.kaleidoscopeVideoCtx.lineTo(shapeRadius * Math.cos(angleStep), shapeRadius * Math.sin(angleStep));
                                    break;
                            }

                            this.kaleidoscopeVideoCtx.closePath();
                            this.kaleidoscopeVideoCtx.clip();

                            // Set opacity based on ring number for better visibility
                            this.kaleidoscopeVideoCtx.globalAlpha = 1 - (ring * 0.15);

                            // Apply mirror transformation if needed
                            if (this.videoMirror === 'horizontal' || this.videoMirror === 'both') {
                                this.kaleidoscopeVideoCtx.scale(-1, 1);
                            }
                            if (this.videoMirror === 'vertical' || this.videoMirror === 'both') {
                                this.kaleidoscopeVideoCtx.scale(1, -1);
                            }

                            // Draw segment
                            if (i % 2 === 0) {
                                this.kaleidoscopeVideoCtx.drawImage(videoSource, - centerX / ringScale, - centerY / ringScale, width / ringScale, height / ringScale);
                            } else {
                                this.kaleidoscopeVideoCtx.scale(1, -1);
                                this.kaleidoscopeVideoCtx.drawImage(videoSource, - centerX / ringScale, - centerY / ringScale, width / ringScale, height / ringScale);
                            }
                            this.kaleidoscopeVideoCtx.restore();
                        }
                    }

                    // Hide original video when kaleidoscope is active
                    if (this.videoElement) {
                        this.videoElement.style.opacity = '0';
                    }

                    console.log('Video kaleidoscope drawn successfully');
                } else {
                    console.warn('Video source not ready for kaleidoscope');
                }
            } else {
                this.kaleidoscopeVideoCanvas.style.display = 'none';
                if (this.videoElement && this.videoMode === 'camera') {
                    this.videoElement.style.opacity = this.videoOpacity.toString();
                }
            }

            // Check if we need to draw kaleidoscope (either AM viz or IZ)
            const shouldDrawKaleidoscope = (this.kaleidoscopeApplyToViz && this.audioMotion && this.audioMotion.canvas && this.visualizationEnabled) ||
                                         (this.kaleidoscopeApplyToInfiniteZoom && this.infiniteZoom && this.infiniteZoom.isActive && this.infiniteZoom.canvas);

            if (shouldDrawKaleidoscope) {
                this.kaleidoscopeVizCanvas.style.display = 'block';
                this.kaleidoscopeVizCtx.clearRect(0, 0, width, height);

                console.log('Drawing viz kaleidoscope');

                // Hide the original visualization canvas when kaleidoscope is active
                if (this.audioMotion && this.audioMotion.canvas) {
                    this.audioMotion.canvas.style.visibility = 'hidden';
                }

                // Draw multiple rings for VISUALIZATION
                for (let ring = 0; ring < this.kaleidoscopeRings; ring++) {
                    const ringScale = this.kaleidoscopeScale * Math.pow(1 - this.kaleidoscopeRingSpacing, ring);
                    const ringRotationOffset = this.kaleidoscopeRingRotations[ring] || (ring * (Math.PI / this.kaleidoscopeSegments));

                    // Draw viz kaleidoscope segments for this ring
                    for (let i = 0; i < this.kaleidoscopeSegments; i++) {
                        this.kaleidoscopeVizCtx.save();
                        this.kaleidoscopeVizCtx.translate(centerX, centerY);
                        this.kaleidoscopeVizCtx.rotate(angleStep * i + this.kaleidoscopeRotation + ringRotationOffset);
                        this.kaleidoscopeVizCtx.scale(ringScale, ringScale);

                        // Create clipping path based on shape
                        this.kaleidoscopeVizCtx.beginPath();

                        switch (this.kaleidoscopeShape) {
                            case 'petal':
                                // Curved petal shape
                                this.kaleidoscopeVizCtx.moveTo(0, 0);
                                const petalAngle = angleStep * 0.8;
                                const controlRadius = shapeRadius * 0.7;
                                this.kaleidoscopeVizCtx.quadraticCurveTo(controlRadius * Math.cos(petalAngle * 0.3), controlRadius * Math.sin(petalAngle * 0.3), shapeRadius * Math.cos(petalAngle * 0.5), shapeRadius * Math.sin(petalAngle * 0.5));
                                this.kaleidoscopeVizCtx.quadraticCurveTo(controlRadius * Math.cos(petalAngle * 0.7), controlRadius * Math.sin(petalAngle * 0.7), 0, 0);
                                break;

                            case 'rectangle':
                                // Draw rectangle as a path from origin
                                const rectAngle = angleStep * 0.45;
                                this.kaleidoscopeVizCtx.moveTo(0, 0);
                                this.kaleidoscopeVizCtx.lineTo(shapeRadius * Math.cos(- rectAngle), shapeRadius * Math.sin(- rectAngle));
                                this.kaleidoscopeVizCtx.lineTo(shapeRadius * Math.cos(- rectAngle), shapeRadius * Math.sin(- rectAngle) + shapeRadius * 0.3);
                                this.kaleidoscopeVizCtx.lineTo(shapeRadius * Math.cos(rectAngle), shapeRadius * Math.sin(rectAngle) + shapeRadius * 0.3);
                                this.kaleidoscopeVizCtx.lineTo(shapeRadius * Math.cos(rectAngle), shapeRadius * Math.sin(rectAngle));
                                this.kaleidoscopeVizCtx.lineTo(0, 0);
                                break;

                            case 'triangle':
                            default:
                                // Original triangular shape
                                this.kaleidoscopeVizCtx.moveTo(0, 0);
                                this.kaleidoscopeVizCtx.lineTo(shapeRadius * Math.cos(0), shapeRadius * Math.sin(0));
                                this.kaleidoscopeVizCtx.lineTo(shapeRadius * Math.cos(angleStep), shapeRadius * Math.sin(angleStep));
                                break;
                        }

                        this.kaleidoscopeVizCtx.closePath();
                        this.kaleidoscopeVizCtx.clip();

                        // Set opacity based on ring number for better visibility
                        this.kaleidoscopeVizCtx.globalAlpha = 1 - (ring * 0.15);

                        // Draw segment - include main visualization and/or infinite zoom
                        if (i % 2 === 0) {
                            // Draw main visualization if enabled and available
                            if (this.kaleidoscopeApplyToViz && this.audioMotion && this.audioMotion.canvas && this.visualizationEnabled) {
                                this.kaleidoscopeVizCtx.drawImage(this.audioMotion.canvas, - centerX / ringScale, - centerY / ringScale, width / ringScale, height / ringScale);
                            }
                            
                            // Draw infinite zoom if active and enabled for kaleidoscope
                            if (this.infiniteZoom && this.infiniteZoom.isActive && this.infiniteZoom.canvas && this.kaleidoscopeApplyToInfiniteZoom) {
                                this.kaleidoscopeVizCtx.drawImage(this.infiniteZoom.canvas, - centerX / ringScale, - centerY / ringScale, width / ringScale, height / ringScale);
                            }
                        } else {
                            this.kaleidoscopeVizCtx.scale(1, -1);
                            // Draw main visualization if enabled and available
                            if (this.kaleidoscopeApplyToViz && this.audioMotion && this.audioMotion.canvas && this.visualizationEnabled) {
                                this.kaleidoscopeVizCtx.drawImage(this.audioMotion.canvas, - centerX / ringScale, - centerY / ringScale, width / ringScale, height / ringScale);
                            }
                            
                            // Draw infinite zoom if active and enabled for kaleidoscope
                            if (this.infiniteZoom && this.infiniteZoom.isActive && this.infiniteZoom.canvas && this.kaleidoscopeApplyToInfiniteZoom) {
                                this.kaleidoscopeVizCtx.drawImage(this.infiniteZoom.canvas, - centerX / ringScale, - centerY / ringScale, width / ringScale, height / ringScale);
                            }
                        }
                        this.kaleidoscopeVizCtx.restore();
                    }
                }

                console.log('Viz kaleidoscope drawn successfully');
            } else {
                this.kaleidoscopeVizCanvas.style.display = 'none';
                // Show the original visualization canvas when kaleidoscope is not active
                if (this.audioMotion && this.audioMotion.canvas) {
                    this.audioMotion.canvas.style.visibility = 'visible';
                }
            }
        }
        setKaleidoscopeSegments(value) {
            this.kaleidoscopeSegments = value;
            if (this.kaleidoscopeEnabled) {
                this.applyKaleidoscopeEffect();
            }
        }

        setKaleidoscopeSpeed(value) {
            this.kaleidoscopeSpeed = value;
        }

        setKaleidoscopeScale(value) {
            this.kaleidoscopeScale = value / 100;
            // Store as base scale when manually adjusted
            if (!this.kaleidoscopeBeatReactive) {
                this.kaleidoscopeBaseScale = this.kaleidoscopeScale;
            }
            if (this.kaleidoscopeEnabled) {
                this.applyKaleidoscopeEffect();
            }
        }

        setKaleidoscopeCenterX(value) {
            this.kaleidoscopeCenterX = value / 100;
            if (this.kaleidoscopeEnabled) {
                this.applyKaleidoscopeEffect();
            }
        }

        setKaleidoscopeCenterY(value) {
            this.kaleidoscopeCenterY = value / 100;
            if (this.kaleidoscopeEnabled) {
                this.applyKaleidoscopeEffect();
            }
        }


        // End Kaleid0scope

        generateNewMorphTarget() { // Start with locked parameters if they exist
            const baseConfig = this.lockedMorphParams || {};

            // Check if we're in radial mode
            const isRadial = baseConfig.radial !== undefined ? baseConfig.radial : Math.random() > 0.6;

            // Use locked spinSpeed if it exists, otherwise keep current
            const spinSpeed = baseConfig.spinSpeed !== undefined ? baseConfig.spinSpeed : (this.morphStartConfig ? this.morphStartConfig.spinSpeed : 0);

            this.morphTargetConfig = {
                // Keep locked parameters unchanged
                mode: baseConfig.mode !== undefined ? baseConfig.mode : Math.floor(Math.random() * 11),
                radial: isRadial,
                mirror: baseConfig.mirror !== undefined ? baseConfig.mirror : (Math.random() > 0.7 ? (Math.random() > 0.5 ? 1 : -1) : 0),
                ledBars: baseConfig.ledBars !== undefined ? baseConfig.ledBars : false,
                ansiBands: baseConfig.ansiBands !== undefined ? baseConfig.ansiBands : Math.random() > 0.7,
                channelLayout: baseConfig.channelLayout || 'single',
                frequencyScale: baseConfig.frequencyScale || this.morphStartConfig.frequencyScale,
                spinSpeed: spinSpeed,
                // Use the preserved spin speed

                // Variable parameters that can change
                barSpace: Math.random() * 0.05,
                fillAlpha: isRadial ? 1 : 0.8 + Math.random() * 0.2,
                smoothing: 0.3 + Math.random() * 0.5,
                gradient: [
                    'classic',
                    'rainbow',
                    'prism',
                    'steelblue',
                    'orangered'
                ][Math.floor(Math.random() * 5)],
                showPeaks: Math.random() > 0.5,
                radius: isRadial ? 0.8 + Math.random() * 0.6 : 0.3 + Math.random() * 0.5,
                reflexRatio: Math.random() * 0.5,
                reflexAlpha: 0.5 + Math.random() * 0.5,
                roundBars: Math.random() > 0.5,
                lineWidth: isRadial ? 4 + Math.random() * 4 : Math.random() * 2,
                bgAlpha: 0.5 + Math.random() * 0.5,

                // Critical parameters for visibility - boost these for radial
                fftSize: 8192,
                maxDecibels: isRadial ? -15 + Math.random() * 5 : -20 + Math.random() * 10,
                minDecibels: isRadial ? -70 + Math.random() * 10 : -80 + Math.random() * 10,
                maxFreq: 16000 + Math.random() * 6000,
                minFreq: 20 + Math.random() * 30,
                linearAmplitude: true,
                linearBoost: isRadial ? 3 + Math.random() * 3 : 2 + Math.random() * 3,
                volume: isRadial ? 2 + Math.random() * 1.5 : 1.5 + Math.random() * 1,

                // Other parameters
                alphaBars: false,
                colorMode: 'gradient',
                fadePeaks: false,
                loRes: false,
                lumiBars: false,
                maxFPS: 0,
                noteLabels: false,
                outlineBars: Math.random() > 0.7,
                overlay: false,
                peakFadeTime: 500 + Math.random() * 500,
                peakHoldTime: 300 + Math.random() * 400,
                peakLine: false,
                reflexBright: 1,
                reflexFit: true,
                showBgColor: true,
                showFPS: false,
                showScaleY: false,
                splitGradient: false,
                trueLeds: baseConfig.mode === 6 ? Math.random() > 0.5 : false,
                useCanvas: true,
                weightingFilter: ''
            };
        }

        // Preset Methods
        loadPresets() {
            try {
                const saved = localStorage.getItem('gitup_presets');
                return saved ? JSON.parse(saved) : [];
            } catch (e) {
                console.error('Error loading presets:', e);
                return [];
            }
        }

        savePresets() {
            try {
                localStorage.setItem('gitup_presets', JSON.stringify(this.savedPresets));
            } catch (e) {
                console.error('Error saving presets:', e);
            }
        }

        saveCurrentAsPreset(name) {
            if (!this.audioMotion) 
                return;
            


            const preset = {
                name: name || `Preset ${
                    this.savedPresets.length + 1
                }`,
                timestamp: Date.now(),
                config: this.getCurrentConfig()
            };

            this.savedPresets.push(preset);
            if (this.savedPresets.length > 20) {
                this.savedPresets.shift();
            }

            this.savePresets();
            this.updatePresetSelector();
        }

        toggleVisualization() {
            this.visualizationEnabled = !this.visualizationEnabled;

            // Update button text
            const btn = document.getElementById('vizToggleBtn');
            if (btn) {
                btn.textContent = this.visualizationEnabled ? 'ON' : 'OFF';
                btn.classList.toggle('active', this.visualizationEnabled);
            }

            if (this.audioMotion) {
                if (this.visualizationEnabled) { // Resume visualization - restart the animation loop
                    this.audioMotion.animate();
                } else { // Stop main visualization but keep animation loop for Infinite Zoom
                    // Don't cancel animation frame - let it continue for Infinite Zoom
                    // The animation loop will handle skipping main visualization when disabled
                    // Clear the canvas only if video is NOT active
                    if (this.audioMotion.ctx && this.audioMotion.canvas) { // Check if video is active
                        const container = document.getElementById('visualizationContainer');
                        const isVideoActive = container && container.classList.contains('video-active');

                        if (! isVideoActive) { // Only clear canvas if no video is playing
                            this.audioMotion.ctx.fillStyle = this.backgroundColor;
                            this.audioMotion.ctx.fillRect(0, 0, this.audioMotion.canvas.width, this.audioMotion.canvas.height);
                        } else { // If video is active, just clear the canvas to transparent
                            this.audioMotion.ctx.clearRect(0, 0, this.audioMotion.canvas.width, this.audioMotion.canvas.height);
                        }
                    }
                    // Hide kaleidoscope viz canvas if active (but NOT video kaleidoscope)
                    if (this.kaleidoscopeVizCanvas) {
                        this.kaleidoscopeVizCanvas.style.display = 'none';
                    }
                }
            }
        }

        getCurrentConfig() {
            if (!this.audioMotion) 
                return {};
            


            const config = {};
            const params = [
                'alphaBars',
                'ansiBands',
                'barSpace',
                'bgAlpha',
                'channelLayout',
                'colorMode',
                'fadePeaks',
                'fftSize',
                'fillAlpha',
                'frequencyScale',
                'gradient',
                'gradientLeft',
                'gradientRight',
                'gravity',
                'ledBars',
                'linearAmplitude',
                'linearBoost',
                'lineWidth',
                'loRes',
                'lumiBars',
                'maxDecibels',
                'maxFPS',
                'maxFreq',
                'minDecibels',
                'minFreq',
                'mirror',
                'mode',
                'noteLabels',
                'outlineBars',
                'overlay',
                'peakFadeTime',
                'peakHoldTime',
                'peakLine',
                'radial',
                'radialInvert',
                'radius',
                'reflexAlpha',
                'reflexBright',
                'reflexFit',
                'reflexRatio',
                'roundBars',
                'showBgColor',
                'showFPS',
                'showPeaks',
                'showScaleY',
                'smoothing',
                'spinSpeed',
                'splitGradient',
                'trueLeds',
                'useCanvas',
                'volume',
                'weightingFilter'
            ];

            params.forEach(param => {
                if (this.audioMotion.hasOwnProperty(param)) {
                    config[param] = this.audioMotion[param];
                }
            });

            // Ensure critical values are never undefined
            config.showScaleX = false;
            config.fftSize = config.fftSize || 8192;
            config.linearAmplitude = config.linearAmplitude !== undefined ? config.linearAmplitude : true;
            config.linearBoost = config.linearBoost || 2;
            config.volume = config.volume || 1.5;

            return config;
        }

        loadPreset(index) {
            if (index < 0 || index >= this.savedPresets.length) 
                return;
            


            const preset = this.savedPresets[index];
            if (preset && preset.config && this.audioMotion) { // Don't apply brightness boost to saved presets
                this.audioMotion.setOptions(preset.config);
                document.querySelectorAll('#vizModeDropdown .dropdown-item').forEach(item => {
                    item.classList.remove('active');
                });
            }
        }

        updatePresetSelector() {
            const selector = document.getElementById('presetSelector');
            const fsSelector = document.getElementById('fsPresetSelect');

            const updateSelector = (sel) => {
                if (!sel) 
                    return;
                

                sel.innerHTML = '<option value="">Load Preset...</option>';
                this.savedPresets.forEach((preset, index) => {
                    const option = document.createElement('option');
                    option.value = index;
                    option.textContent = preset.name;
                    sel.appendChild(option);
                });
            };

            updateSelector(selector);
            if (this.isFullscreen) {
                updateSelector(fsSelector);
            }
        }

        // Background Color Methods
        loadBackgroundColor() {
            try {
                const saved = localStorage.getItem('gitup_bgcolor');
                if (saved) {
                    this.backgroundColor = saved;
                    const picker = document.getElementById('bgColorPicker');
                    if (picker) 
                        picker.value = saved;
                    

                } else {
                    this.backgroundColor = '#000000';
                }
            } catch (e) {
                console.error('Error loading background color:', e);
                this.backgroundColor = '#000000';
            }
        }

        saveBackgroundColor() {
            try {
                localStorage.setItem('gitup_bgcolor', this.backgroundColor);
            } catch (e) {
                console.error('Error saving background color:', e);
            }
        }

        setBackgroundColor(color) {
            this.backgroundColor = color;
            const visualizationContainer = document.getElementById('visualizationContainer');
            const mainArea = document.querySelector('.main-area');

            visualizationContainer.style.backgroundColor = color;
            mainArea.style.backgroundColor = color;

            this.saveBackgroundColor();

            if (this.audioMotion) {
                this.audioMotion.setBackgroundColor(color);
            }
        }


        // UI Methods
        toggleGradientMode(enable) {
            const elements = document.querySelectorAll('.header, .footer, .playlist-container, .playlist-header, .info-button, .info-popup, .loading, .error-message, .viz-btn, .color-btn, .control-btn, .fullscreen-btn, .loop-btn, .transparent-btn, .progress-bar, .progress-fill, .volume-slider, .volume-fill, .playlist-item.active, .dropdown-toggle, .random-viz-btn');

            elements.forEach(el => {
                if (enable) {
                    el.classList.add('gradient-mode');
                } else {
                    el.classList.remove('gradient-mode');
                }
            });
        }

        setColorScheme(scheme) {
            const root = document.documentElement;
            this.currentColorScheme = scheme;

            if (this.audioMotion) {
                this.audioMotion.setColorScheme(scheme);
            }

            const useGradients = (scheme === 'psychedelic' || scheme === 'metal');
            this.toggleGradientMode(useGradients);

            const playlistItems = document.querySelectorAll('.playlist-dropdown-item.active');
            playlistItems.forEach(item => {
                if (scheme === 'luigi') {
                    item.classList.add('luigi-scheme');
                } else {
                    item.classList.remove('luigi-scheme');
                }
            });

            switch (scheme) {
                case 'earthtones': root.style.setProperty('--accent-color', '#D2691E');
                    root.style.setProperty('--primary-bg', '#2F1B14');
                    root.style.setProperty('--secondary-bg', '#4A2C17');
                    root.style.setProperty('--border-color', '#8B4513');
                    root.style.setProperty('--hover-color', '#654321');
                    root.style.setProperty('--text-primary', '#ffffff');
                    root.style.setProperty('--text-secondary', '#ffffff');
                    break;

                case 'luigi': root.style.setProperty('--accent-color', '#0000FF');
                    root.style.setProperty('--primary-bg', '#0a0a0a');
                    root.style.setProperty('--secondary-bg', '#1a0000');
                    root.style.setProperty('--border-color', '#00A000');
                    root.style.setProperty('--hover-color', '#000066');
                    root.style.setProperty('--text-primary', '#ffffff');
                    root.style.setProperty('--text-secondary', '#ffffff');
                    break;

                case 'metal': root.style.setProperty('--accent-color', '#C0C0C0');
                    root.style.setProperty('--primary-bg', '#0a0a0a');
                    root.style.setProperty('--secondary-bg', '#1a1a1a');
                    root.style.setProperty('--border-color', '#606060');
                    root.style.setProperty('--hover-color', '#2a2a2a');
                    root.style.setProperty('--text-primary', '#ffffff');
                    root.style.setProperty('--text-secondary', '#C0C0C0');
                    break;

                case 'psychedelic': root.style.setProperty('--accent-color', '#FF1493');
                    root.style.setProperty('--primary-bg', '#0a0a0a');
                    root.style.setProperty('--secondary-bg', '#1a0a1a');
                    root.style.setProperty('--border-color', '#9400D3');
                    root.style.setProperty('--hover-color', '#2a1a2a');
                    root.style.setProperty('--text-primary', '#ffffff');
                    root.style.setProperty('--text-secondary', '#00CED1');
                    break;

                default: root.style.setProperty('--accent-color', '#2969b0');
                    root.style.setProperty('--primary-bg', '#f5f3e9');
                    root.style.setProperty('--secondary-bg', '#1a1a1a');
                    root.style.setProperty('--border-color', '#898989');
                    root.style.setProperty('--hover-color', '#2a2a2a');
                    root.style.setProperty('--text-primary', '#ffffff');
                    root.style.setProperty('--text-secondary', '#ffffff');
                    break;
            }
        }

        // * new event listeners
        setupEventListeners() { // Dropdown toggles
            const setupDropdown = (toggleId, dropdownId) => {
                const toggle = document.getElementById(toggleId);
                const dropdown = document.getElementById(dropdownId);

                if (! toggle || ! dropdown) 
                    return;
                


                toggle.addEventListener('click', (e) => {
                    e.stopPropagation();
                    document.querySelectorAll('.dropdown-content').forEach(d => {
                        if (d !== dropdown) 
                            d.classList.remove('show');
                        

                    });
                    dropdown.classList.toggle('show');
                });
            };

            setupDropdown('colorSchemeToggle', 'colorSchemeDropdown');
            setupDropdown('vizModeToggle', 'vizModeDropdown');
            setupDropdown('playlistToggle', 'playlistDropdown');

            // Close dropdowns when clicking outside (except playlist dropdown)
            document.addEventListener('click', () => {
                document.querySelectorAll('.dropdown-content').forEach(d => {
                    // Skip playlist dropdown - it has its own close button
                    if (d.id !== 'playlistDropdown') {
                    d.classList.remove('show');
                    }
                });
            });

            // Color scheme dropdown items
            document.querySelectorAll('#colorSchemeDropdown .dropdown-item').forEach(item => {
                item.addEventListener('click', (e) => {
                    e.stopPropagation();
                    document.querySelectorAll('#colorSchemeDropdown .dropdown-item').forEach(i => i.classList.remove('active'));
                    item.classList.add('active');
                    const scheme = item.dataset.scheme;
                    this.setColorScheme(scheme);
                    document.getElementById('colorSchemeToggle').textContent = item.textContent;
                    document.getElementById('colorSchemeDropdown').classList.remove('show');
                });
            });

            // Visualization mode dropdown items
            document.querySelectorAll('#vizModeDropdown .dropdown-item').forEach(item => {
                item.addEventListener('click', (e) => {
                    e.stopPropagation();
                    const mode = item.dataset.mode;
                    if (mode === 'random') {
                        this.setRandomVisualization();
                    } else {
                        document.querySelectorAll('#vizModeDropdown .dropdown-item').forEach(i => i.classList.remove('active'));
                        item.classList.add('active');
                        this.setVisualizationMode(parseInt(mode));
                        document.getElementById('vizModeToggle').textContent = item.textContent;
                    }
                    document.getElementById('vizModeDropdown').classList.remove('show');
                });
            });

            // Visualization toggle button
            const vizToggleBtn = document.getElementById('vizToggleBtn');
            if (vizToggleBtn) {
                vizToggleBtn.addEventListener('click', () => {
                    this.toggleVisualization();
                });
            }

            // Volume icon mute toggle
            const volumeIcon = document.querySelector('.volume-control span');
            if (volumeIcon) {
                volumeIcon.style.cursor = 'pointer'; // Make it look clickable
                volumeIcon.addEventListener('click', () => {
                    this.toggleMute();
                });
            }

            // Close button for video controls panel
            const videoControlsClose = document.getElementById('videoControlsClose');
            if (videoControlsClose) {
                videoControlsClose.addEventListener('click', () => {
                    document.getElementById('videoControlsPanel').style.display = 'none';
                });
            }
            
            // Video settings button (for dynamically created button)
            document.addEventListener('click', (e) => {
                if (e.target && e.target.id === 'videoSettingsBtn') {
                    e.stopPropagation();
                    const panel = document.getElementById('videoControlsPanel');
                    if (panel) {
                        const isVisible = panel.style.display !== 'none';
                        panel.style.display = isVisible ? 'none' : 'block';
                    }
                }
            });
            // Pulse controls
            const videoPulseRateSlider = document.getElementById('videoPulseRateSlider');
            if (videoPulseRateSlider) {
                videoPulseRateSlider.addEventListener('input', (e) => {
                    const value = parseFloat(e.target.value);
                    this.setVideoPulseRate(value);
                    document.getElementById('videoPulseRateValue').textContent = `${
                        value.toFixed(1)
                    }s`;
                });
            }

            // Basic controls
            const videoBrightnessSlider = document.getElementById('videoBrightnessSlider');
            if (videoBrightnessSlider) {
                videoBrightnessSlider.addEventListener('input', (e) => {
                    const value = parseInt(e.target.value);
                    this.setVideoBrightness(value);
                    document.getElementById('videoBrightnessValue').textContent = `${value}%`;
                });
            }

            const videoContrastSlider = document.getElementById('videoContrastSlider');
            if (videoContrastSlider) {
                videoContrastSlider.addEventListener('input', (e) => {
                    const value = parseInt(e.target.value);
                    this.setVideoContrast(value);
                    document.getElementById('videoContrastValue').textContent = `${value}%`;
                });
            }

            // Color controls
            const videoSaturationSlider = document.getElementById('videoSaturationSlider');
            if (videoSaturationSlider) {
                videoSaturationSlider.addEventListener('input', (e) => {
                    const value = parseInt(e.target.value);
                    this.setVideoSaturation(value);
                    document.getElementById('videoSaturationValue').textContent = `${value}%`;
                });
            }

            const videoHueRotateSlider = document.getElementById('videoHueRotateSlider');
            if (videoHueRotateSlider) {
                videoHueRotateSlider.addEventListener('input', (e) => {
                    const value = parseInt(e.target.value);
                    this.setVideoHueRotate(value);
                    document.getElementById('videoHueRotateValue').textContent = `${value}°`;
                });
            }

            const videoGrayscaleSlider = document.getElementById('videoGrayscaleSlider');
            if (videoGrayscaleSlider) {
                videoGrayscaleSlider.addEventListener('input', (e) => {
                    const value = parseInt(e.target.value);
                    this.setVideoGrayscale(value);
                    document.getElementById('videoGrayscaleValue').textContent = `${value}%`;
                });
            }

            const videoSepiaSlider = document.getElementById('videoSepiaSlider');
            if (videoSepiaSlider) {
                videoSepiaSlider.addEventListener('input', (e) => {
                    const value = parseInt(e.target.value);
                    this.setVideoSepia(value);
                    document.getElementById('videoSepiaValue').textContent = `${value}%`;
                });
            }

            // Effects controls
            const videoBlurSlider = document.getElementById('videoBlurSlider');
            if (videoBlurSlider) {
                videoBlurSlider.addEventListener('input', (e) => {
                    const value = parseInt(e.target.value);
                    this.setVideoBlur(value);
                    document.getElementById('videoBlurValue').textContent = `${value}px`;
                });
            }

            const videoVignetteSlider = document.getElementById('videoVignetteSlider');
            if (videoVignetteSlider) {
                videoVignetteSlider.addEventListener('input', (e) => {
                    const value = parseInt(e.target.value);
                    this.setVideoVignette(value);
                    document.getElementById('videoVignetteValue').textContent = `${value}%`;
                });
            }

            const videoPosterizeSlider = document.getElementById('videoPosterizeSlider');
            if (videoPosterizeSlider) {
                videoPosterizeSlider.addEventListener('input', (e) => {
                    const value = parseInt(e.target.value);
                    this.setVideoPosterize(value);
                    const displayText = value >= 16 ? 'Off' : `${value} levels`;
                    document.getElementById('videoPosterizeValue').textContent = displayText;
                });
            }


            // Live Display button
            const liveDisplayBtn = document.getElementById('liveDisplayBtn');
            if (liveDisplayBtn) {
                liveDisplayBtn.addEventListener('click', () => {
                    if (this.streamManager) {
                        this.streamManager.toggleLiveDisplay();
                    }
                });
            }

            // Display Settings Panel Controls
            // Close button
            const displaySettingsClose = document.getElementById('displaySettingsClose');
            if (displaySettingsClose) {
                displaySettingsClose.addEventListener('click', () => {
                    document.getElementById('displaySettingsPanel').style.display = 'none';
                });
            }

            // Display Settings button toggle
            const displaySettingsBtn = document.getElementById('displaySettingsBtn');
            if (displaySettingsBtn) {
                displaySettingsBtn.addEventListener('click', () => {
                    const panel = document.getElementById('displaySettingsPanel');
                    if (panel) {
                        panel.style.display = panel.style.display === 'none' ? 'block' : 'none';
                    }
                });
            }

            // Presentation mode buttons
            document.querySelectorAll('.display-mode-btn').forEach(btn => {
                btn.addEventListener('click', (e) => { // Update active state
                    document.querySelectorAll('.display-mode-btn').forEach(b => b.classList.remove('active'));
                    btn.classList.add('active');

                    // Update settings
                    const mode = btn.dataset.mode;
                    if (this.streamManager) {
                        this.streamManager.displaySettings.presentationMode = mode;
                        this.streamManager.saveDisplaySettings();

                        // Send to display window if streaming
                        if (this.streamManager.isStreaming) {
                            this.streamManager.channel.postMessage({type: 'display-settings', data: this.streamManager.displaySettings});
                        }
                    }
                });
            });

            // Aspect ratio buttons
            document.querySelectorAll('.aspect-ratio-btn').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    document.querySelectorAll('.aspect-ratio-btn').forEach(b => b.classList.remove('active'));
                    btn.classList.add('active');

                    const ratio = btn.dataset.ratio;
                    if (this.streamManager) {
                        this.streamManager.displaySettings.aspectRatio = ratio;
                        this.streamManager.saveDisplaySettings();
                        this.streamManager.reconfigureCapture();
                    }
                });
            });

            // Capture resolution dropdown
            const captureResolution = document.getElementById('captureResolution');
            if (captureResolution) {
                captureResolution.addEventListener('change', (e) => {
                    const value = parseInt(e.target.value);
                    if (this.streamManager) {
                        this.streamManager.displaySettings.captureResolution = value;
                        this.streamManager.saveDisplaySettings();
                        this.streamManager.reconfigureCapture();
                        
                        // Update stats display
                        if (this.cameraInfo) {
                            this.updateCameraStats();
                        }
                    }
                });
            }

            // Capture frame rate dropdown
            const captureFrameRate = document.getElementById('captureFrameRate');
            if (captureFrameRate) {
                captureFrameRate.addEventListener('change', (e) => {
                    const value = parseInt(e.target.value);
                    if (this.streamManager) {
                        this.streamManager.displaySettings.captureFrameRate = value;
                        this.streamManager.saveDisplaySettings();
                        this.streamManager.reconfigureCapture();
                        
                        // Update stats display
                        if (this.cameraInfo) {
                            this.updateCameraStats();
                        }
                    }
                });
            }

            // Capture bitrate slider
            const captureBitrate = document.getElementById('captureBitrate');
            if (captureBitrate) {
                captureBitrate.addEventListener('input', (e) => {
                    const value = parseInt(e.target.value);
                    document.getElementById('captureBitrateValue').textContent = `${value} Mbps`;
                    if (this.streamManager) {
                        this.streamManager.displaySettings.captureBitrate = value;
                        this.streamManager.saveDisplaySettings();
                        this.streamManager.reconfigureCapture();
                        
                        // Update stats display
                        if (this.cameraInfo) {
                            this.updateCameraStats();
                        }
                    }
                });
            }

            // Display sharpness slider
            const displaySharpness = document.getElementById('displaySharpness');
            if (displaySharpness) {
                displaySharpness.addEventListener('input', (e) => {
                    const value = parseInt(e.target.value);
                    document.getElementById('displaySharpnessValue').textContent = `${value}%`;
                    if (this.streamManager) {
                        this.streamManager.displaySettings.displaySharpness = value;
                        this.streamManager.saveDisplaySettings();

                        if (this.streamManager.isStreaming) {
                            this.streamManager.channel.postMessage({type: 'display-settings', data: this.streamManager.displaySettings});
                        }
                    }
                });
            }

            // Letterbox color picker
            const letterboxColor = document.getElementById('letterboxColor');
            if (letterboxColor) {
                letterboxColor.addEventListener('input', (e) => {
                    const value = e.target.value;
                    document.getElementById('letterboxColorValue').textContent = value;
                    if (this.streamManager) {
                        this.streamManager.displaySettings.letterboxColor = value;
                        this.streamManager.saveDisplaySettings();

                        if (this.streamManager.isStreaming) {
                            this.streamManager.channel.postMessage({type: 'display-settings', data: this.streamManager.displaySettings});
                        }
                    }
                });
            }

            // Mirror background toggle
            const mirrorBackgroundBtn = document.getElementById('mirrorBackgroundBtn');
            if (mirrorBackgroundBtn) {
                mirrorBackgroundBtn.addEventListener('click', () => {
                    if (this.streamManager) {
                        this.streamManager.displaySettings.mirrorBackground = !this.streamManager.displaySettings.mirrorBackground;
                        this.streamManager.saveDisplaySettings();

                        // Update UI
                        mirrorBackgroundBtn.classList.toggle('active', this.streamManager.displaySettings.mirrorBackground);
                        mirrorBackgroundBtn.textContent = `Mirror Background: ${
                            this.streamManager.displaySettings.mirrorBackground ? 'On' : 'Off'
                        }`;

                        // Show/hide blur controls
                        const blurContainer = document.getElementById('mirrorBlurContainer');
                        if (blurContainer) {
                            blurContainer.style.display = this.streamManager.displaySettings.mirrorBackground ? 'flex' : 'none';
                        }

                        // Send to display
                        if (this.streamManager.isStreaming) {
                            this.streamManager.channel.postMessage({type: 'display-settings', data: this.streamManager.displaySettings});
                        }
                    }
                });
            }

            // Mirror background blur slider
            const mirrorBackgroundBlur = document.getElementById('mirrorBackgroundBlur');
            if (mirrorBackgroundBlur) {
                mirrorBackgroundBlur.addEventListener('input', (e) => {
                    const value = parseInt(e.target.value);
                    document.getElementById('mirrorBackgroundBlurValue').textContent = `${value}px`;
                    if (this.streamManager) {
                        this.streamManager.displaySettings.mirrorBackgroundBlur = value;
                        this.streamManager.saveDisplaySettings();

                        if (this.streamManager.isStreaming) {
                            this.streamManager.channel.postMessage({type: 'display-settings', data: this.streamManager.displaySettings});
                        }
                    }
                });
            }

            // Display preset buttons
            document.querySelectorAll('.display-preset-btn').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    const preset = btn.dataset.preset;
                    this.applyDisplayPreset(preset);
                });
            });

            // Display aspect ratio buttons
            document.querySelectorAll('#displaySettingsPanel .aspect-ratio-btn').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    // Remove active class from all aspect ratio buttons in display settings
                    document.querySelectorAll('#displaySettingsPanel .aspect-ratio-btn').forEach(b => b.classList.remove('active'));
                    // Add active class to clicked button
                    btn.classList.add('active');
                    
                    const ratio = btn.dataset.ratio;
                    if (this.streamManager) {
                        this.streamManager.displaySettings.aspectRatio = ratio;
                        this.streamManager.saveDisplaySettings();
                        console.log('Display aspect ratio changed to:', ratio);
                        
                        if (this.streamManager.isStreaming) {
                            this.streamManager.channel.postMessage({type: 'display-settings', data: this.streamManager.displaySettings});
                        }
                    }
                });
            });

            // Kaleidoscope
            // Kaleidoscope controls
            const kaleidoscopeBtn = document.getElementById('kaleidoscopeBtn');
            if (kaleidoscopeBtn) {
                kaleidoscopeBtn.addEventListener('click', () => {
                    this.toggleKaleidoscope();
                });
            }
            
            // Infinite Zoom button
            const infiniteZoomBtn = document.getElementById('infiniteZoomBtn');
            if (infiniteZoomBtn) {
                infiniteZoomBtn.addEventListener('click', () => {
                    this.toggleInfiniteZoom();
                });
            }
            
            // Infinite Zoom close button
            const infiniteZoomCloseBtn = document.getElementById('infiniteZoomCloseBtn');
            if (infiniteZoomCloseBtn) {
                infiniteZoomCloseBtn.addEventListener('click', () => {
                    const panel = document.getElementById('infiniteZoomPanel');
                    if (panel) {
                        panel.style.display = 'none';
                    }
                });
            }
            
            // Infinite Zoom shape selection
            const infiniteZoomShapeSelect = document.getElementById('infiniteZoomShapeSelect');
            if (infiniteZoomShapeSelect) {
                infiniteZoomShapeSelect.addEventListener('change', (e) => {
                    if (this.infiniteZoom) {
                        this.infiniteZoom.shape = e.target.value;
                        this.infiniteZoom.updateObjectShapes();
                        console.log(`🔍 Infinite Zoom shape set to: ${e.target.value}`);
                    }
                });
            }
            
            // Infinite Zoom color randomness slider
            const infiniteZoomColorRandomSlider = document.getElementById('infiniteZoomColorRandomSlider');
            const infiniteZoomColorRandomValue = document.getElementById('infiniteZoomColorRandomValue');
            if (infiniteZoomColorRandomSlider && infiniteZoomColorRandomValue) {
                infiniteZoomColorRandomSlider.addEventListener('input', (e) => {
                    const value = parseFloat(e.target.value);
                    infiniteZoomColorRandomValue.textContent = value.toFixed(1);
                    if (this.infiniteZoom) {
                        this.infiniteZoom.colorRandomness = value;
                        // Update existing objects with new color randomness
                        this.infiniteZoom.objects.forEach(obj => {
                            obj.color = this.infiniteZoom.generateColor();
                        });
                    }
                });
            }
            
            // Infinite Zoom min size slider
            const infiniteZoomMinSizeSlider = document.getElementById('infiniteZoomMinSizeSlider');
            const infiniteZoomMinSizeValue = document.getElementById('infiniteZoomMinSizeValue');
            if (infiniteZoomMinSizeSlider && infiniteZoomMinSizeValue) {
                infiniteZoomMinSizeSlider.addEventListener('input', (e) => {
                    const value = parseInt(e.target.value);
                    infiniteZoomMinSizeValue.textContent = value;
                    if (this.infiniteZoom) {
                        this.infiniteZoom.minSize = value;
                        // Update existing objects with new size range
                        this.infiniteZoom.objects.forEach(obj => {
                            obj.size = this.infiniteZoom.minSize + Math.random() * (this.infiniteZoom.maxSize - this.infiniteZoom.minSize);
                        });
                    }
                });
            }
            
            // Infinite Zoom max size slider
            const infiniteZoomMaxSizeSlider = document.getElementById('infiniteZoomMaxSizeSlider');
            const infiniteZoomMaxSizeValue = document.getElementById('infiniteZoomMaxSizeValue');
            if (infiniteZoomMaxSizeSlider && infiniteZoomMaxSizeValue) {
                infiniteZoomMaxSizeSlider.addEventListener('input', (e) => {
                    const value = parseInt(e.target.value);
                    infiniteZoomMaxSizeValue.textContent = value;
                    if (this.infiniteZoom) {
                        this.infiniteZoom.maxSize = value;
                        // Update existing objects with new size range
                        this.infiniteZoom.objects.forEach(obj => {
                            obj.size = this.infiniteZoom.minSize + Math.random() * (this.infiniteZoom.maxSize - this.infiniteZoom.minSize);
                        });
                    }
                });
            }
            
            // Infinite Zoom density slider
            const infiniteZoomDensitySlider = document.getElementById('infiniteZoomDensitySlider');
            const infiniteZoomDensityValue = document.getElementById('infiniteZoomDensityValue');
            if (infiniteZoomDensitySlider && infiniteZoomDensityValue) {
                infiniteZoomDensitySlider.addEventListener('input', (e) => {
                    const value = parseInt(e.target.value);
                    infiniteZoomDensityValue.textContent = value;
                    if (this.infiniteZoom) {
                        // Convert 1-100 range to actual density based on screen area
                        // At 100, objects should fill screen with no negative space
                        const screenArea = this.infiniteZoom.canvas ? 
                            this.infiniteZoom.canvas.width * this.infiniteZoom.canvas.height : 800 * 600;
                        const maxDensity = Math.floor(screenArea / 100); // 1 object per 100 pixels for max density
                        this.infiniteZoom.density = Math.floor((value / 100) * maxDensity);
                        // Regenerate objects if active
                        if (this.infiniteZoom.isActive) {
                            this.infiniteZoom.generateInitialObjects();
                        }
                    }
                });
            }
            
            // Infinite Zoom speed slider
            const infiniteZoomSpeedSlider = document.getElementById('infiniteZoomSpeedSlider');
            const infiniteZoomSpeedValue = document.getElementById('infiniteZoomSpeedValue');
            if (infiniteZoomSpeedSlider && infiniteZoomSpeedValue) {
                infiniteZoomSpeedSlider.addEventListener('input', (e) => {
                    const value = parseInt(e.target.value);
                    infiniteZoomSpeedValue.textContent = value;
                    if (this.infiniteZoom) {
                        // Convert -100 to 100 range to zoom speed
                        // 0 = no movement, 50 = normal speed, 100 = very fast, -100 = very fast reverse
                        if (value === 0) {
                            this.infiniteZoom.zoomSpeed = 0;
                            this.infiniteZoom.baseZoomSpeed = 0;
                        } else {
                            // Convert to actual zoom speed: -100 to 100 becomes -0.1 to 0.1
                            const newSpeed = (value / 100) * 0.1;
                            this.infiniteZoom.zoomSpeed = newSpeed;
                            this.infiniteZoom.baseZoomSpeed = newSpeed;
                        }
                    }
                });
            }
            
            // Infinite Zoom rotation slider
            const infiniteZoomRotationSlider = document.getElementById('infiniteZoomRotationSlider');
            const infiniteZoomRotationValue = document.getElementById('infiniteZoomRotationValue');
            if (infiniteZoomRotationSlider && infiniteZoomRotationValue) {
                infiniteZoomRotationSlider.addEventListener('input', (e) => {
                    const value = parseFloat(e.target.value);
                    infiniteZoomRotationValue.textContent = value.toFixed(1);
                    if (this.infiniteZoom) {
                        this.infiniteZoom.rotationSpeed = value;
                        this.infiniteZoom.baseRotationSpeed = value;
                        console.log('🔍 Rotation slider changed to:', value, 'Base:', this.infiniteZoom.baseRotationSpeed);
                    }
                });
            }
            
            // Infinite Zoom opacity slider
            const infiniteZoomOpacitySlider = document.getElementById('infiniteZoomOpacitySlider');
            const infiniteZoomOpacityValue = document.getElementById('infiniteZoomOpacityValue');
            if (infiniteZoomOpacitySlider && infiniteZoomOpacityValue) {
                infiniteZoomOpacitySlider.addEventListener('input', (e) => {
                    const value = parseInt(e.target.value);
                    infiniteZoomOpacityValue.textContent = value + '%';
                    if (this.infiniteZoom) {
                        this.infiniteZoom.opacity = value / 100;
                    }
                });
            }
            
            // Infinite Zoom sensitivity slider
            const infiniteZoomSensitivitySlider = document.getElementById('infiniteZoomSensitivitySlider');
            const infiniteZoomSensitivityValue = document.getElementById('infiniteZoomSensitivityValue');
            if (infiniteZoomSensitivitySlider && infiniteZoomSensitivityValue) {
                infiniteZoomSensitivitySlider.addEventListener('input', (e) => {
                    const value = parseInt(e.target.value);
                    infiniteZoomSensitivityValue.textContent = value + '%';
                    if (this.infiniteZoom) {
                        this.infiniteZoom.sensitivity = value / 100; // Convert 0-100 to 0-1
                        console.log('🔍 Sensitivity changed to:', this.infiniteZoom.sensitivity);
                    }
                });
            }
            
            // Infinite Zoom Beat React button
            const infiniteZoomBeatReactBtn = document.getElementById('infiniteZoomBeatReactBtn');
            if (infiniteZoomBeatReactBtn) {
                infiniteZoomBeatReactBtn.addEventListener('click', () => {
                    if (this.infiniteZoom) {
                        this.infiniteZoom.beatReact = !this.infiniteZoom.beatReact;
                        infiniteZoomBeatReactBtn.textContent = `Beat React: ${this.infiniteZoom.beatReact ? 'On' : 'Off'}`;
                        infiniteZoomBeatReactBtn.classList.toggle('active', this.infiniteZoom.beatReact);
                        console.log('🔍 Beat React toggled to:', this.infiniteZoom.beatReact);
                        
                        // Show/hide beat reaction controls
                        const controls = document.getElementById('infiniteZoomBeatReactControls');
                        if (controls) {
                            controls.style.display = this.infiniteZoom.beatReact ? 'block' : 'none';
                        }
                        
                        // When enabling Beat React, turn on all individual controls by default
                        if (this.infiniteZoom.beatReact) {
                            this.infiniteZoom.beatZoom = true;
                            this.infiniteZoom.beatRotation = true;
                            this.infiniteZoom.beatDensity = true;
                            this.infiniteZoom.beatShape = true;
                            
                            // Update button states
                            const beatZoomBtn = document.getElementById('infiniteZoomBeatZoomBtn');
                            const beatRotationBtn = document.getElementById('infiniteZoomBeatRotationBtn');
                            const beatDensityBtn = document.getElementById('infiniteZoomBeatDensityBtn');
                            const beatShapeBtn = document.getElementById('infiniteZoomBeatShapeBtn');
                            
                            if (beatZoomBtn) {
                                beatZoomBtn.textContent = 'Beat Zoom: On';
                                beatZoomBtn.classList.add('active');
                            }
                            if (beatRotationBtn) {
                                beatRotationBtn.textContent = 'Beat Rotation: On';
                                beatRotationBtn.classList.add('active');
                            }
                            if (beatDensityBtn) {
                                beatDensityBtn.textContent = 'Beat Density: On';
                                beatDensityBtn.classList.add('active');
                            }
                            if (beatShapeBtn) {
                                beatShapeBtn.textContent = 'Beat Shape: On';
                                beatShapeBtn.classList.add('active');
                            }
                        } else {
                            // When disabling Beat React, turn off all individual controls
                            this.infiniteZoom.beatZoom = false;
                            this.infiniteZoom.beatRotation = false;
                            this.infiniteZoom.beatDensity = false;
                            this.infiniteZoom.beatShape = false;
                        }
                        
                        console.log(`🔍 Infinite Zoom Beat React: ${this.infiniteZoom.beatReact ? 'On' : 'Off'}`);
                    }
                });
            }
            
            // Beat reaction control buttons
            const infiniteZoomBeatZoomBtn = document.getElementById('infiniteZoomBeatZoomBtn');
            if (infiniteZoomBeatZoomBtn) {
                infiniteZoomBeatZoomBtn.addEventListener('click', () => {
                    if (this.infiniteZoom) {
                        this.infiniteZoom.beatZoom = !this.infiniteZoom.beatZoom;
                        infiniteZoomBeatZoomBtn.textContent = `Beat Zoom: ${this.infiniteZoom.beatZoom ? 'On' : 'Off'}`;
                        infiniteZoomBeatZoomBtn.classList.toggle('active', this.infiniteZoom.beatZoom);
                    }
                });
            }
            
            const infiniteZoomBeatRotationBtn = document.getElementById('infiniteZoomBeatRotationBtn');
            if (infiniteZoomBeatRotationBtn) {
                infiniteZoomBeatRotationBtn.addEventListener('click', () => {
                    if (this.infiniteZoom) {
                        this.infiniteZoom.beatRotation = !this.infiniteZoom.beatRotation;
                        infiniteZoomBeatRotationBtn.textContent = `Beat Rotation: ${this.infiniteZoom.beatRotation ? 'On' : 'Off'}`;
                        infiniteZoomBeatRotationBtn.classList.toggle('active', this.infiniteZoom.beatRotation);
                        console.log('🔍 Beat Rotation toggled to:', this.infiniteZoom.beatRotation);
                    }
                });
            }
            
            const infiniteZoomBeatDensityBtn = document.getElementById('infiniteZoomBeatDensityBtn');
            if (infiniteZoomBeatDensityBtn) {
                infiniteZoomBeatDensityBtn.addEventListener('click', () => {
                    if (this.infiniteZoom) {
                        this.infiniteZoom.beatDensity = !this.infiniteZoom.beatDensity;
                        infiniteZoomBeatDensityBtn.textContent = `Beat Density: ${this.infiniteZoom.beatDensity ? 'On' : 'Off'}`;
                        infiniteZoomBeatDensityBtn.classList.toggle('active', this.infiniteZoom.beatDensity);
                    }
                });
            }
            
            const infiniteZoomBeatShapeBtn = document.getElementById('infiniteZoomBeatShapeBtn');
            if (infiniteZoomBeatShapeBtn) {
                infiniteZoomBeatShapeBtn.addEventListener('click', () => {
                    if (this.infiniteZoom) {
                        this.infiniteZoom.beatShape = !this.infiniteZoom.beatShape;
                        infiniteZoomBeatShapeBtn.textContent = `Beat Shape: ${this.infiniteZoom.beatShape ? 'On' : 'Off'}`;
                        infiniteZoomBeatShapeBtn.classList.toggle('active', this.infiniteZoom.beatShape);
                    }
                });
            }

            const kaleidoscopeSettingsBtn = document.getElementById('kaleidoscopeSettingsBtn');
            if (kaleidoscopeSettingsBtn) {
                kaleidoscopeSettingsBtn.addEventListener('click', () => {
                    const panel = document.getElementById('kaleidoscopePanel');
                    panel.style.display = panel.style.display === 'none' ? 'block' : 'none';
                });
            }

            const kaleidoscopeCloseBtn = document.getElementById('kaleidoscopeCloseBtn');
            if (kaleidoscopeCloseBtn) {
                kaleidoscopeCloseBtn.addEventListener('click', () => {
                    document.getElementById('kaleidoscopePanel').style.display = 'none';
                });
            }

            // Beat rotation toggle
            const beatRotationBtn = document.getElementById('kaleidoscopeBeatRotationBtn');
            if (beatRotationBtn) {
                beatRotationBtn.addEventListener('click', () => {
                    this.kaleidoscopeBeatRotation = !this.kaleidoscopeBeatRotation;
                    beatRotationBtn.textContent = `Rotation: ${
                        this.kaleidoscopeBeatRotation ? 'On' : 'Off'
                    }`;
                    beatRotationBtn.classList.toggle('active', this.kaleidoscopeBeatRotation);
                });
            }

            // Beat shape toggle
            const beatShapeBtn = document.getElementById('kaleidoscopeBeatShapeBtn');
            if (beatShapeBtn) {
                beatShapeBtn.addEventListener('click', () => {
                    this.kaleidoscopeBeatShape = !this.kaleidoscopeBeatShape;
                    beatShapeBtn.textContent = `Shape: ${
                        this.kaleidoscopeBeatShape ? 'On' : 'Off'
                    }`;
                    beatShapeBtn.classList.toggle('active', this.kaleidoscopeBeatShape);

                    // Store current shape as original
                    if (this.kaleidoscopeBeatShape) {
                        this.kaleidoscopeOriginalShape = this.kaleidoscopeShape;
                    }
                });
            }

            // Kaleidoscope sliders
            const kaleidoscopeSegments = document.getElementById('kaleidoscopeSegments');
            if (kaleidoscopeSegments) {
                kaleidoscopeSegments.addEventListener('input', (e) => {
                    const value = parseInt(e.target.value);
                    this.setKaleidoscopeSegments(value);
                    document.getElementById('kaleidoscopeSegmentsValue').textContent = value;
                });
            }

            const kaleidoscopeSpeed = document.getElementById('kaleidoscopeSpeed');
            if (kaleidoscopeSpeed) {
                kaleidoscopeSpeed.addEventListener('input', (e) => {
                    const value = parseFloat(e.target.value);
                    this.setKaleidoscopeSpeed(value);
                    document.getElementById('kaleidoscopeSpeedValue').textContent = value;
                });
            }

            const kaleidoscopeScale = document.getElementById('kaleidoscopeScale');
            if (kaleidoscopeScale) {
                kaleidoscopeScale.addEventListener('input', (e) => {
                    const value = parseInt(e.target.value);
                    this.setKaleidoscopeScale(value);
                    document.getElementById('kaleidoscopeScaleValue').textContent = `${value}%`;
                });
            }

            const kaleidoscopeCenterX = document.getElementById('kaleidoscopeCenterX');
            if (kaleidoscopeCenterX) {
                kaleidoscopeCenterX.addEventListener('input', (e) => {
                    const value = parseInt(e.target.value);
                    this.setKaleidoscopeCenterX(value);
                    document.getElementById('kaleidoscopeCenterXValue').textContent = `${value}%`;
                });
            }

            // Beat reactive toggle
            // Beat reactive toggle
            const kaleidoscopeBeatBtn = document.getElementById('kaleidoscopeBeatBtn');
            if (kaleidoscopeBeatBtn) {
                kaleidoscopeBeatBtn.addEventListener('click', () => {
                    this.kaleidoscopeBeatReactive = !this.kaleidoscopeBeatReactive;
                    kaleidoscopeBeatBtn.textContent = `Beat React: ${
                        this.kaleidoscopeBeatReactive ? 'On' : 'Off'
                    }`;
                    kaleidoscopeBeatBtn.classList.toggle('active', this.kaleidoscopeBeatReactive);

                    const sensitivityContainer = document.getElementById('beatSensitivityContainer');
                    if (sensitivityContainer) {
                        sensitivityContainer.style.display = this.kaleidoscopeBeatReactive ? 'block' : 'none';
                    }

                    // Store base values when enabling
                    if (this.kaleidoscopeBeatReactive) { // Reset scale to max 150% if it's higher
                        if (this.kaleidoscopeScale > 1.5) {
                            this.kaleidoscopeScale = 1.5;
                            // Update slider and display
                            const scaleSlider = document.getElementById('kaleidoscopeScale');
                            const scaleValue = document.getElementById('kaleidoscopeScaleValue');
                            if (scaleSlider && scaleValue) {
                                scaleSlider.value = 150;
                                scaleValue.textContent = '150%';
                            }
                        }
                        this.kaleidoscopeBaseScale = this.kaleidoscopeScale;
                        this.kaleidoscopeBaseSegments = this.kaleidoscopeSegments;
                    }
                });
            }

            // Beat sensitivity
            const beatSensitivitySlider = document.getElementById('kaleidoscopeBeatSensitivity');
            if (beatSensitivitySlider) {
                beatSensitivitySlider.addEventListener('input', (e) => {
                    const value = parseInt(e.target.value);
                    this.kaleidoscopeBeatSensitivity = value / 100;
                    document.getElementById('kaleidoscopeBeatSensitivityValue').textContent = `${value}%`;
                });
            }


            // Kaleidoscope preset buttons
            document.querySelectorAll('.kaleidoscope-preset-btn').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    const presetIndex = parseInt(e.target.dataset.preset);
                    this.applyKaleidoscopePreset(this.kaleidoscopePresets[presetIndex]);
                });
            });

            // Rings control
            const kaleidoscopeRings = document.getElementById('kaleidoscopeRings');
            if (kaleidoscopeRings) {
                kaleidoscopeRings.addEventListener('input', (e) => {
                    const value = parseInt(e.target.value);
                    this.kaleidoscopeRings = value;
                    document.getElementById('kaleidoscopeRingsValue').textContent = value;
                    if (this.kaleidoscopeEnabled) {
                        this.applyKaleidoscopeEffect();
                    }
                });
            }

            // Ring spacing control
            const kaleidoscopeRingSpacing = document.getElementById('kaleidoscopeRingSpacing');
            if (kaleidoscopeRingSpacing) {
                kaleidoscopeRingSpacing.addEventListener('input', (e) => {
                    const value = parseInt(e.target.value);
                    this.kaleidoscopeRingSpacing = value / 100;
                    document.getElementById('kaleidoscopeRingSpacingValue').textContent = `${value}%`;
                    if (this.kaleidoscopeEnabled) {
                        this.applyKaleidoscopeEffect();
                    }
                });
            }

            // Shape toggle
            const kaleidoscopeShapeBtn = document.getElementById('kaleidoscopeShapeBtn');
            if (kaleidoscopeShapeBtn) {
                kaleidoscopeShapeBtn.addEventListener('click', () => {
                    const shapes = ['triangle', 'petal', 'rectangle'];
                    const currentIndex = shapes.indexOf(this.kaleidoscopeShape);
                    this.kaleidoscopeShape = shapes[(currentIndex + 1) % shapes.length];
                    kaleidoscopeShapeBtn.textContent = `Shape: ${
                        this.kaleidoscopeShape.charAt(0).toUpperCase() + this.kaleidoscopeShape.slice(1)
                    }`;
                    if (this.kaleidoscopeEnabled) {
                        this.applyKaleidoscopeEffect();
                    }
                });
            }

            const kaleidoscopeCenterY = document.getElementById('kaleidoscopeCenterY');
            if (kaleidoscopeCenterY) {
                kaleidoscopeCenterY.addEventListener('input', (e) => {
                    const value = parseInt(e.target.value);
                    this.setKaleidoscopeCenterY(value);
                    document.getElementById('kaleidoscopeCenterYValue').textContent = `${value}%`;
                });
            }

            // Toggle buttons for applying to video/viz
            const kaleidoscopeVideoBtn = document.getElementById('kaleidoscopeVideoBtn');
            if (kaleidoscopeVideoBtn) {
                kaleidoscopeVideoBtn.addEventListener('click', () => {
                    this.kaleidoscopeApplyToVideo = !this.kaleidoscopeApplyToVideo;
                    kaleidoscopeVideoBtn.textContent = `Apply to Video: ${
                        this.kaleidoscopeApplyToVideo ? 'On' : 'Off'
                    }`;
                    kaleidoscopeVideoBtn.classList.toggle('active', this.kaleidoscopeApplyToVideo);

                    // Enable kaleidoscope if turning on
                    if (this.kaleidoscopeApplyToVideo) {
                        if (!this.kaleidoscopeEnabled) {
                            this.kaleidoscopeEnabled = true;
                            this.initKaleidoscope(); // Make sure it's initialized
                            this.startKaleidoscopeAnimation();
                        }

                        // Force immediate redraw
                        this.applyKaleidoscopeEffect();
                    } else if (!this.kaleidoscopeApplyToViz) {
                        this.stopKaleidoscopeAnimation();
                        this.kaleidoscopeEnabled = false;
                    }

                    // Update main button state
                    const btn = document.getElementById('kaleidoscopeBtn');
                    const btnText = btn.querySelector('.kaleidoscope-btn-text');
                    if (this.kaleidoscopeEnabled) {
                        btnText.textContent = 'Kaleidoscope On';
                        btn.classList.add('active');
                    } else {
                        btnText.textContent = 'Kaleidoscope Off';
                        btn.classList.remove('active');
                    }
                });
            }

            const kaleidoscopeVizBtn = document.getElementById('kaleidoscopeVizBtn');
            if (kaleidoscopeVizBtn) {
                kaleidoscopeVizBtn.addEventListener('click', () => {
                    this.kaleidoscopeApplyToViz = !this.kaleidoscopeApplyToViz;
                    kaleidoscopeVizBtn.textContent = `Apply to Viz: ${
                        this.kaleidoscopeApplyToViz ? 'On' : 'Off'
                    }`;
                    kaleidoscopeVizBtn.classList.toggle('active', this.kaleidoscopeApplyToViz);

                    // Enable kaleidoscope if turning on, disable if both are off
                    if (this.kaleidoscopeApplyToViz) {
                        if (!this.kaleidoscopeEnabled) {
                            this.kaleidoscopeEnabled = true;
                            this.initKaleidoscope();
                            this.startKaleidoscopeAnimation();
                        }
                    } else if (!this.kaleidoscopeApplyToVideo) {
                        this.stopKaleidoscopeAnimation();
                        this.kaleidoscopeEnabled = false;
                    }

                    // Update main button state
                    const btn = document.getElementById('kaleidoscopeBtn');
                    const btnText = btn.querySelector('.kaleidoscope-btn-text');
                    if (this.kaleidoscopeEnabled) {
                        btnText.textContent = 'Kaleidoscope On';
                        btn.classList.add('active');
                    } else {
                        btnText.textContent = 'Kaleidoscope Off';
                        btn.classList.remove('active');
                    }

                    if (this.kaleidoscopeEnabled) {
                        this.applyKaleidoscopeEffect();
                    }
                });
            }

            // Infinite Zoom toggle button
            const kaleidoscopeInfiniteZoomBtn = document.getElementById('kaleidoscopeInfiniteZoomBtn');
            if (kaleidoscopeInfiniteZoomBtn) {
                // Initialize button state
                kaleidoscopeInfiniteZoomBtn.textContent = `Infinite Zoom: ${
                    this.kaleidoscopeApplyToInfiniteZoom ? 'On' : 'Off'
                }`;
                kaleidoscopeInfiniteZoomBtn.classList.toggle('active', this.kaleidoscopeApplyToInfiniteZoom);
                
                kaleidoscopeInfiniteZoomBtn.addEventListener('click', () => {
                    this.kaleidoscopeApplyToInfiniteZoom = !this.kaleidoscopeApplyToInfiniteZoom;
                    kaleidoscopeInfiniteZoomBtn.textContent = `Infinite Zoom: ${
                        this.kaleidoscopeApplyToInfiniteZoom ? 'On' : 'Off'
                    }`;
                    kaleidoscopeInfiniteZoomBtn.classList.toggle('active', this.kaleidoscopeApplyToInfiniteZoom);

                    // Apply kaleidoscope effect if enabled
                    if (this.kaleidoscopeEnabled) {
                        this.applyKaleidoscopeEffect();
                    }
                });
            }


            // End Kaleidoscope

            // Toggle buttons
            const videoInvertBtn = document.getElementById('videoInvertBtn');
            if (videoInvertBtn) {
                videoInvertBtn.addEventListener('click', () => {
                    this.toggleVideoInvert();
                    videoInvertBtn.textContent = `Invert: ${
                        this.videoInvert ? 'On' : 'Off'
                    }`;
                    videoInvertBtn.classList.toggle('active', this.videoInvert);
                });
            }

            const videoMirrorBtn = document.getElementById('videoMirrorBtn');
            if (videoMirrorBtn) {
                videoMirrorBtn.addEventListener('click', () => {
                    this.cycleVideoMirror();
                    const mirrorText = this.videoMirror === 'off' ? 'Off' : this.videoMirror.charAt(0).toUpperCase() + this.videoMirror.slice(1);
                    videoMirrorBtn.textContent = `Mirror: ${mirrorText}`;
                    videoMirrorBtn.classList.toggle('active', this.videoMirror !== 'off');
                });
            }

            const videoPulseBtn = document.getElementById('videoPulseBtn');
            if (videoPulseBtn) {
                videoPulseBtn.addEventListener('click', () => {
                    this.toggleVideoPulse();
                    videoPulseBtn.textContent = `Pulse: ${
                        this.videoPulse ? 'On' : 'Off'
                    }`;
                    videoPulseBtn.classList.toggle('active', this.videoPulse);
                });
            }

            // Inline video file controls
            const videoFileLoopBtn = document.getElementById('videoFileLoopBtn');
            if (videoFileLoopBtn) {
                videoFileLoopBtn.addEventListener('click', () => {
                    this.videoFileLoop = !this.videoFileLoop;
                    videoFileLoopBtn.classList.toggle('active', this.videoFileLoop);
                    
                    // Update loop setting on video elements
                    if (this.videoElement && this.videoMode === 'file') {
                        this.videoElement.loop = this.videoFileLoop;
                    }
                    
                    // Update stats if visible
                    if (this.videoMode === 'file') {
                        this.detectVideoFileInfo();
                    }
                });
            }

            const videoFileMuteBtn = document.getElementById('videoFileMuteBtn');
            if (videoFileMuteBtn) {
                videoFileMuteBtn.addEventListener('click', () => {
                    this.videoFileMuted = !this.videoFileMuted;
                    videoFileMuteBtn.textContent = this.videoFileMuted ? 'Muted' : 'Sound';
                    videoFileMuteBtn.classList.toggle('active', this.videoFileMuted);
                    
                    // Update gain node instead of video element muted property
                    if (this.videoAudioGain) {
                        this.videoAudioGain.gain.value = this.videoFileMuted ? 0 : 1;
                        console.log('Video audio gain set to:', this.videoFileMuted ? 0 : 1);
                    }
                });
            }

            // Match Visualization Aspect Ratio toggle
            const matchVisualizationAspectBtn = document.getElementById('matchVisualizationAspectBtn');
            if (matchVisualizationAspectBtn) {
                matchVisualizationAspectBtn.addEventListener('click', () => {
                    this.matchVisualizationAspect = !this.matchVisualizationAspect;
                    matchVisualizationAspectBtn.textContent = this.matchVisualizationAspect ? 'Match Video Aspect: On' : 'Match Video Aspect: Off';
                    matchVisualizationAspectBtn.classList.toggle('active', this.matchVisualizationAspect);
                    
                    // Apply aspect ratio matching if video is active
                    if ((this.videoMode === 'camera' || this.videoMode === 'file') && this.videoElement) {
                        this.updateVisualizationAspectRatio();
                    }
                    
                    console.log('Match visualization aspect ratio:', this.matchVisualizationAspect);
                });
            }

            // Preset buttons
            // Live video presets (exclude file browser presets)
            document.querySelectorAll('.video-preset-btn:not([data-target="fileBrowser"])').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    const preset = e.target.dataset.preset;
                    console.log('Applying LIVE VIDEO preset:', preset);
                    this.applyVideoPreset(preset);
                });
            });

            // Toggle panel visibility when clicking the video button (when already active)
            const videoInputBtn = document.getElementById('videoInputBtn');
            if (videoInputBtn) {
                videoInputBtn.addEventListener('click', () => {
                    if (this.videoMode === 'camera' || this.videoMode === 'file') { // If video is on, turn it OFF (not toggle panel)
                        this.stopVideoInput();
                        const btnText = videoInputBtn.querySelector('.video-mode-text');
                        btnText.textContent = 'Video Input';
                        videoInputBtn.classList.remove('video-active');
                        document.getElementById('videoDeviceSelect').style.display = 'none';
                        document.getElementById('videoControlsPanel').style.display = 'none';
                        this.videoMode = 'off';
                    } else { // If video is off, start the selection process
                        this.toggleVideoInput();
                    }
                });
            }

            const videoDeviceSelect = document.getElementById('videoDeviceSelect');
            if (videoDeviceSelect) {
                videoDeviceSelect.addEventListener('change', async (e) => {
                    const value = e.target.value;
                    if (value === 'file') {
                        // Trigger file input
                        const fileInput = document.getElementById('videoFileInput');
                        if (fileInput) {
                            fileInput.click();
                        }
                    } else if (value) {
                        // Start camera input
                        await this.startVideoInput(value);
                    }
                });
            }

            // Video file input handler
            const videoFileInput = document.getElementById('videoFileInput');
            if (videoFileInput) {
                videoFileInput.addEventListener('change', async (e) => {
                    const file = e.target.files?.[0];
                    if (file && file.type.startsWith('video/')) {
                        console.log('Selected video file:', file.name, file.type);
                        await this.startVideoFile(file);
                        // Update the dropdown to show the file name
                        this.updateVideoDeviceList();
                        const deviceSelect = document.getElementById('videoDeviceSelect');
                        if (deviceSelect) {
                            deviceSelect.value = 'file';
                        }
                        // Reset file input for reselection
                        e.target.value = '';
                    } else if (file) {
                        this.showError('Please select a valid video file');
                        // Reset the file input
                        e.target.value = '';
                    }
                });
            }

            const videoOpacitySlider = document.getElementById('videoOpacitySlider');
            if (videoOpacitySlider) {
                videoOpacitySlider.addEventListener('input', (e) => {
                    const value = e.target.value / 100;
                    this.setVideoOpacity(value);
                    document.getElementById('videoOpacityValue').textContent = `${
                        e.target.value
                    }%`;
                });
            }

            const videoFadeSlider = document.getElementById('videoFadeSlider');
            if (videoFadeSlider) {
                videoFadeSlider.addEventListener('input', (e) => {
                    const value = parseFloat(e.target.value);
                    this.setVideoFadeTime(value);
                    document.getElementById('videoFadeValue').textContent = `${
                        value.toFixed(1)
                    }s`;
                });
            }

            // Audio input mode button
            const inputBtn = document.getElementById('inputModeBtn');
            if (inputBtn) {
                inputBtn.addEventListener('click', () => {
                    this.toggleInputMode();
                });
            }

            // Audio device selector
            const deviceSelect = document.getElementById('audioDeviceSelect');
            if (deviceSelect) {
                deviceSelect.addEventListener('change', async (e) => {
                    const deviceId = e.target.value;

                    if (deviceId === 'help') {
                        this.showSystemAudioHelp();
                        e.target.value = '';
                    } else if (deviceId) {
                        await this.startLiveInput(deviceId);
                    }
                });
            }


            // Morph controls
            const morphBtn = document.getElementById('morphBtn');
            if (morphBtn) {
                morphBtn.addEventListener('click', () => {
                    this.toggleMorph();
                });
            }

            const morphSpeedSelect = document.getElementById('morphSpeedSelect');
            if (morphSpeedSelect) {
                morphSpeedSelect.addEventListener('change', (e) => {
                    this.setMorphSpeed(e.target.value);
                });
            }

            // Random visualization button
            const randomBtn = document.getElementById('randomVizBtn');
            if (randomBtn) {
                randomBtn.addEventListener('click', () => {
                    this.setRandomVisualization();
                });
            }

            // Fullscreen exit button
            const fullscreenExitBtn = document.getElementById('fullscreenExitBtn');
            if (fullscreenExitBtn) {
                fullscreenExitBtn.addEventListener('click', () => {
                    this.exitFullscreen();
                });
            }

            // Click to exit fullscreen on mobile/touch devices
            document.addEventListener('click', (e) => {
                if (this.isFullscreen && (e.target.id === 'visualizationContainer' || e.target.id === 'visualizer' || e.target.tagName === 'CANVAS')) {
                    if (window.innerWidth<= 768 || 'ontouchstart' in window) {
                if (!e.target.closest('#fullscreenRandomBtn')) {
                    this.exitFullscreen();
                }
            }
        }
    });
    
    // Playback controls
    document.getElementById('playBtn').addEventListener('click', () => this.togglePlay()) 

                        document.getElementById('prevBtn').addEventListener('click', () => this.prevTrack());
                    
                    document.getElementById('nextBtn').addEventListener('click', () => this.nextTrack());
                    document.getElementById('loopBtn').addEventListener('click', () => this.toggleLoop());

                    // Background color controls
                    const bgColorBtn = document.getElementById('bgColorBtn');
                    const bgColorPicker = document.getElementById('bgColorPicker');

                    if (bgColorBtn && bgColorPicker) {
                        bgColorBtn.addEventListener('click', () => {
                            bgColorPicker.click();
                        });

                        bgColorPicker.addEventListener('change', (e) => {
                            this.setBackgroundColor(e.target.value);
                        });
                    }

                    // Preset controls
                    const savePresetBtn = document.getElementById('savePresetBtn');
                    if (savePresetBtn) {
                        savePresetBtn.addEventListener('click', () => {
                            const name = prompt('Enter preset name:', `Preset ${
                                this.savedPresets.length + 1
                            }`);
                            if (name) {
                                this.saveCurrentAsPreset(name);
                            }
                        });
                    }

                    const presetSelector = document.getElementById('presetSelector');
                    if (presetSelector) {
                        presetSelector.addEventListener('change', (e) => {
                            if (e.target.value !== '') {
                                this.loadPreset(parseInt(e.target.value));
                                e.target.value = '';
                            }
                        });
                    }

                    const exportPresetsBtn = document.getElementById('exportPresetsBtn');
                    if (exportPresetsBtn) {
                        exportPresetsBtn.addEventListener('click', () => {
                            this.exportPresets();
                        });
                    }

                    const importPresetsBtn = document.getElementById('importPresetsBtn');
                    if (importPresetsBtn) {
                        importPresetsBtn.addEventListener('click', () => {
                            document.getElementById('importPresetsFile').click();
                        });
                    }

                    const importPresetsFile = document.getElementById('importPresetsFile');
                    if (importPresetsFile) {
                        importPresetsFile.addEventListener('change', (e) => {
                            const file = e.target.files[0];
                            if (file) {
                                this.importPresets(file);
                                e.target.value = '';
                            }
                        });
                    }

                    // Info popup
                    const infoBtn = document.getElementById('infoBtn');
                    if (infoBtn) {
                        infoBtn.addEventListener('click', () => this.showInfoPopup());
                    }

                    const popupOverlay = document.getElementById('popupOverlay');
                    if (popupOverlay) {
                        popupOverlay.addEventListener('click', () => this.closeInfoPopup());
                    }

                    // Progress bar click to seek
                    const progressBar = document.getElementById('progressBar');
                    if (progressBar) {
                        progressBar.addEventListener('click', (e) => {
                            if (this.audio && this.audio.duration) {
                                const rect = e.currentTarget.getBoundingClientRect();
                                const percent = (e.clientX - rect.left) / rect.width;
                                this.audio.currentTime = percent * this.audio.duration;
                            }
                        });
                    }

                    // Volume slider
                    const volumeSlider = document.getElementById('volumeSlider');
                    if (volumeSlider) {
                        volumeSlider.addEventListener('click', (e) => {
                            const rect = e.currentTarget.getBoundingClientRect();
                            const percent = Math.max(0, Math.min(1, (e.clientX - rect.left) / rect.width));
                            this.setVolume(percent);
                        });
                    }

                    // ========== FULLSCREEN CONTROLS ==========

                    // Fullscreen playback controls
                    const fsPlayBtn = document.getElementById('fsPlayBtn');
                    if (fsPlayBtn) {
                        fsPlayBtn.addEventListener('click', () => {
                            this.togglePlay();
                            fsPlayBtn.innerHTML = this.isPlaying ? '⏸' : '▶';
                        });
                    }

                    const fsPrevBtn = document.getElementById('fsPrevBtn');
                    if (fsPrevBtn) {
                        fsPrevBtn.addEventListener('click', () => this.prevTrack());
                    }

                    const fsNextBtn = document.getElementById('fsNextBtn');
                    if (fsNextBtn) {
                        fsNextBtn.addEventListener('click', () => this.nextTrack());
                    }

                    const fsLoopBtn = document.getElementById('fsLoopBtn');
                    if (fsLoopBtn) {
                        fsLoopBtn.addEventListener('click', () => {
                            this.toggleLoop();
                            const fsLoopIndicator = document.getElementById('fsLoopIndicator');
                            if (fsLoopIndicator) {
                                switch (this.loopMode) {
                                    case 'off': fsLoopBtn.classList.remove('active');
                                        fsLoopIndicator.style.display = 'none';
                                        break;
                                    case 'one': fsLoopBtn.classList.add('active');
                                        fsLoopIndicator.style.display = 'flex';
                                        fsLoopIndicator.textContent = '1';
                                        break;
                                    case 'all': fsLoopBtn.classList.add('active');
                                        fsLoopIndicator.style.display = 'flex';
                                        fsLoopIndicator.textContent = 'A';
                                        break;
                                }
                            }
                        });
                    }

                    // Fullscreen progress bar
                    const fsProgressBar = document.getElementById('fsProgressBar');
                    if (fsProgressBar) {
                        fsProgressBar.addEventListener('click', (e) => {
                            if (this.audio && this.audio.duration) {
                                const rect = e.currentTarget.getBoundingClientRect();
                                const percent = (e.clientX - rect.left) / rect.width;
                                this.audio.currentTime = percent * this.audio.duration;
                            }
                        });
                    }

                    // Fullscreen volume
                    const fsVolumeSlider = document.getElementById('fsVolumeSlider');
                    if (fsVolumeSlider) {
                        fsVolumeSlider.addEventListener('click', (e) => {
                            const rect = e.currentTarget.getBoundingClientRect();
                            const percent = Math.max(0, Math.min(1, (e.clientX - rect.left) / rect.width));
                            this.setVolume(percent);
                            document.getElementById('fsVolumeFill').style.width = `${
                                percent * 100
                            }%`;
                        });
                    }

                    // Fullscreen playlist dropdown
                    const fsPlaylistSelect = document.getElementById('fsPlaylistSelect');
                    if (fsPlaylistSelect) {
                        fsPlaylistSelect.addEventListener('change', async (e) => {
                            if (e.target.value !== '') {
                                await this.selectTrack(parseInt(e.target.value));
                            }
                        });
                    }

                    // Fullscreen color scheme
                    const fsColorSelect = document.getElementById('fsColorSelect');
                    if (fsColorSelect) {
                        fsColorSelect.addEventListener('change', (e) => {
                            this.setColorScheme(e.target.value);
                        });
                    }

                    // Fullscreen visualization mode
                    const fsVizSelect = document.getElementById('fsVizSelect');
                    if (fsVizSelect) {
                        fsVizSelect.addEventListener('change', (e) => {
                            this.setVisualizationMode(parseInt(e.target.value));
                        });
                    }

                    // Fullscreen preset dropdown
                    const fsPresetSelect = document.getElementById('fsPresetSelect');
                    if (fsPresetSelect) {
                        fsPresetSelect.addEventListener('change', (e) => {
                            if (e.target.value !== '') {
                                this.loadPreset(parseInt(e.target.value));
                                e.target.value = '';
                            }
                        });
                    }

                    // Fullscreen background color
                    const fsBgColorBtn = document.getElementById('fsBgColorBtn');
                    const fsBgColorPicker = document.getElementById('fsBgColorPicker');
                    if (fsBgColorBtn && fsBgColorPicker) {
                        fsBgColorBtn.addEventListener('click', () => {
                            fsBgColorPicker.click();
                        });

                        fsBgColorPicker.addEventListener('change', (e) => {
                            this.setBackgroundColor(e.target.value);
                        });
                    }

                    // Fullscreen morph controls
                    const fsMorphBtn = document.getElementById('fsMorphBtn');
                    if (fsMorphBtn) {
                        fsMorphBtn.addEventListener('click', () => {
                            this.toggleMorph();
                            fsMorphBtn.classList.toggle('active', this.isMorphing);
                        });
                    }

                    const fsMorphSpeed = document.getElementById('fsMorphSpeed');
                    if (fsMorphSpeed) {
                        fsMorphSpeed.addEventListener('change', (e) => {
                            this.setMorphSpeed(e.target.value);
                        });
                    }

                    // Fullscreen random button
                    const fsRandomBtn = document.getElementById('fsRandomBtn');
                    if (fsRandomBtn) {
                        fsRandomBtn.addEventListener('click', () => {
                            this.setRandomVisualization();
                        });
                    }

                    // Fullscreen button
                    const fullscreenBtn = document.getElementById('fullscreenBtn');
                    if (fullscreenBtn) {
                        fullscreenBtn.addEventListener('click', () => this.toggleFullscreen());
                    }

                    // Fullscreen change events
                    // Fullscreen change events
                    const fullscreenChangeHandler = () => {
                        this.isFullscreen = !!(document.fullscreenElement || document.mozFullScreenElement || document.webkitFullscreenElement || document.msFullscreenElement);

                        const exitBtn = document.getElementById('fullscreenExitBtn');
                        const fsControls = document.getElementById('fullscreenControls');
                        const visualizationContainer = document.querySelector('.visualization-container');

                        if (this.isFullscreen) {
                            document.body.classList.add('fullscreen-mode');

                            if (visualizationContainer && fsControls) {
                                visualizationContainer.appendChild(fsControls);
                                fsControls.style.display = 'flex';

                                // Start auto-hide timer
                                this.showFullscreenControls();

                                // Add mouse movement listener for fullscreen
                                if (!this.fullscreenMouseHandler) {
                                    this.fullscreenMouseHandler = () => this.showFullscreenControls();
                                }
                                document.addEventListener('mousemove', this.fullscreenMouseHandler);
                            }

                            if (exitBtn) {
                                exitBtn.style.display = 'flex';
                            }

                            // Populate fullscreen playlist dropdown
                            const fsPlaylistSelect = document.getElementById('fsPlaylistSelect');
                            if (fsPlaylistSelect && this.playlist) {
                                fsPlaylistSelect.innerHTML = '<option value="">Select Track...</option>';
                                this.playlist.forEach((track, index) => {
                                    const option = document.createElement('option');
                                    option.value = index;
                                    option.textContent = track.name;
                                    if (index === this.currentTrackIndex) {
                                        option.selected = true;
                                    }
                                    fsPlaylistSelect.appendChild(option);
                                });
                            }

                            // Populate fullscreen presets dropdown
                            const fsPresetSelect = document.getElementById('fsPresetSelect');
                            if (fsPresetSelect && this.savedPresets) {
                                fsPresetSelect.innerHTML = '<option value="">Load Preset...</option>';
                                this.savedPresets.forEach((preset, index) => {
                                    const option = document.createElement('option');
                                    option.value = index;
                                    option.textContent = preset.name;
                                    fsPresetSelect.appendChild(option);
                                });
                            }

                            // Sync other control states
                            const fsPlayBtn = document.getElementById('fsPlayBtn');
                            if (fsPlayBtn) {
                                fsPlayBtn.innerHTML = this.isPlaying ? '⏸' : '▶';
                            }

                            const fsLoopBtn = document.getElementById('fsLoopBtn');
                            const fsLoopIndicator = document.getElementById('fsLoopIndicator');
                            if (fsLoopBtn && fsLoopIndicator) {
                                switch (this.loopMode) {
                                    case 'off': fsLoopBtn.classList.remove('active');
                                        fsLoopIndicator.style.display = 'none';
                                        break;
                                    case 'one': fsLoopBtn.classList.add('active');
                                        fsLoopIndicator.style.display = 'flex';
                                        fsLoopIndicator.textContent = '1';
                                        break;
                                    case 'all': fsLoopBtn.classList.add('active');
                                        fsLoopIndicator.style.display = 'flex';
                                        fsLoopIndicator.textContent = 'A';
                                        break;
                                }
                            }

                            const fsMorphBtn = document.getElementById('fsMorphBtn');
                            if (fsMorphBtn) {
                                fsMorphBtn.classList.toggle('active', this.isMorphing);
                            }

                            const fsVolumeFill = document.getElementById('fsVolumeFill');
                            if (fsVolumeFill) {
                                fsVolumeFill.style.width = `${
                                    this.volume * 100
                                }%`;
                            }

                            const fsVizSelect = document.getElementById('fsVizSelect');
                            if (fsVizSelect) {
                                fsVizSelect.value = this.currentMode;
                            }

                            const fsColorSelect = document.getElementById('fsColorSelect');
                            if (fsColorSelect) {
                                fsColorSelect.value = this.currentColorScheme;
                            }

                            const fsMorphSpeed = document.getElementById('fsMorphSpeed');
                            if (fsMorphSpeed) {
                                fsMorphSpeed.value = this.morphMode;
                            }

                            const fsBgColorPicker = document.getElementById('fsBgColorPicker');
                            if (fsBgColorPicker) {
                                fsBgColorPicker.value = this.backgroundColor;
                            }

                            const fsTrackTitle = document.getElementById('fsTrackTitle');
                            if (fsTrackTitle && this.playlist[this.currentTrackIndex]) {
                                fsTrackTitle.textContent = this.playlist[this.currentTrackIndex].name;
                            }

                        } else {
                            document.body.classList.remove('fullscreen-mode');

                            // Remove mouse movement listener
                            if (this.fullscreenMouseHandler) {
                                document.removeEventListener('mousemove', this.fullscreenMouseHandler);
                            }
                            if (this.controlsTimeout) {
                                clearTimeout(this.controlsTimeout);
                            }

                            if (fsControls) {
                                document.body.appendChild(fsControls);
                                fsControls.style.display = 'none';
                                fsControls.classList.remove('hidden');
                            }

                            if (exitBtn) {
                                exitBtn.style.display = 'none';
                            }

                            if (visualizationContainer && visualizationContainer.style.position === 'fixed') {
                                visualizationContainer.style.position = '';
                                visualizationContainer.style.top = '';
                                visualizationContainer.style.left = '';
                                visualizationContainer.style.width = '';
                                visualizationContainer.style.height = '';
                                visualizationContainer.style.zIndex = '';
                            }
                        }
                    };

                    document.addEventListener('fullscreenchange', fullscreenChangeHandler);
                    document.addEventListener('mozfullscreenchange', fullscreenChangeHandler);
                    document.addEventListener('webkitfullscreenchange', fullscreenChangeHandler);
                    document.addEventListener('msfullscreenchange', fullscreenChangeHandler);

                    // Keyboard controls
                    document.addEventListener('keydown', async (e) => {
                        if (e.target.tagName === 'INPUT') 
                            return;
                        


                        switch (e.code) {
                            case 'Space':
                                e.preventDefault();
                                await this.togglePlay();
                                break;
                            case 'ArrowLeft':
                                e.preventDefault();
                                await this.prevTrack();
                                break;
                            case 'ArrowRight':
                                e.preventDefault();
                                await this.nextTrack();
                                break;
                            case 'ArrowUp':
                                e.preventDefault();
                                this.setVolume(Math.min(1, this.volume + 0.05));
                                break;
                            case 'ArrowDown':
                                e.preventDefault();
                                this.setVolume(Math.max(0, this.volume - 0.05));
                                break;
                            case 'KeyF':
                                e.preventDefault();
                                this.toggleFullscreen();
                                break;
                            case 'KeyR':
                                e.preventDefault();
                                this.setRandomVisualization();
                                break;
                            case 'KeyM':
                                e.preventDefault();
                                this.toggleMorph();
                                break;
                            case 'KeyL':
                                e.preventDefault();
                                this.toggleLoop();
                                break;
                            case 'Escape':
                                e.preventDefault();
                                this.exitFullscreen();
                                this.closeInfoPopup();
                                break;
                        }
                    });

                    // Touch/swipe gestures for mobile
                    let touchStartX = 0;
                    let touchStartY = 0;

                    document.addEventListener('touchstart', (e) => {
                        touchStartX = e.changedTouches[0].screenX;
                        touchStartY = e.changedTouches[0].screenY;
                    }, {passive: true});

                    document.addEventListener('touchend', (e) => {
                        const touchEndX = e.changedTouches[0].screenX;
                        const touchEndY = e.changedTouches[0].screenY;
                        const diffX = touchEndX - touchStartX;
                        const diffY = touchEndY - touchStartY;

                        if (Math.abs(diffX) > 50) {
                            if (diffX > 0) {
                                this.prevTrack();
                            } else {
                                this.nextTrack();
                            }
                        }

                        if (Math.abs(diffY) > 50) {
                            if (diffY > 0) {
                                this.setVolume(Math.max(0, this.volume - 0.1));
                            } else {
                                this.setVolume(Math.min(1, this.volume + 0.1));
                            }
                        }
                    }, {passive: true});
                }

                // Show/Hide full screen controls
                showFullscreenControls() {
                    const fsControls = document.getElementById('fullscreenControls');
                    if (fsControls && this.isFullscreen) {
                        fsControls.classList.remove('hidden');
                        this.controlsVisible = true;

                        // Clear existing timeout
                        if (this.controlsTimeout) {
                            clearTimeout(this.controlsTimeout);
                        }

                        // Set new timeout
                        this.controlsTimeout = setTimeout(() => {
                            this.hideFullscreenControls();
                        }, 5000);
                    }
                }

                hideFullscreenControls() {
                    const fsControls = document.getElementById('fullscreenControls');
                    if (fsControls && this.isFullscreen) {
                        fsControls.classList.add('hidden');
                        this.controlsVisible = false;
                    }
                }

                // *end evenlisteners
                updatePlaylistDropdown() {
                    const dropdown = document.getElementById('playlistDropdown');
                    if (!dropdown) return;
                    
                    // Check if we have new playlist content - if so, don't overwrite it
                    const hasNewContent = dropdown.querySelector('.playlist-actions-dropdown');
                    if (hasNewContent) {
                        console.log('Preserving new playlist content, skipping old dropdown update');
                        return;
                    }
                    
                    // Only clear and populate if using old hardcoded system
                    dropdown.innerHTML = '';

                    const playlistData = document.querySelectorAll('#playlistData .playlist-data-item');
                    let trackIndex = 0;

                    playlistData.forEach(item => {
                        if (item.dataset.type === 'album') {
                            const albumDiv = document.createElement('div');
                            albumDiv.className = 'playlist-album-cover';
                            albumDiv.innerHTML = `
                    <img src="${
                                item.dataset.image
                            }" alt="${
                                item.dataset.name
                            }">
                    <div class="playlist-album-name">${
                                item.dataset.name
                            }</div>
                `;
                            dropdown.appendChild(albumDiv);

                        } else if (item.dataset.type === 'track') {
                            const trackDiv = document.createElement('div');
                            trackDiv.className = 'playlist-dropdown-item';

                            if (trackIndex === this.currentTrackIndex) {
                                trackDiv.classList.add('active');
                            }

                            const currentTrackIndex = trackIndex;
                            trackDiv.innerHTML = `
                    <div class="playlist-album-icon">
                        <img src="${
                                item.dataset.image
                            }" alt="${
                                item.dataset.name
                            }">
                    </div>
                    <div class="playlist-track-name">${
                                item.dataset.name
                            }</div>
                `;

                            trackDiv.addEventListener('click', () => {
                                this.selectTrack(currentTrackIndex);
                                document.getElementById('playlistDropdown').classList.remove('show');
                            });

                            dropdown.appendChild(trackDiv);
                            trackIndex++;
                        }
                    });
                }

                showInfoPopup() {
                    document.getElementById('infoPopup').classList.add('active');
                    document.getElementById('popupOverlay').classList.add('active');
                }

                closeInfoPopup() {
                    document.getElementById('infoPopup').classList.remove('active');
                    document.getElementById('popupOverlay').classList.remove('active');
                }

                // Morph Methods
                startMorphing() {
                    if (this.isMorphing) {
                        this.stopMorphing();
                        return;
                    }

                    this.isMorphing = true;

                    const morphBtn = document.getElementById('morphBtn');
                    if (morphBtn) {
                        morphBtn.classList.add('active');
                        const btnText = morphBtn.querySelector('.morph-btn-text');
                        if (btnText) {
                            btnText.textContent = 'Stop Morph';
                        }
                    }

                    // Make sure energy history is initialized
                    this.energyHistory = this.energyHistory || [];
                    this.currentEnergy = 0;
                    this.lastEnergy = 0;

                    if (this.morphMode === 'energy') {
                        this.startEnergyDetection();
                        const energyContainer = document.getElementById('energyContainer');
                        if (energyContainer) {
                            energyContainer.style.display = 'block';
                        }
                    }

                    this.morphStartConfig = this.getCurrentConfig();

                    // Store MORE locked parameters to prevent visual jumps
                    this.lockedMorphParams = {
                        radial: this.morphStartConfig.radial,
                        mirror: this.morphStartConfig.mirror,
                        ledBars: this.morphStartConfig.ledBars,
                        ansiBands: this.morphStartConfig.ansiBands,
                        mode: this.morphStartConfig.mode,
                        channelLayout: this.morphStartConfig.channelLayout,
                        frequencyScale: this.morphStartConfig.frequencyScale, // Lock this
                        spinSpeed: this.morphStartConfig.spinSpeed, // Lock spin speed
                        spinAngle: this.audioMotion ? this.audioMotion.spinAngle : 0 // Preserve current angle
                    };

                    this.generateNewMorphTarget();
                    this.morphProgress = 0;

                    this.morphInterval = setInterval(() => {
                        this.updateMorph();
                    }, 50);
                }

                stopMorphing() {
                    this.isMorphing = false;
                    this.lockedMorphParams = null;

                    if (this.morphInterval) {
                        clearInterval(this.morphInterval);
                        this.morphInterval = null;
                    }

                    if (this.energyCheckInterval) {
                        clearInterval(this.energyCheckInterval);
                        this.energyCheckInterval = null;
                    }

                    const morphBtn = document.getElementById('morphBtn');
                    if (morphBtn) {
                        morphBtn.classList.remove('active');
                        const btnText = morphBtn.querySelector('.morph-btn-text');
                        if (btnText) {
                            btnText.textContent = 'Start Morph';
                        }
                    }

                    // Hide energy indicator
                    const energyContainer = document.getElementById('energyContainer');
                    if (energyContainer) {
                        energyContainer.style.display = 'none';
                    }
                }

                startEnergyDetection() {
                    if (this.energyCheckInterval) {
                        clearInterval(this.energyCheckInterval);
                    }

                    this.energyCheckInterval = setInterval(() => {
                        this.detectEnergy();
                    }, 100);
                }

                detectEnergy() {
                    if (!this.audioMotion || !this.audioMotion.dataArray) 
                        return;
                    


                    let energy = 0;
                    const dataArray = this.audioMotion.dataArray;

                    const bassEnd = Math.min(Math.floor(dataArray.length * 0.1), dataArray.length);
                    for (let i = 0; i < bassEnd; i++) {
                        energy += dataArray[i];
                    }
                    energy = energy / bassEnd / 255;

                    this.energyHistory.push(energy);
                    if (this.energyHistory.length > 10) {
                        this.energyHistory.shift();
                    }

                    this.lastEnergy = this.currentEnergy;
                    this.currentEnergy = this.energyHistory.reduce((a, b) => a + b, 0) / this.energyHistory.length;

                    if (this.morphMode === 'energy') {
                        this.updateMorphSpeedFromEnergy();
                    }

                    const energyIndicator = document.getElementById('energyIndicator');
                    if (energyIndicator) {
                        energyIndicator.style.width = `${
                            this.currentEnergy * 100
                        }%`;
                        const hue = 120 - (this.currentEnergy * 120);
                        energyIndicator.style.background = `hsl(${hue}, 100%, 50%)`;
                    }
                }

                updateMorphSpeedFromEnergy() {
                    const minDuration = 1500;
                    const maxDuration = 8000;

                    this.morphDuration = minDuration + (1 - this.currentEnergy) * (maxDuration - minDuration);

                    if (this.currentEnergy > 0.7 && this.lastEnergy < 0.6) {
                        this.morphProgress = 0;
                        this.morphStartConfig = this.getCurrentConfig();
                        this.generateNewMorphTarget();
                    }
                }

                updateMorph() {
                    if (!this.isMorphing || !this.audioMotion) 
                        return;
                    


                    this.morphProgress += 50 / this.morphDuration;

                    if (this.morphProgress >= 1) {
                        this.morphProgress = 1;

                        this.applyMorphConfig(this.morphTargetConfig);

                        this.morphStartConfig = this.morphTargetConfig;
                        this.generateNewMorphTarget();
                        this.morphProgress = 0;
                    } else {
                        const easedProgress = this.easeInOutCubic(this.morphProgress);
                        const currentConfig = this.interpolateConfigs(this.morphStartConfig, this.morphTargetConfig, easedProgress);

                        this.applyMorphConfig(currentConfig);
                    }
                }

                interpolateConfigs(start, target, progress) {
                    const config = {};

                    // Always use locked parameters if they exist
                    if (this.lockedMorphParams) {
                        Object.assign(config, this.lockedMorphParams);
                    }

                    // Interpolate ONLY numeric properties that should smoothly transition
                    const numericProps = [
                        'barSpace',
                        'fillAlpha',
                        'smoothing',
                        'reflexRatio',
                        'reflexAlpha',
                        'lineWidth',
                        'radius',
                        'bgAlpha',
                        'maxDecibels',
                        'minDecibels',
                        'linearBoost',
                        'volume'
                    ];

                    numericProps.forEach(prop => {
                        if (start[prop] !== undefined && target[prop] !== undefined) {
                            config[prop] = start[prop] + (target[prop] - start[prop]) * progress;
                        }
                    });

                    // Keep these properties from start config to prevent jumps
                    config.gradient = start.gradient;
                    config.showPeaks = start.showPeaks;
                    config.roundBars = start.roundBars;
                    config.outlineBars = start.outlineBars;
                    config.linearAmplitude = start.linearAmplitude;

                    // Only switch these at the END of morph (when starting new morph)
                    if (progress >= 1) {
                        config.gradient = target.gradient;
                        config.showPeaks = target.showPeaks;
                        config.roundBars = target.roundBars;
                        config.outlineBars = target.outlineBars;
                    }

                    // Always include these critical properties
                    config.fftSize = 8192;

                    return config;
                }

                easeInOutCubic(t) { // Make the easing even smoother
                    if (t < 0.5) {
                        return 4 * t * t * t;
                    } else {
                        const p = 2 * t - 2;
                        return 1 + p * p * p / 2;
                    }
                }

                toggleMorph() {
                    if (this.isMorphing) {
                        this.stopMorphing();
                    } else {
                        this.startMorphing();
                    }
                }

                setMorphSpeed(speed) {
                    this.morphMode = speed;

                    if (speed === 'energy') {
                        if (this.isMorphing) {
                            this.startEnergyDetection();
                        }
                        const energyContainer = document.getElementById('energyContainer');
                        if (energyContainer) {
                            energyContainer.style.display = 'block';
                        }
                    } else {
                        if (this.energyCheckInterval) {
                            clearInterval(this.energyCheckInterval);
                            this.energyCheckInterval = null;
                        }

                        const energyContainer = document.getElementById('energyContainer');
                        if (energyContainer) {
                            energyContainer.style.display = 'none';
                        }

                        const speeds = {
                            slow: 10000,
                            medium: 5000,
                            fast: 2000,
                            ultra: 1000
                        };
                        this.morphDuration = speeds[speed] || 5000;
                    }
                }

                // Fullscreen Methods
                toggleFullscreen() {
                    const visualizationContainer = document.querySelector('.visualization-container');
                    const appContainer = document.querySelector('.app-container');
                    const exitBtn = document.getElementById('fullscreenExitBtn');

                    if (!document.fullscreenElement && !document.mozFullScreenElement && !document.webkitFullscreenElement && !document.msFullscreenElement) {

                        const element = visualizationContainer || appContainer || document.documentElement;

                        if (exitBtn) {
                            exitBtn.style.display = 'flex';
                        }

                        if (element.requestFullscreen) {
                            element.requestFullscreen().catch(err => {
                                console.error('Error attempting fullscreen:', err);
                                this.fallbackFullscreen();
                            });
                        } else if (element.mozRequestFullScreen) {
                            element.mozRequestFullScreen();
                        } else if (element.webkitRequestFullscreen) {
                            element.webkitRequestFullscreen();
                        } else if (element.webkitEnterFullscreen) {
                            element.webkitEnterFullscreen();
                        } else if (element.msRequestFullscreen) {
                            element.msRequestFullscreen();
                        } else {
                            this.fallbackFullscreen();
                        }
                    } else {
                        this.exitFullscreen();
                    }
                }

                fallbackFullscreen() {
                    const visualizationContainer = document.querySelector('.visualization-container');
                    const randomBtn = document.getElementById('fullscreenRandomBtn');
                    const exitBtn = document.getElementById('fullscreenExitBtn');

                    if (visualizationContainer) {
                        visualizationContainer.style.position = 'fixed';
                        visualizationContainer.style.top = '0';
                        visualizationContainer.style.left = '0';
                        visualizationContainer.style.width = '100vw';
                        visualizationContainer.style.height = '100vh';
                        visualizationContainer.style.zIndex = '9999';
                        document.body.classList.add('fullscreen-mode');
                        this.isFullscreen = true;

                        if (randomBtn) {
                            visualizationContainer.appendChild(randomBtn);
                            randomBtn.style.display = 'block';
                        }

                        if (exitBtn) {
                            exitBtn.style.display = 'flex';
                        }
                    }
                }

                exitFullscreen() {
                    const randomBtn = document.getElementById('fullscreenRandomBtn');
                    const exitBtn = document.getElementById('fullscreenExitBtn');

                    if (document.fullscreenElement || document.mozFullScreenElement || document.webkitFullscreenElement || document.msFullscreenElement) {

                        if (document.exitFullscreen) {
                            document.exitFullscreen();
                        } else if (document.mozCancelFullScreen) {
                            document.mozCancelFullScreen();
                        } else if (document.webkitExitFullscreen) {
                            document.webkitExitFullscreen();
                        } else if (document.msExitFullscreen) {
                            document.msExitFullscreen();
                        }
                    } else if (this.isFullscreen) {
                        const visualizationContainer = document.querySelector('.visualization-container');
                        if (visualizationContainer) {
                            visualizationContainer.style.position = '';
                            visualizationContainer.style.top = '';
                            visualizationContainer.style.left = '';
                            visualizationContainer.style.width = '';
                            visualizationContainer.style.height = '';
                            visualizationContainer.style.zIndex = '';
                            document.body.classList.remove('fullscreen-mode');
                            this.isFullscreen = false;
                        }
                    }

                    if (randomBtn) {
                        document.body.appendChild(randomBtn);
                        randomBtn.style.display = 'none';
                    }

                    if (exitBtn) {
                        exitBtn.style.display = 'none';
                    }
                }

                // Playlist Methods
                loadPlaylist() {
                    this.playlist = [];
                    const playlistData = document.querySelectorAll('#playlistData .playlist-data-item[data-type="track"]');

                    playlistData.forEach(item => {
                        this.playlist.push({
                            name: item.dataset.name,
                            url: item.dataset.url,
                            image: item.dataset.image || 'https://content.app-sources.com/s/810881111918650241/uploads/Images/Icon-3589409.jpg'
                        });
                    });

                    this.updatePlaylistDropdown();
                }

                async preloadTrack(index) {
                    if (index < 0 || index >= this.playlist.length) 
                        return;
                    


                    try {
                        if (this.audio) {
                            this.audio.pause();
                            if (this.audioMotion) {
                                this.audioMotion.disconnectInput();
                            }
                        }

                        this.audio = new Audio();
                        this.audio.crossOrigin = 'anonymous';
                        this.audio.src = this.playlist[index].url;
                        this.audio.volume = this.volume;

                        await new Promise((resolve, reject) => {
                            this.audio.addEventListener('canplay', resolve, {once: true});
                            this.audio.addEventListener('error', reject, {once: true});
                            setTimeout(() => resolve(), 3000);
                        });

                        this.audio.addEventListener('timeupdate', () => this.updateProgress());
                        this.audio.addEventListener('ended', () => this.handleTrackEnd());
                        this.audio.addEventListener('error', (e) => {
                            console.error('Audio error:', e);
                            this.showError('Failed to load audio track');
                        });

                        if (this.audioMotion) {
                            this.audioMotion.connectInput(this.audio);
                        }

                        this.currentTrackIndex = index;
                        this.updateTrackInfo();
                        this.updatePlaylistDropdown();

                    } catch (error) {
                        console.error('Failed to preload track:', error);
                        this.showError('Failed to load track: ' + error.message);
                    }
                }

                async selectTrack(index) {
                    await this.preloadTrack(index);
                    if (this.isPlaying) {
                        await this.play();
                    }
                }

                async togglePlay() {
                    if (!this.audio || !this.audioInitialized) {
                        await this.initializeFirstTrack();
                    }

                    if (this.isPlaying) {
                        this.pause();
                    } else {
                        await this.play();
                    }
                }

                async play() {
                    if (!this.audio) {
                        await this.initializeFirstTrack();
                        document.getElementById('fsPlayBtn').innerHTML = '⏸';
                    }

                    try {
                        if (this.audioMotion && this.audioMotion.audioCtx) {
                            if (this.audioMotion.audioCtx.state === 'suspended') {
                                await this.audioMotion.audioCtx.resume();
                            }
                        }

                        await this.audio.play();
                        this.isPlaying = true;
                        document.getElementById('playBtn').innerHTML = '⏸';
                    } catch (error) {
                        console.error('Playback failed:', error);
                        if (error.name === 'NotAllowedError') {
                            this.showError('Click play again to start playback');
                        } else {
                            this.showError('Playback failed. Please try again.');
                        }
                    }
                }

                pause() {
                    if (!this.audio) 
                        return;
                    


                    this.audio.pause();
                    this.isPlaying = false;
                    document.getElementById('playBtn').innerHTML = '▶';
                }

                async nextTrack() {
                    const nextIndex = (this.currentTrackIndex + 1) % this.playlist.length;
                    await this.selectTrack(nextIndex);
                }

                async prevTrack() {
                    const prevIndex = (this.currentTrackIndex - 1 + this.playlist.length) % this.playlist.length;
                    await this.selectTrack(prevIndex);
                }

                toggleLoop() {
                    const modes = ['off', 'one', 'all'];
                    const currentIndex = modes.indexOf(this.loopMode);
                    this.loopMode = modes[(currentIndex + 1) % modes.length];

                    const loopBtn = document.getElementById('loopBtn');
                    const loopIndicator = document.getElementById('loopIndicator');

                    switch (this.loopMode) {
                        case 'off': loopBtn.classList.remove('active');
                            loopIndicator.style.display = 'none';
                            loopBtn.title = 'Toggle Loop (Off)';
                            if (this.audio) 
                                this.audio.loop = false;
                            

                            break;
                        case 'one': loopBtn.classList.add('active');
                            loopIndicator.style.display = 'flex';
                            loopIndicator.textContent = '1';
                            loopBtn.title = 'Toggle Loop (One)';
                            if (this.audio) 
                                this.audio.loop = true;
                            

                            break;
                        case 'all': loopBtn.classList.add('active');
                            loopIndicator.style.display = 'flex';
                            loopIndicator.textContent = 'A';
                            loopBtn.title = 'Toggle Loop (All)';
                            if (this.audio) 
                                this.audio.loop = false;
                            

                            break;
                    }
                }

                async handleTrackEnd() {
                    if (this.loopMode === 'one') {
                        return;
                    } else if (this.loopMode === 'all') {
                        await this.nextTrack();
                    } else {
                        this.pause();
                    }
                }

                setVolume(value) {
                    this.volume = value;
                    if (this.audio) {
                        this.audio.volume = value;
                    }
                    document.getElementById('volumeFill').style.width = `${
                        value * 100
                    }%`;

                    // Update mute state
                    if (value === 0 && !this.isMuted) {
                        this.isMuted = true;
                    } else if (value > 0 && this.isMuted) {
                        this.isMuted = false;
                        this.previousVolume = value;
                    }
                }

                toggleMute() {
                    const volumeIcon = document.querySelector('.volume-control span');

                    if (this.isMuted) { // Unmute
                        this.setVolume(this.previousVolume);
                        this.isMuted = false;
                        if (volumeIcon) 
                            volumeIcon.textContent = '🔊';
                        

                    } else { // Mute
                        this.previousVolume = this.volume;
                        this.setVolume(0);
                        this.isMuted = true;
                        if (volumeIcon) 
                            volumeIcon.textContent = '🔇';
                        

                    }
                }

                updateProgress() {
                    if (!this.audio || !this.audio.duration) 
                        return;
                    


                    const percent = (this.audio.currentTime / this.audio.duration) * 100;
                    document.getElementById('progressFill').style.width = `${percent}%`;

                    const current = this.formatTime(this.audio.currentTime);
                    const total = this.formatTime(this.audio.duration);
                    document.getElementById('timeDisplay').textContent = `${current} / ${total}`;

                    const fsProgressFill = document.getElementById('fsProgressFill');
                    if (fsProgressFill) {
                        fsProgressFill.style.width = `${percent}%`;
                    }
                    const fsTimeDisplay = document.getElementById('fsTimeDisplay');
                    if (fsTimeDisplay) {
                        fsTimeDisplay.textContent = `${current} / ${total}`;
                    }
                }

                updateTrackInfo() {
                    const track = this.playlist[this.currentTrackIndex];
                    if (track) {
                        document.getElementById('trackTitle').textContent = track.name;
                        document.getElementById('playlistToggle').textContent = track.name;
                    }
                    const fsTrackTitle = document.getElementById('fsTrackTitle');
                    if (fsTrackTitle) {
                        fsTrackTitle.textContent = track.name;
                    }
                    const fsPlaylistSelect = document.getElementById('fsPlaylistSelect');
                    if (fsPlaylistSelect) {
                        fsPlaylistSelect.value = this.currentTrackIndex;
                    }
                }

                // Utility Methods
                formatTime(seconds) {
                    if (!seconds || isNaN(seconds)) 
                        return '0:00';
                    


                    const minutes = Math.floor(seconds / 60);
                    const secs = Math.floor(seconds % 60);
                    return `${minutes}:${
                        secs.toString().padStart(2, '0')
                    }`;
                }

                showLoading() {
                    document.getElementById('loading').style.display = 'block';
                    document.getElementById('error').style.display = 'none';
                }

                hideLoading() {
                    document.getElementById('loading').style.display = 'none';
                }

                showError(message) {
                    const errorDiv = document.getElementById('error');
                    const errorText = document.getElementById('error-text');

                    errorDiv.style.display = 'block';
                    errorText.textContent = message;
                    document.getElementById('loading').style.display = 'none';

                    setTimeout(() => {
                        errorDiv.style.display = 'none';
                    }, 5000);

                    errorDiv.onclick = () => {
                        errorDiv.style.display = 'none';
                    };
                }
            }

            // Initialize the visualizer
            let visualizer;

        document.addEventListener('DOMContentLoaded', () => {
            window.visualizer = new GitItUpVisualizer();
            
            // Add resize listener for Infinite Zoom
            window.addEventListener('resize', () => {
                if (window.visualizer && window.visualizer.infiniteZoom) {
                    window.visualizer.infiniteZoom.resize();
                }
            });
        });

        // Global function for closing info popup
        function closeInfoPopup() {
            if (window.visualizer) {
                window.visualizer.closeInfoPopup();
            }
        }
        </script>
</body>
</html>

